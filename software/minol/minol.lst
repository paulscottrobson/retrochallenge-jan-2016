 AS V1.42 Beta [Bld 102] - source file minol.asm - page 1 - 1/11/2016 13:50:19


       1/       0 :                     ; ****************************************************************************************************************
       2/       0 :                     ; ****************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;												Minol ROM Image
       5/       0 :                     ;
       6/       0 :                     ; ****************************************************************************************************************
       7/       0 :                     ; ****************************************************************************************************************
       8/       0 :                     
       9/       0 :                     	cpu 	sc/mp
      10/       0 :                     
      11/       0 :                     	include source\memorymacros.asm 							; Memory allocation and Macro definition.	
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;										Memory and Macro Allocation.
(1)    5/       0 :                     ;	
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0x3                OSMathLibrary = 0x0003 											; the Maths library is here.
(1)   10/       0 : =0x210              BootMonitor = 0x210 											; address to boot monitor
(1)   11/       0 :                     
(1)   12/       0 :                     ; ****************************************************************************************************************
(1)   13/       0 :                     ;												 Memory Allocation
(1)   14/       0 :                     ; ****************************************************************************************************************
(1)   15/       0 :                     
(1)   16/       0 : =0xC00              ScreenMirror = 0xC00 											; Screen mirror, 128 bytes, 256 byte page boundary.
(1)   17/       0 : =0xC80              ScreenCursor = ScreenMirror+0x80  								; Position on that screen (00..7F)
(1)   18/       0 :                     
(1)   19/       0 : =0xC90              SystemMemory = 0xC90 											; System Memory
(1)   20/       0 :                     
(1)   21/       0 : =0xC8E              RandomSeed = SystemMemory-2										; Random Seed Value (2 bytes)
(1)   22/       0 : =0xC8D              CurrentLine = SystemMemory-3 									; Current Line Number (1 byte)
(1)   23/       0 : =0xC90              Variables = SystemMemory 										; Variables (26 bytes)
(1)   24/       0 :                     
(1)   25/       0 :                     ; ****************************************************************************************************************
(1)   26/       0 :                     ;														Macros
(1)   27/       0 :                     ; ****************************************************************************************************************
(1)   28/       0 :                     
(1)   29/       0 :                     lpi	macro	ptr,addr											; load pointer register with constant
(1)   30/       0 :                     	ldi 	(addr) / 256
(1)   31/       0 :                     	xpah 	ptr
(1)   32/       0 :                     	ldi 	(addr) & 255
(1)   33/       0 :                     	xpal 	ptr
(1)   34/       0 :                     	endm
(1)   35/       0 :                     
(1)   36/       0 :                     pushp macro ptr 												; push pointer register on stack
(1)   37/       0 :                     	xpah 	ptr
(1)   38/       0 :                     	st 		@-1(p2)
(1)   39/       0 :                     	xpal 	ptr
(1)   40/       0 :                     	st 		@-1(p2)
(1)   41/       0 :                     	endm
(1)   42/       0 :                     
(1)   43/       0 :                     pullp macro ptr 												; pull pointer register off stack
(1)   44/       0 :                     	ld 		@1(p2)
(1)   45/       0 :                     	xpal 	ptr
(1)   46/       0 :                     	ld 		@1(p2)
(1)   47/       0 :                     	xpah 	ptr
(1)   48/       0 :                     	endm
(1)   49/       0 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(memorymacros.asm) - page 2 - 1/11/2016 13:50:19


(1)   50/       0 :                     pushe macro 													; push E on stack
(1)   51/       0 :                     	lde
(1)   52/       0 :                     	st 		@-1(p2)
(1)   53/       0 :                     	endm
(1)   54/       0 :                     
(1)   55/       0 :                     pulle macro 													; pull E off stack
(1)   56/       0 :                     	ld 		@1(p2)
(1)   57/       0 :                     	xae
(1)   58/       0 :                     	endm
(1)   59/       0 :                     
(1)   60/       0 :                     pusha macro 													; push A on stack
(1)   61/       0 :                     	st 		@-1(p2)
(1)   62/       0 :                     	endm
(1)   63/       0 :                     
(1)   64/       0 :                     pulla macro
(1)   65/       0 :                     	ld 		@1(p2)
(1)   66/       0 :                     	endm
(1)   67/       0 :                     
(1)   68/       0 :                     setv macro ch,value 											; sets a variable to a value, assumes P3 = Variables.
(1)   69/       0 :                     	ldi 	(value) & 255
(1)   70/       0 :                     	st 		((ch) - 'A')(p3)
(1)   71/       0 :                     	endm
(1)   72/       0 :                     
(1)   73/       0 :                     code macro lineNo,code 											; a debugging macro, which fakes up a line of code.
(1)   74/       0 :                     	db 		strlen(code)+3 										; one byte offset to next (255 = End of code)
(1)   75/       0 :                     	db 		lineNo 												; one byte line number 
(1)   76/       0 :                     	db 		code,0 												; ASCIIZ string
(1)   77/       0 :                     	endm
(1)   78/       0 :                     
(1)   79/       0 :                     cmd macro 	c1,c2,length,code
(1)   80/       0 :                     	db 		c1,c2 												; first and second characters
(1)   81/       0 :                     	db 		(length)-1											; length -1 (first char already skipped)
(1)   82/       0 :                     	dw 		(code)-1 											; execution point for prefetch.
(1)   83/       0 :                     	endm
      12/       0 :                     	include source\errors.asm 									; Error Codes
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;												Error Codes
(1)    5/       0 :                     ;
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0xFF               ERRC_END = 0xFF													; psuedo error, program stopped. Does "OK" as for no error.
(1)   10/       0 : =0x1                ERRC_LABEL = 1 													; Label does not exist (e.g. GOTO)
(1)   11/       0 : =0x2                ERRC_UNKNOWN = 2												; Unknown instruction
(1)   12/       0 : =0x4                ERRC_TERM = 4 													; Illegal term/expression
(1)   13/       0 : =0x5                ERRC_SYNTAX = 5													; Syntax Error
(1)   14/       0 : =0x6                ERRC_MEMORY = 6 												; Out of memory
(1)   15/       0 : =0x7                ERRC_DIVZERO = 7 												; Division by Zero Error.
(1)   16/       0 :                     
      13/       0 :                     
      14/       0 :                     ; ****************************************************************************************************************
      15/       0 :                     ; ****************************************************************************************************************
      16/       0 :                     ; 	NOTE: When executing line follow the line with $FF so it thinks it has reached the program end.
      17/       0 :                     ; ****************************************************************************************************************
      18/       0 :                     ; ****************************************************************************************************************
      19/       0 :                     
      20/       0 :                     
      21/       0 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 3 - 1/11/2016 13:50:19


      22/       0 :                     ;													Main Program
      23/       0 :                     ; ****************************************************************************************************************
      24/       0 :                     
      25/    9000 :                     	org 	0x9000 												; the ROM starts here
      26/    9000 :                     
      27/    9000 : 68                  	db 		0x68												; this makes it boot straight into this ROM.
      28/    9001 : (MACRO)             	lpi 	p2,0xFF8											; set up stack default value
      28/    9001 : C4 0F                       ldi     (0XFF8) / 256
      28/    9003 : 36                          xpah    P2
      28/    9004 : C4 F8                       ldi     (0XFF8) & 255
      28/    9006 : 32                          xpal    P2
      29/    9007 : (MACRO)             	lpi 	p3,Print-1
      29/    9007 : C4 91                       ldi     (PRINT-1) / 256
      29/    9009 : 37                          xpah    P3
      29/    900A : C4 96                       ldi     (PRINT-1) & 255
      29/    900C : 33                          xpal    P3
      30/    900D : C4 0C               	ldi 	12
      31/    900F : 3F                  	xppc	p3
      32/    9010 :                     
      33/    9010 : (MACRO)             	lpi 	p3,SystemMemory
      33/    9010 : C4 0C                       ldi     (SYSTEMMEMORY) / 256
      33/    9012 : 37                          xpah    P3
      33/    9013 : C4 90                       ldi     (SYSTEMMEMORY) & 255
      33/    9015 : 33                          xpal    P3
      34/    9016 : (MACRO)             	lpi 	p3,CMD_Run-1
      34/    9016 : C4 94                       ldi     (CMD_RUN-1) / 256
      34/    9018 : 37                          xpah    P3
      34/    9019 : C4 C1                       ldi     (CMD_RUN-1) & 255
      34/    901B : 33                          xpal    P3
      35/    901C : 3F                  	xppc	p3
      36/    901D :                     
      37/    901D :                     wait1:	
      38/    901D : 90 FE               	jmp 	wait1
      39/    901F :                     
      40/    901F :                     
      41/    901F :                     ProgramBase:
      42/    901F : (MACRO)             	code 	1,"\"START\":CLEAR:GOTO 240"
      42/    901F : 19                          db              strlen("\"START\":CLEAR:GOTO 240")+3                                                                          ; one byte offset to next (255 = End of "\"START\":CLEAR:GOTO 240")
      42/    9020 : 01                          db              1                                                                                          ; one byte line number 
      42/    9021 : 22 53 54 41 52 54           db              "\"START\":CLEAR:GOTO 240",0                                                                                          ; ASCIIZ string
                    22 3A 43 4C 45 41 
                    52 3A 47 4F 54 4F 
                    20 32 34 30 00 
      43/    9038 : (MACRO)             	code 	10,"HELLO WORLD"
      43/    9038 : 0E                          db              strlen("HELLO WORLD")+3                                                                          ; one byte offset to next (255 = End of "HELLO WORLD")
      43/    9039 : 0A                          db              10                                                                                          ; one byte line number 
      43/    903A : 48 45 4C 4C 4F 20           db              "HELLO WORLD",0                                                                                          ; ASCIIZ string
                    57 4F 52 4C 44 00 
      44/    9046 : (MACRO)             	code 	20,"GOTO 20"
      44/    9046 : 0A                          db              strlen("GOTO 20")+3                                                                          ; one byte offset to next (255 = End of "GOTO 20")
      44/    9047 : 14                          db              20                                                                                          ; one byte line number 
      44/    9048 : 47 4F 54 4F 20 32           db              "GOTO 20",0                                                                                          ; ASCIIZ string
                    30 00 
      45/    9050 : (MACRO)             	code 	30,"LETB=69:LETA=42:C=A+B:END"
      45/    9050 : 1C                          db              strlen("LETB=69:LETA=42:C=A+B:END")+3                                                                          ; one byte offset to next (255 = End of "LETB=69:LETA=42:C=A+B:END")
      45/    9051 : 1E                          db              30                                                                                          ; one byte line number 
      45/    9052 : 4C 45 54 42 3D 36           db              "LETB=69:LETA=42:C=A+B:END",0                                                                                          ; ASCIIZ string
                    39 3A 4C 45 54 41 
                    3D 34 32 3A 43 3D 
                    41 2B 42 3A 45 4E 
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 4 - 1/11/2016 13:50:19


                    44 00 
      46/    906C : (MACRO)             	code 	120,"D=D+1:(0,4)=D:(12,130)=69:GOTO120"
      46/    906C : 24                          db              strlen("D=D+1:(0,4)=D:(12,130)=69:GOTO120")+3                                                                          ; one byte offset to next (255 = End of "D=D+1:(0,4)=D:(12,130)=69:GOTO
      46/    906D : 78                          db              120                                                                                          ; one byte line number 
      46/    906E : 44 3D 44 2B 31 3A           db              "D=D+1:(0,4)=D:(12,130)=69:GOTO120",0                                                                                          ; ASCIIZ string
                    28 30 2C 34 29 3D 
                    44 3A 28 31 32 2C 
                    31 33 30 29 3D 36 
                    39 3A 47 4F 54 4F 
                    31 32 30 00 
      47/    9090 : (MACRO)             	code 	130,"A=!:B='@':C=42:D=0-1:GOTO130"
      47/    9090 : 1F                          db              strlen("A=!:B='@':C=42:D=0-1:GOTO130")+3                                                                          ; one byte offset to next (255 = End of "A=!:B='@':C=42:D=0-1:GOTO130")
      47/    9091 : 82                          db              130                                                                                          ; one byte line number 
      47/    9092 : 41 3D 21 3A 42 3D           db              "A=!:B='@':C=42:D=0-1:GOTO130",0                                                                                          ; ASCIIZ string
                    27 40 27 3A 43 3D 
                    34 32 3A 44 3D 30 
                    2D 31 3A 47 4F 54 
                    4F 31 33 30 00 
      48/    90AF : (MACRO)             	code 	140,"IF1#255;A=A+1:B=B+1"
      48/    90AF : 16                          db              strlen("IF1#255;A=A+1:B=B+1")+3                                                                          ; one byte offset to next (255 = End of "IF1#255;A=A+1:B=B+1")
      48/    90B0 : 8C                          db              140                                                                                          ; one byte line number 
      48/    90B1 : 49 46 31 23 32 35           db              "IF1#255;A=A+1:B=B+1",0                                                                                          ; ASCIIZ string
                    35 3B 41 3D 41 2B 
                    31 3A 42 3D 42 2B 
                    31 00 
      49/    90C5 : (MACRO)             	code 	150,"IF255#255;C=C+1:D=D+1"
      49/    90C5 : 18                          db              strlen("IF255#255;C=C+1:D=D+1")+3                                                                          ; one byte offset to next (255 = End of "IF255#255;C=C+1:D=D+1")
      49/    90C6 : 96                          db              150                                                                                          ; one byte line number 
      49/    90C7 : 49 46 32 35 35 23           db              "IF255#255;C=C+1:D=D+1",0                                                                                          ; ASCIIZ string
                    32 35 35 3B 43 3D 
                    43 2B 31 3A 44 3D 
                    44 2B 31 00 
      50/    90DD : (MACRO)             	code 	200,"LETA=0"
      50/    90DD : 09                          db              strlen("LETA=0")+3                                                                          ; one byte offset to next (255 = End of "LETA=0")
      50/    90DE : C8                          db              200                                                                                          ; one byte line number 
      50/    90DF : 4C 45 54 41 3D 30           db              "LETA=0",0                                                                                          ; ASCIIZ string
                    00 
      51/    90E6 : (MACRO)             	code 	210,"LETA=A+1:IFA#250;GOTO210"
      51/    90E6 : 1B                          db              strlen("LETA=A+1:IFA#250;GOTO210")+3                                                                          ; one byte offset to next (255 = End of "LETA=A+1:IFA#250;GOTO210")
      51/    90E7 : D2                          db              210                                                                                          ; one byte line number 
      51/    90E8 : 4C 45 54 41 3D 41           db              "LETA=A+1:IFA#250;GOTO210",0                                                                                          ; ASCIIZ string
                    2B 31 3A 49 46 41 
                    23 32 35 30 3B 47 
                    4F 54 4F 32 31 30 
                    00 
      52/    9101 :                     
      53/    9101 : (MACRO)             	code 	240,"PR42,69"
      53/    9101 : 0A                          db              strlen("PR42,69")+3                                                                          ; one byte offset to next (255 = End of "PR42,69")
      53/    9102 : F0                          db              240                                                                                          ; one byte line number 
      53/    9103 : 50 52 34 32 2C 36           db              "PR42,69",0                                                                                          ; ASCIIZ string
                    39 00 
      54/    910B : (MACRO)             	code 	241,"PR \"A:\",A,\"STAR TREK\""
      54/    910B : 18                          db              strlen("PR \"A:\",A,\"STAR TREK\"")+3                                                                          ; one byte offset to next (255 = End of "PR \"A:\",A,\"STAR TREK\"")
      54/    910C : F1                          db              241                                                                                          ; one byte line number 
      54/    910D : 50 52 20 22 41 3A           db              "PR \"A:\",A,\"STAR TREK\"",0                                                                                          ; ASCIIZ string
                    22 2C 41 2C 22 53 
                    54 41 52 20 54 52 
                    45 4B 22 00 
      55/    9123 : (MACRO)             	code 	242,"PR \"(\",$(144,33),\")\""
      55/    9123 : 17                          db              strlen("PR \"(\",$(144,33),\")\"")+3                                                                          ; one byte offset to next (255 = End of "PR \"(\",$(144,33),\")\"")
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 5 - 1/11/2016 13:50:19


      55/    9124 : F2                          db              242                                                                                          ; one byte line number 
      55/    9125 : 50 52 20 22 28 22           db              "PR \"(\",$(144,33),\")\"",0                                                                                          ; ASCIIZ string
                    2C 24 28 31 34 34 
                    2C 33 33 29 2C 22 
                    29 22 00 
      56/    913A : FF                  	db 		255
      57/    913B :                     
      58/    913B :                     
      59/    913B :                     ; ****************************************************************************************************************
      60/    913B :                     ;													Source Files
      61/    913B :                     ; ****************************************************************************************************************
      62/    913B :                     
      63/    913B :                     	include source\itoa.asm 									; print integer routine.
(1)    1/    913B :                     ; ****************************************************************************************************************
(1)    2/    913B :                     ; ****************************************************************************************************************
(1)    3/    913B :                     ;
(1)    4/    913B :                     ;											Integer (Byte) Printer
(1)    5/    913B :                     ;											======================
(1)    6/    913B :                     ;	
(1)    7/    913B :                     ;	Print Integer in E as String to output routine. Uses stack space as temporary storage. Changes A/E but not
(1)    8/    913B :                     ;	P1 or P2. Unsigned.
(1)    9/    913B :                     ;	
(1)   10/    913B :                     ;	On exit P3 is set up to Print routine.
(1)   11/    913B :                     ;
(1)   12/    913B :                     ; ****************************************************************************************************************
(1)   13/    913B :                     ; ****************************************************************************************************************
(1)   14/    913B :                     
(1)   15/    913B :                     PrintInteger:
(1)   16/    913B : (MACRO)             	pushp 	p3													; save P3
(1)   16/    913B : 37                          xpah    P3
(1)   16/    913C : CE FF                       st              @-1(p2)
(1)   16/    913E : 33                          xpal    P3
(1)   16/    913F : CE FF                       st              @-1(p2)
(1)   17/    9141 : C4 FF               	ldi 	0xFF 												; use $FF to mark stack top.
(1)   18/    9143 : CE FF               	st 		@-1(p2)
(1)   19/    9145 : CE FD               	st 		@-3(p2) 											; allocate space for results.
(1)   20/    9147 : C4 64               	ldi 	100 												; start with 100s
(1)   21/    9149 :                     __PIDivideOuter:
(1)   22/    9149 : CA 01               	st 		1(p2) 												; save subtractor at stack (1)
(1)   23/    914B : C4 FF               	ldi 	0xFF 												; clear stack (0) (count) to -1 because we pre-increment.
(1)   24/    914D : CA 00               	st 		0(p2)
(1)   25/    914F :                     __PIDivideLoop:
(1)   26/    914F : AA 00               	ild 	0(p2) 												; bump the counter.
(1)   27/    9151 : 40                  	lde 														; get value
(1)   28/    9152 : 03                  	scl 														; subtract divider
(1)   29/    9153 : FA 01               	cad 	1(p2) 												
(1)   30/    9155 : 01                  	xae 														; put back in E
(1)   31/    9156 : 06                  	csa 														; if no borrow
(1)   32/    9157 : D4 80               	ani 	0x80
(1)   33/    9159 : 9C F4               	jnz 	__PIDivideLoop 
(1)   34/    915B : 40                  	lde 														; add the divider.
(1)   35/    915C : 02                  	ccl
(1)   36/    915D : F2 01               	add 	1(p2)
(1)   37/    915F : 01                  	xae
(1)   38/    9160 : C2 01               	ld 		1(p2) 												; get the divider back
(1)   39/    9162 : E4 0A               	xri 	10 													; is it 10 ?
(1)   40/    9164 : 98 06               	jz 		__PIDivideEnd 										; we have finished the division bit.
(1)   41/    9166 : C6 01               	ld 		@1(p2) 												; push stack up one.
(1)   42/    9168 : C4 0A               	ldi 	10 													; and divide by 10
(1)   43/    916A : 90 DD               	jmp 	__PIDivideOuter
 AS V1.42 Beta [Bld 102] - source file minol.asm(itoa.asm) - page 6 - 1/11/2016 13:50:19


(1)   44/    916C :                     ;
(1)   45/    916C :                     __PIDivideEnd:
(1)   46/    916C :                     
(1)   47/    916C : 40                  	lde 														; write out the last digit.
(1)   48/    916D : CA 01               	st 		1(p2)
(1)   49/    916F : (MACRO)             	lpi 	p3,Print-1 											; point P3 to the print routine.
(1)   49/    916F : C4 91                       ldi     (PRINT-1) / 256
(1)   49/    9171 : 37                          xpah    P3
(1)   49/    9172 : C4 96                       ldi     (PRINT-1) & 255
(1)   49/    9174 : 33                          xpal    P3
(1)   50/    9175 :                     ;
(1)   51/    9175 :                     ;	Remove leading spaces
(1)   52/    9175 :                     ;
(1)   53/    9175 : C6 FF               	ld 		@-1(p2) 											; look at first digit, if non-zero go to print
(1)   54/    9177 : 9C 08               	jnz 	__PIPrint 
(1)   55/    9179 : C6 01               	ld 		@1(p2) 												; skip it, eliminate trailing zeros.
(1)   56/    917B : C2 00               	ld 		(p2) 												; now look at second digit
(1)   57/    917D : 9C 02               	jnz 	__PIPrint 											; skip it, eliminate trailing zeros.
(1)   58/    917F : C6 01               	ld 		@1(p2)
(1)   59/    9181 :                     ;
(1)   60/    9181 :                     __PIPrint:
(1)   61/    9181 : C6 01               	ld 		@1(p2) 												; read digit
(1)   62/    9183 : D4 80               	ani 	0x80												; if found -ve value then exit.
(1)   63/    9185 : 9C 07               	jnz 	__PIExit
(1)   64/    9187 : C2 FF               	ld 		-1(p2) 												; re-read it.
(1)   65/    9189 : DC 30               	ori 	'0'													; make ASCII
(1)   66/    918B : 3F                  	xppc 	p3 													; print it
(1)   67/    918C : 90 F3               	jmp 	__PIPrint 											; and keep printing.
(1)   68/    918E :                     ;
(1)   69/    918E :                     __PIExit:
(1)   70/    918E : (MACRO)             	pullp 	p3 													; restore P3
(1)   70/    918E : C6 01                       ld              @1(p2)
(1)   70/    9190 : 33                          xpal    P3
(1)   70/    9191 : C6 01                       ld              @1(p2)
(1)   70/    9193 : 37                          xpah    P3
(1)   71/    9194 : 3F                  	xppc 	p3 													; and exit
(1)   72/    9195 : 90 00               	jmp 	Print 												; and set up to execute print afterwards.
(1)   73/    9197 :                     
(1)   74/    9197 :                     
      64/    9197 :                     	include source\screen.asm 									; screen I/O stuff.
(1)    1/    9197 :                     ; ****************************************************************************************************************
(1)    2/    9197 :                     ; ****************************************************************************************************************
(1)    3/    9197 :                     ;
(1)    4/    9197 :                     ;											Screen I/O, VTL-2 ROM
(1)    5/    9197 :                     ;											=====================
(1)    6/    9197 :                     ;
(1)    7/    9197 :                     ;	Provides Character and String Input/Output functionality.
(1)    8/    9197 :                     ;
(1)    9/    9197 :                     ; ****************************************************************************************************************
(1)   10/    9197 :                     ; ****************************************************************************************************************
(1)   11/    9197 :                     
(1)   12/    9197 :                     ; ****************************************************************************************************************
(1)   13/    9197 :                     ; ****************************************************************************************************************
(1)   14/    9197 :                     ;
(1)   15/    9197 :                     ;	Print routine. Prints either character in A, or ASCIIZ string at P1 (if A is zero). Preserves all registers
(1)   16/    9197 :                     ;	except if printing string, P1 points to the character after the NULL terminator.
(1)   17/    9197 :                     ;
(1)   18/    9197 :                     ;	Scrolls automatically. Understands character codes 32-255, 8 (Backspace) 12 (Clear Screen) 13 (Carriage
(1)   19/    9197 :                     ;	Return). Others are currently ignored (except 0, see above). Note L/C values (97....) display those characters
(1)   20/    9197 :                     ;	in the ROM font *not* lower case :)
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 7 - 1/11/2016 13:50:19


(1)   21/    9197 :                     ;
(1)   22/    9197 :                     ; ****************************************************************************************************************
(1)   23/    9197 :                     ; ****************************************************************************************************************
(1)   24/    9197 :                     
(1)   25/    9197 :                     Print:
(1)   26/    9197 :                     	section 	Print
(1)   27/    9197 :                     
(1)   28/    9197 : (MACRO)             	pusha														; push registers on stack
(1)   28/    9197 : CE FF                       st              @-1(p2)
(1)   29/    9199 : (MACRO)             	pushp 	p1
(1)   29/    9199 : 35                          xpah    P1
(1)   29/    919A : CE FF                       st              @-1(p2)
(1)   29/    919C : 31                          xpal    P1
(1)   29/    919D : CE FF                       st              @-1(p2)
(1)   30/    919F : (MACRO)             	pushe
(1)   30/    919F : 40                          lde
(1)   30/    91A0 : CE FF                       st              @-1(p2)
(1)   31/    91A2 :                     
(1)   32/    91A2 : C2 03               	ld 		3(p2) 												; read character 
(1)   33/    91A4 : 9C 12               	jnz 	__PRPrintCharacterA 								; if non zero print it on its own.
(1)   34/    91A6 :                     
(1)   35/    91A6 :                     __PRPrintString:
(1)   36/    91A6 : C2 01               	ld 		1(p2) 												; restore original P1
(1)   37/    91A8 : 31                  	xpal 	p1
(1)   38/    91A9 : C2 02               	ld 		2(p2)
(1)   39/    91AB : 35                  	xpah 	p1 													; read character at P1.
(1)   40/    91AC : C5 01               	ld 		@1(p1)
(1)   41/    91AE : 01                  	xae 														; save in E.
(1)   42/    91AF : 35                  	xpah 	p1 													; write P1 back.
(1)   43/    91B0 : CA 02               	st 		2(p2)
(1)   44/    91B2 : 31                  	xpal 	p1
(1)   45/    91B3 : CA 01               	st 		1(p2)
(1)   46/    91B5 : 40                  	lde 														; get character from E
(1)   47/    91B6 : 98 46               	jz 		__PRExitNoCheck 									; exit without loop check.
(1)   48/    91B8 :                     ;
(1)   49/    91B8 :                     ;	Print character in A now ; throughout it is stored in E.
(1)   50/    91B8 :                     ;
(1)   51/    91B8 :                     __PRPrintCharacterA:
(1)   52/    91B8 : 01                  	xae 														; save character in E.
(1)   53/    91B9 :                     ;
(1)   54/    91B9 :                     ;	Read cursor and set P1 to that address
(1)   55/    91B9 :                     ;
(1)   56/    91B9 : C4 0C               	ldi 	ScreenCursor/256 									; set P1 to point to screen cursor
(1)   57/    91BB : 35                  	xpah 	p1
(1)   58/    91BC : C4 80               	ldi 	ScreenCursor&255
(1)   59/    91BE : 31                  	xpal 	p1
(1)   60/    91BF : C1 00               	ld 		0(p1) 												; put cursor position in P1.L
(1)   61/    91C1 : 31                  	xpal 	p1
(1)   62/    91C2 :                     ;
(1)   63/    91C2 :                     ;	Check for control
(1)   64/    91C2 :                     ;
(1)   65/    91C2 : 40                  	lde 														; look at character
(1)   66/    91C3 : D4 E0               	ani 	0xE0 												; is it code 0-31
(1)   67/    91C5 : 98 45               	jz 		__PRIsControlChar
(1)   68/    91C7 :                     ;
(1)   69/    91C7 :                     ;	Print non-control
(1)   70/    91C7 :                     ;
(1)   71/    91C7 : 40                  	lde 														; read character
(1)   72/    91C8 : 03                  	scl 														; CY/L clear if < 96
(1)   73/    91C9 : FC 60               	cai 	96 
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 8 - 1/11/2016 13:50:19


(1)   74/    91CB : 06                  	csa 	 	 												; skip if carry set
(1)   75/    91CC : E4 80               	xri 	0x80													
(1)   76/    91CE : 94 04               	jp 		__PRNotASCII
(1)   77/    91D0 : 40                  	lde 														; if ASCII make 6 bit.
(1)   78/    91D1 : D4 3F               	ani 	0x3F
(1)   79/    91D3 : 01                  	xae
(1)   80/    91D4 :                     __PRNotASCII:
(1)   81/    91D4 : 40                  	lde 														; get character.
(1)   82/    91D5 : C9 00               	st 		(p1) 												; save in shadow memory
(1)   83/    91D7 : 35                  	xpah 	p1 													; switch to VRAM, preserving A.
(1)   84/    91D8 : C4 00               	ldi 	0 													
(1)   85/    91DA : 35                  	xpah 	p1
(1)   86/    91DB : CD 01               	st 		@1(p1) 												; save in screen memory, advance write position.
(1)   87/    91DD :                     ;
(1)   88/    91DD :                     ;	Write cursor position back from P1.L
(1)   89/    91DD :                     ;
(1)   90/    91DD :                     __PRUpdateCursor:
(1)   91/    91DD : C4 0C               	ldi		ScreenCursor / 256 									; set P1 to point to screen cursor, restore position to P1
(1)   92/    91DF : 35                  	xpah 	p1
(1)   93/    91E0 : C4 80               	ldi 	ScreenCursor & 255 
(1)   94/    91E2 : 31                  	xpal 	p1 													; after this, adjusted cursor position is in AC.
(1)   95/    91E3 : C9 00               	st 		(p1) 												; write back in cursor position
(1)   96/    91E5 : 94 13               	jp 		__PRExit 											; if position is off the bottom then scroll.
(1)   97/    91E7 :                     ;
(1)   98/    91E7 :                     ;	Scroll display
(1)   99/    91E7 :                     ;
(1)  100/    91E7 : C4 0C               	ldi 	(ScreenMirror+16) / 256 							; point P1 to 2nd line.
(1)  101/    91E9 : 35                  	xpah 	p1
(1)  102/    91EA : C4 10               	ldi 	(ScreenMirror+16) & 255
(1)  103/    91EC :                     __PRScrollLoop:
(1)  104/    91EC : 31                  	xpal 	p1
(1)  105/    91ED : C1 00               	ld 		0(p1) 												; copy char to previous line
(1)  106/    91EF : C9 F0               	st 		-16(p1)
(1)  107/    91F1 : C5 01               	ld 		@1(p1) 												; bump pointer.
(1)  108/    91F3 : 31                  	xpal 	p1
(1)  109/    91F4 : 94 F6               	jp 		__PRScrollLoop
(1)  110/    91F6 : C4 70               	ldi 	128-16 												; clear from and move to last line
(1)  111/    91F8 : 90 3D               	jmp 	__PRClearFromMoveTo
(1)  112/    91FA :                     ;
(1)  113/    91FA :                     ;	Exit screen drawing routine.
(1)  114/    91FA :                     ;
(1)  115/    91FA :                     __PRExit:
(1)  116/    91FA : C2 03               	ld 		3(p2) 												; if character was zero, loop
(1)  117/    91FC : 98 A8               	jz 		__PRPrintString 									; back as printing string at P1.
(1)  118/    91FE :                     __PRExitNoCheck:
(1)  119/    91FE : (MACRO)             	pulle 														; restore registers
(1)  119/    91FE : C6 01                       ld              @1(p2)
(1)  119/    9200 : 01                          xae
(1)  120/    9201 : (MACRO)             	pullp 	p1
(1)  120/    9201 : C6 01                       ld              @1(p2)
(1)  120/    9203 : 31                          xpal    P1
(1)  120/    9204 : C6 01                       ld              @1(p2)
(1)  120/    9206 : 35                          xpah    P1
(1)  121/    9207 : (MACRO)             	pulla
(1)  121/    9207 : C6 01                       ld              @1(p2)
(1)  122/    9209 : 3F                  	xppc 	p3 													; return
(1)  123/    920A : 90 8B               	jmp 	Print 												; make re-entrant.
(1)  124/    920C :                     ;
(1)  125/    920C :                     ;	Check for supported control characters 8 (Backspace) 12 (Clear) 13 (Carriage Return)
(1)  126/    920C :                     ;
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 9 - 1/11/2016 13:50:19


(1)  127/    920C :                     __PRIsControlChar:
(1)  128/    920C : 40                  	lde 														; restore character.
(1)  129/    920D : E4 0D               	xri 	13 													; carriage return ? (13)
(1)  130/    920F : 98 1B               	jz 		__PRIsReturn
(1)  131/    9211 : E4 01               	xri 	13!12 												; form feed ? (12)
(1)  132/    9213 : 98 20               	jz 		__PRClearScreen
(1)  133/    9215 : E4 04               	xri 	12!8 												; backspace ? (8)
(1)  134/    9217 : 9C E1               	jnz 	__PRExit 
(1)  135/    9219 :                     ;
(1)  136/    9219 :                     ;	Handle backspace (8)
(1)  137/    9219 :                     ;
(1)  138/    9219 : 31                  	xpal 	p1 													; check cursor position is zero
(1)  139/    921A : 98 DE               	jz 		__PRExit 											; if it is, cannot backspace so exit.
(1)  140/    921C : 31                  	xpal 	p1  												; put it back
(1)  141/    921D : C5 FF               	ld 		@-1(p1)												; move it back one
(1)  142/    921F : C4 20               	ldi 	' '	 												; erase in shadow
(1)  143/    9221 : C9 00               	st 		(p1)
(1)  144/    9223 : C4 00               	ldi 	0 													; point P1 to VRAM
(1)  145/    9225 : 35                  	xpah 	p1
(1)  146/    9226 : C4 20               	ldi 	' '													; erase in VRAM
(1)  147/    9228 : C9 00               	st 		(p1)
(1)  148/    922A : 90 B1               	jmp 	__PRUpdateCursor 									; and exit
(1)  149/    922C :                     ;
(1)  150/    922C :                     ;	Handle carriage return (13)
(1)  151/    922C :                     ;
(1)  152/    922C :                     __PRIsReturn:
(1)  153/    922C : 31                  	xpal 	p1 													; cursor position in A
(1)  154/    922D : D4 F0               	ani 	0xF0 												; start of current line
(1)  155/    922F : 02                  	ccl 														; down one line
(1)  156/    9230 : F4 10               	adi 	0x10 	
(1)  157/    9232 : 31                  	xpal 	p1 													; put it back in P1.
(1)  158/    9233 : 90 A8               	jmp 	__PRUpdateCursor
(1)  159/    9235 :                     ;
(1)  160/    9235 :                     ;	Handle clear screen (12)
(1)  161/    9235 :                     ;
(1)  162/    9235 :                     __PRClearScreen:
(1)  163/    9235 : C4 00               	ldi 	0 													; clear shadow memory from here.
(1)  164/    9237 :                     ;
(1)  165/    9237 :                     ;	From position A, clear the memory in the shadow screen to the end, copy the shadow screen to VRAM
(1)  166/    9237 :                     ;	then use position A as the new cursor position.
(1)  167/    9237 :                     ;
(1)  168/    9237 :                     __PRClearFromMoveTo:
(1)  169/    9237 : CE FF               	st 		@-1(p2) 											; save this position, the cursor goes here.
(1)  170/    9239 :                     __PRClearLoop:
(1)  171/    9239 : 31                  	xpal 	p1 													; save position in P1.
(1)  172/    923A : C4 20               	ldi 	' '													; write space there.
(1)  173/    923C : CD 01               	st 		@1(p1)
(1)  174/    923E : 31                  	xpal 	p1
(1)  175/    923F : 94 F8               	jp 		__PRClearLoop 										; until reached shadow memory start.
(1)  176/    9241 : C4 00               	ldi 	0 													; now copy shadow memory to screen memory.
(1)  177/    9243 :                     __PRCopy:
(1)  178/    9243 : 31                  	xpal 	p1 													; set up P1.L
(1)  179/    9244 : C4 0C               	ldi 	ScreenMirror/256 									; point to shadow memory.
(1)  180/    9246 : 35                  	xpah 	p1 													
(1)  181/    9247 : C1 00               	ld 		(p1) 												; read shadow memory
(1)  182/    9249 : 35                  	xpah 	p1 													; zero P1.H preserving A
(1)  183/    924A : C4 00               	ldi 	0
(1)  184/    924C : 35                  	xpah 	p1
(1)  185/    924D : CD 01               	st 		@1(p1) 												; save and increment p1
(1)  186/    924F : 31                  	xpal 	p1 
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 10 - 1/11/2016 13:50:19


(1)  187/    9250 : 94 F1               	jp 		__PRCopy 											; keep doing till all copied.
(1)  188/    9252 : C6 01               	ld 		@1(p2) 												; read cursor position
(1)  189/    9254 : 31                  	xpal 	p1 													; put in P1.L
(1)  190/    9255 : 90 86               	jmp 	__PRUpdateCursor
(1)  191/    9257 :                     
(1)  192/    9257 :                     	endsection 	Print
(1)  193/    9257 :                     
(1)  194/    9257 :                     ; ****************************************************************************************************************
(1)  195/    9257 :                     ; ****************************************************************************************************************
(1)  196/    9257 :                     ;
(1)  197/    9257 :                     ;		Input a single character into A. Case is converted to Upper. All registers preserved except A
(1)  198/    9257 :                     ;
(1)  199/    9257 :                     ; ****************************************************************************************************************
(1)  200/    9257 :                     ; ****************************************************************************************************************
(1)  201/    9257 :                     
(1)  202/    9257 :                     GetChar:
(1)  203/    9257 :                     	section 	GetChar
(1)  204/    9257 : C4 08               	ldi 	0x8 												; set P1 to $8xx, and save P1.H
(1)  205/    9259 : 35                  	xpah 	p1
(1)  206/    925A : CE FF               	st 		@-1(p2)
(1)  207/    925C :                     __GCWaitKey: 													; wait for key press
(1)  208/    925C : C1 00               	ld 		0(p1)
(1)  209/    925E : 94 FC               	jp 		__GCWaitKey
(1)  210/    9260 : D4 7F               	ani	 	0x7F 												; throw away the upper bit.
(1)  211/    9262 : CA FF               	st 		-1(p2) 												; save it below stack
(1)  212/    9264 :                     __GCWaitRelease:
(1)  213/    9264 : C1 00               	ld 		0(p1) 												; wait for release
(1)  214/    9266 : D4 80               	ani 	0x80
(1)  215/    9268 : 9C FA               	jnz 	__GCWaitRelease
(1)  216/    926A : C6 01               	ld 		@1(p2) 												; restore P1.H
(1)  217/    926C : 35                  	xpah 	p1
(1)  218/    926D : C2 FE               	ld 		-2(p2) 												; restore saved value
(1)  219/    926F : 02                  	ccl
(1)  220/    9270 : F4 20               	adi 	0x20												; will make lower case -ve
(1)  221/    9272 : 94 02               	jp 		__GCNotLower
(1)  222/    9274 : FC 20               	cai 	0x20 												; capitalise
(1)  223/    9276 :                     __GCNotLower:
(1)  224/    9276 : F4 E0               	adi 	0xE0 												; fix up.
(1)  225/    9278 : 3F                  	xppc 	p3 													; return
(1)  226/    9279 : 90 DC               	jmp 	GetChar 											; make re-entrant
(1)  227/    927B :                     	endsection 	GetChar
(1)  228/    927B :                     
(1)  229/    927B :                     ; ****************************************************************************************************************
(1)  230/    927B :                     ; ****************************************************************************************************************
(1)  231/    927B :                     ;
(1)  232/    927B :                     ;			Read an ASCIIZ string from keyboard into P1 of length A maximum (excludes NULL terminator)
(1)  233/    927B :                     ;
(1)  234/    927B :                     ; ****************************************************************************************************************
(1)  235/    927B :                     ; ****************************************************************************************************************
(1)  236/    927B :                     
(1)  237/    927B :                     GetString:
(1)  238/    927B :                     	section GetString
(1)  239/    927B : (MACRO)             	pusha 														; save A,P3,E
(1)  239/    927B : CE FF                       st              @-1(p2)
(1)  240/    927D : (MACRO)             	pushp 	p3
(1)  240/    927D : 37                          xpah    P3
(1)  240/    927E : CE FF                       st              @-1(p2)
(1)  240/    9280 : 33                          xpal    P3
(1)  240/    9281 : CE FF                       st              @-1(p2)
(1)  241/    9283 : (MACRO)             	pushe 
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 11 - 1/11/2016 13:50:19


(1)  241/    9283 : 40                          lde
(1)  241/    9284 : CE FF                       st              @-1(p2)
(1)  242/    9286 : C4 00               	ldi 	0 													; set E (current position) to A.
(1)  243/    9288 : 01                  	xae
(1)  244/    9289 :                     __GSLoop:
(1)  245/    9289 : (MACRO)             	lpi 	p3,Print-1 											; print the prompt (half coloured square)
(1)  245/    9289 : C4 91                       ldi     (PRINT-1) / 256
(1)  245/    928B : 37                          xpah    P3
(1)  245/    928C : C4 96                       ldi     (PRINT-1) & 255
(1)  245/    928E : 33                          xpal    P3
(1)  246/    928F : C4 9B               	ldi 	155
(1)  247/    9291 : 3F                  	xppc 	p3
(1)  248/    9292 : (MACRO)             	lpi 	p3,GetChar-1 										; get a character
(1)  248/    9292 : C4 92                       ldi     (GETCHAR-1) / 256
(1)  248/    9294 : 37                          xpah    P3
(1)  248/    9295 : C4 56                       ldi     (GETCHAR-1) & 255
(1)  248/    9297 : 33                          xpal    P3
(1)  249/    9298 : 3F                  	xppc 	p3
(1)  250/    9299 : C9 80               	st 		-0x80(p1) 											; save it in the current position.
(1)  251/    929B : (MACRO)             	lpi 	p3,Print-1 											; erase the prompt with backspace.
(1)  251/    929B : C4 91                       ldi     (PRINT-1) / 256
(1)  251/    929D : 37                          xpah    P3
(1)  251/    929E : C4 96                       ldi     (PRINT-1) & 255
(1)  251/    92A0 : 33                          xpal    P3
(1)  252/    92A1 : C4 08               	ldi 	8
(1)  253/    92A3 : 3F                  	xppc 	p3
(1)  254/    92A4 : C1 80               	ld 		-0x80(p1) 											; re-read character
(1)  255/    92A6 : D4 E0               	ani 	0xE0 												; check if control key.
(1)  256/    92A8 : 98 0F               	jz 		__GSControlKey 
(1)  257/    92AA : 40                  	lde 														; get current position.
(1)  258/    92AB : E2 03               	xor 	3(p2) 												; reached maximum length of buffer ?
(1)  259/    92AD : 98 DA               	jz 		__GSLoop 											; if so, ignore the key and go round again.
(1)  260/    92AF : C1 80               	ld 		-0x80(p1) 											; get character and print it
(1)  261/    92B1 : 3F                  	xppc 	p3
(1)  262/    92B2 : C4 01               	ldi 	1 													; increment E
(1)  263/    92B4 : 02                  	ccl
(1)  264/    92B5 : 70                  	ade
(1)  265/    92B6 : 01                  	xae
(1)  266/    92B7 : 90 D0               	jmp 	__GSLoop 											; and go round again.
(1)  267/    92B9 :                     ;
(1)  268/    92B9 :                     ;	Handle control keys (0x00-0x1F)
(1)  269/    92B9 :                     ;
(1)  270/    92B9 :                     __GSControlKey:
(1)  271/    92B9 : C1 80               	ld 		-0x80(p1) 											; get typed in key
(1)  272/    92BB : E4 08               	xri 	8 													; check for backspace.
(1)  273/    92BD : 98 17               	jz 		__GSBackspace 			
(1)  274/    92BF : E4 05               	xri 	8!13 												; check for CR
(1)  275/    92C1 : 9C C6               	jnz 	__GSLoop 											; if not, ignore the key.
(1)  276/    92C3 :                     ;
(1)  277/    92C3 :                     ;	Carriage Return, ending input.
(1)  278/    92C3 :                     ;
(1)  279/    92C3 : C9 80               	st 		-0x80(p1) 											; replace the CR written with NULL terminator.
(1)  280/    92C5 : C4 0D               	ldi 	13 													; print CR
(1)  281/    92C7 : 3F                  	xppc 	p3
(1)  282/    92C8 : (MACRO)             	pulle 														; restore E,P3,A
(1)  282/    92C8 : C6 01                       ld              @1(p2)
(1)  282/    92CA : 01                          xae
(1)  283/    92CB : (MACRO)             	pullp	p3
(1)  283/    92CB : C6 01                       ld              @1(p2)
(1)  283/    92CD : 33                          xpal    P3
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 12 - 1/11/2016 13:50:19


(1)  283/    92CE : C6 01                       ld              @1(p2)
(1)  283/    92D0 : 37                          xpah    P3
(1)  284/    92D1 : (MACRO)             	pulla
(1)  284/    92D1 : C6 01                       ld              @1(p2)
(1)  285/    92D3 : 3F                  	xppc 	p3 													; return
(1)  286/    92D4 : 90 A5               	jmp 	GetString 											; make re-entrant (probably unneccessary !!)
(1)  287/    92D6 :                     ;
(1)  288/    92D6 :                     ;	Backspace entered
(1)  289/    92D6 :                     ;
(1)  290/    92D6 :                     __GSBackspace
(1)  291/    92D6 : 40                  	lde 														; if E = 0 we can't backspace any further.
(1)  292/    92D7 : 98 B0               	jz 		__GSLoop
(1)  293/    92D9 : C4 08               	ldi 	8 													; backspace on screen
(1)  294/    92DB : 3F                  	xppc 	p3
(1)  295/    92DC : C4 FF               	ldi 	0xFF 												; decrement E
(1)  296/    92DE : 02                  	ccl
(1)  297/    92DF : 70                  	ade
(1)  298/    92E0 : 01                  	xae
(1)  299/    92E1 : 90 A6               	jmp 	__GSLoop 											; and go round again.
(1)  300/    92E3 :                     
(1)  301/    92E3 :                     	endsection GetString
(1)  302/    92E3 :                     
      65/    92E3 :                     	include source\execute.asm 									; statement exec main loop
(1)    1/    92E3 :                     ; ****************************************************************************************************************
(1)    2/    92E3 :                     ; ****************************************************************************************************************
(1)    3/    92E3 :                     ;
(1)    4/    92E3 :                     ;										Instruction Execution
(1)    5/    92E3 :                     ;	
(1)    6/    92E3 :                     ; ****************************************************************************************************************
(1)    7/    92E3 :                     ; ****************************************************************************************************************
(1)    8/    92E3 :                     
(1)    9/    92E3 :                     ; ****************************************************************************************************************
(1)   10/    92E3 :                     ;							Source codes for execution, with skip-over go here
(1)   11/    92E3 :                     ; ****************************************************************************************************************
(1)   12/    92E3 :                     
(1)   13/    92E3 :                     	include source\commands\os.asm 								; OS
(2)    1/    92E3 :                     ; ****************************************************************************************************************
(2)    2/    92E3 :                     ; ****************************************************************************************************************
(2)    3/    92E3 :                     ;
(2)    4/    92E3 :                     ;												OS command
(2)    5/    92E3 :                     ;	
(2)    6/    92E3 :                     ; ****************************************************************************************************************
(2)    7/    92E3 :                     ; ****************************************************************************************************************
(2)    8/    92E3 :                     
(2)    9/    92E3 : 90 07               	jmp 	COS_Over
(2)   10/    92E5 :                     
(2)   11/    92E5 :                     CMD_OS:
(2)   12/    92E5 : (MACRO)             	lpi 	p3,BootMonitor-1 									; monitor re-entry point
(2)   12/    92E5 : C4 02                       ldi     (BOOTMONITOR-1) / 256
(2)   12/    92E7 : 37                          xpah    P3
(2)   12/    92E8 : C4 0F                       ldi     (BOOTMONITOR-1) & 255
(2)   12/    92EA : 33                          xpal    P3
(2)   13/    92EB : 3F                  	xppc 	p3													; go there.
(2)   14/    92EC :                     
(2)   15/    92EC :                     COS_Over:
(1)   14/    92EC :                     	include source\commands\list.asm 							; LIST
(2)    1/    92EC :                     ; ****************************************************************************************************************
(2)    2/    92EC :                     ; ****************************************************************************************************************
(2)    3/    92EC :                     ;
(2)    4/    92EC :                     ;												LIST command
 AS V1.42 Beta [Bld 102] - source file minol.asm(list.asm) - page 13 - 1/11/2016 13:50:19


(2)    5/    92EC :                     ;	
(2)    6/    92EC :                     ; ****************************************************************************************************************
(2)    7/    92EC :                     ; ****************************************************************************************************************
(2)    8/    92EC :                     
(2)    9/    92EC : 90 3E               	jmp		CLI_Over
(2)   10/    92EE :                     
(2)   11/    92EE :                     CMD_List:
(2)   12/    92EE : (MACRO)             	lpi 	p1,ProgramBase 										; point P1 to first line.
(2)   12/    92EE : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   12/    92F0 : 35                          xpah    P1
(2)   12/    92F1 : C4 1F                       ldi     (PROGRAMBASE) & 255
(2)   12/    92F3 : 31                          xpal    P1
(2)   13/    92F4 : C4 00               	ldi 	0 													; clear counter. used for Speccy style list.
(2)   14/    92F6 : CE FF               	st 		@-1(p2)
(2)   15/    92F8 :                     CLI_Loop:
(2)   16/    92F8 : C5 01               	ld 		@1(p1) 												; check if finished
(2)   17/    92FA : D4 80               	ani 	0x80
(2)   18/    92FC : 9C 28               	jnz 	CLI_End
(2)   19/    92FE : C5 01               	ld 		@1(p1) 												; get line number into E
(2)   20/    9300 : 01                  	xae 
(2)   21/    9301 : (MACRO)             	lpi 	p3,PrintInteger-1 									; and print it.
(2)   21/    9301 : C4 91                       ldi     (PRINTINTEGER-1) / 256
(2)   21/    9303 : 37                          xpah    P3
(2)   21/    9304 : C4 3A                       ldi     (PRINTINTEGER-1) & 255
(2)   21/    9306 : 33                          xpal    P3
(2)   22/    9307 : 3F                  	xppc 	p3
(2)   23/    9308 : C4 20               	ldi 	' '													; print space
(2)   24/    930A : 3F                  	xppc 	p3
(2)   25/    930B :                     ;
(2)   26/    930B :                     CLI_Line:
(2)   27/    930B : C5 01               	ld 		@1(p1) 												; get character
(2)   28/    930D : 98 03               	jz 		CLI_EndLine											; if zero, do next line.
(2)   29/    930F : 3F                  	xppc 	p3 													; print it
(2)   30/    9310 : 90 F9               	jmp 	CLI_Line
(2)   31/    9312 :                     ;
(2)   32/    9312 :                     CLI_EndLine:
(2)   33/    9312 : C4 0D               	ldi 	13													; new line
(2)   34/    9314 : 3F                  	xppc 	p3
(2)   35/    9315 : AA 00               	ild 	(p2) 												; bump counter
(2)   36/    9317 : D4 03               	ani 	0x03 												; stop every 3 lines
(2)   37/    9319 : 9C DD               	jnz 	CLI_Loop 											; keep going.
(2)   38/    931B : (MACRO)             	lpi 	p3,GetChar-1 										; get a keystroke
(2)   38/    931B : C4 92                       ldi     (GETCHAR-1) / 256
(2)   38/    931D : 37                          xpah    P3
(2)   38/    931E : C4 56                       ldi     (GETCHAR-1) & 255
(2)   38/    9320 : 33                          xpal    P3
(2)   39/    9321 : 3F                  	xppc 	p3
(2)   40/    9322 : E4 20               	xri 	' '													; if space pressed
(2)   41/    9324 : 98 D2               	jz 		CLI_Loop 											; and do next line.
(2)   42/    9326 :                     
(2)   43/    9326 :                     CLI_End:
(2)   44/    9326 : C6 01               	ld 		@1(p2) 												; drop counter
(2)   45/    9328 : C4 FF               	ldi 	ERRC_End											; fake error to end after LIST as destroys P1.
(2)   46/    932A : 01                  	xae
(2)   47/    932B : 02                  	ccl
(2)   48/    932C :                     
(2)   49/    932C :                     CLI_Over:
(2)   50/    932C :                     
(2)   51/    932C :                     
(1)   15/    932C :                     	include source\commands\new_end.asm 						; NEW and END
 AS V1.42 Beta [Bld 102] - source file minol.asm(new_end.asm) - page 14 - 1/11/2016 13:50:19


(2)    1/    932C :                     ; ****************************************************************************************************************
(2)    2/    932C :                     ; ****************************************************************************************************************
(2)    3/    932C :                     ;
(2)    4/    932C :                     ;												NEW and END
(2)    5/    932C :                     ;	
(2)    6/    932C :                     ; ****************************************************************************************************************
(2)    7/    932C :                     ; ****************************************************************************************************************
(2)    8/    932C :                     
(2)    9/    932C : 90 0E               	jmp 	CNE_Over
(2)   10/    932E :                     
(2)   11/    932E :                     ; ****************************************************************************************************************
(2)   12/    932E :                     ;						NEW (Erase program) also executes END in case in running program
(2)   13/    932E :                     ; ****************************************************************************************************************
(2)   14/    932E :                     
(2)   15/    932E :                     CMD_New:
(2)   16/    932E : (MACRO)             	lpi 	p3,ProgramBase 										; write $FF at program base
(2)   16/    932E : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   16/    9330 : 37                          xpah    P3
(2)   16/    9331 : C4 1F                       ldi     (PROGRAMBASE) & 255
(2)   16/    9333 : 33                          xpal    P3
(2)   17/    9334 : C4 FF               	ldi 	0xFF
(2)   18/    9336 : CB 00               	st 		0(p3) 												; this erases the program
(2)   19/    9338 :                     
(2)   20/    9338 :                     ; ****************************************************************************************************************
(2)   21/    9338 :                     ;													END program
(2)   22/    9338 :                     ; ****************************************************************************************************************
(2)   23/    9338 :                     
(2)   24/    9338 :                     CMD_End:
(2)   25/    9338 : 02                  	ccl 														; we cause an error, but it is ERRC_End which is 
(2)   26/    9339 : C4 FF               	ldi 	ERRC_End 											; not an error and not reported as such.
(2)   27/    933B : 01                  	xae
(2)   28/    933C :                     
(2)   29/    933C :                     CNE_Over:
(1)   16/    933C :                     	include source\commands\clear.asm							; CLEAR
(2)    1/    933C :                     ; ****************************************************************************************************************
(2)    2/    933C :                     ; ****************************************************************************************************************
(2)    3/    933C :                     ;
(2)    4/    933C :                     ;													CLEAR
(2)    5/    933C :                     ;	
(2)    6/    933C :                     ; ****************************************************************************************************************
(2)    7/    933C :                     ; ****************************************************************************************************************
(2)    8/    933C :                     
(2)    9/    933C : 90 13               	jmp	CCL_Over
(2)   10/    933E :                     
(2)   11/    933E :                     ; ****************************************************************************************************************
(2)   12/    933E :                     ;												CLEAR command
(2)   13/    933E :                     ; ****************************************************************************************************************
(2)   14/    933E :                     
(2)   15/    933E :                     CMD_Clear:
(2)   16/    933E : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   16/    933E : C4 0C                       ldi     (VARIABLES) / 256
(2)   16/    9340 : 37                          xpah    P3
(2)   16/    9341 : C4 90                       ldi     (VARIABLES) & 255
(2)   16/    9343 : 33                          xpal    P3
(2)   17/    9344 : C4 1A               	ldi 	26 													; loop counter to 26
(2)   18/    9346 : CA FF               	st 		-1(p2)
(2)   19/    9348 :                     CCL_Loop:
(2)   20/    9348 : C4 00               	ldi 	0x00												; clear a variable
(2)   21/    934A : CF 01               	st 		@1(p3)
(2)   22/    934C : BA FF               	dld 	-1(p2) 												; done all
 AS V1.42 Beta [Bld 102] - source file minol.asm(clear.asm) - page 15 - 1/11/2016 13:50:19


(2)   23/    934E : 9C F8               	jnz 	CCL_Loop											; loop back
(2)   24/    9350 : 03                  	scl 														; no error
(2)   25/    9351 :                     
(2)   26/    9351 :                     CCL_Over:
(1)   17/    9351 :                     	include source\commands\print.asm 							; PR
(2)    1/    9351 :                     ; ****************************************************************************************************************
(2)    2/    9351 :                     ; ****************************************************************************************************************
(2)    3/    9351 :                     ;
(2)    4/    9351 :                     ;												PR command
(2)    5/    9351 :                     ;	
(2)    6/    9351 :                     ; ****************************************************************************************************************
(2)    7/    9351 :                     ; ****************************************************************************************************************
(2)    8/    9351 :                     
(2)    9/    9351 : 90 7B               	jmp 	CPR_Over2
(2)   10/    9353 :                     
(2)   11/    9353 :                     CMD_Print:
(2)   12/    9353 : (MACRO)             	lpi 	p3,Print-1 											; set up P3 for printing.
(2)   12/    9353 : C4 91                       ldi     (PRINT-1) / 256
(2)   12/    9355 : 37                          xpah    P3
(2)   12/    9356 : C4 96                       ldi     (PRINT-1) & 255
(2)   12/    9358 : 33                          xpal    P3
(2)   13/    9359 : C1 00               	ld 		(p1)												; reached end of command, print RETURN and exit.
(2)   14/    935B : 98 73               	jz 		CPR_EndReturn
(2)   15/    935D : E4 3A               	xri 	':'
(2)   16/    935F : 98 6F               	jz 		CPR_EndReturn
(2)   17/    9361 : C5 01               	ld 		@1(p1)												; re-read with a bump
(2)   18/    9363 : E4 20               	xri 	' '													; if space, skip it
(2)   19/    9365 : 98 EC               	jz 		CMD_Print
(2)   20/    9367 : E4 0C               	xri 	','!' '												; if comma, skip it.
(2)   21/    9369 : 98 E8               	jz 		CMD_Print
(2)   22/    936B : E4 17               	xri 	';'!','												; if semicolon exit without a return
(2)   23/    936D : 98 64               	jz 		CPR_EndOk 
(2)   24/    936F : E4 19               	xri 	'"'!';'												; if quote mark print as quoted string
(2)   25/    9371 : 98 1E               	jz 		CPR_QuotedString
(2)   26/    9373 : E4 06               	xri 	'$'!'"'												; if $ print string at address.
(2)   27/    9375 : 98 27               	jz 		CPR_StringAtAddress
(2)   28/    9377 :                     ;
(2)   29/    9377 :                     ;	numerical expression
(2)   30/    9377 :                     ;
(2)   31/    9377 : C4 20               	ldi 	' '													; preceding space
(2)   32/    9379 : 3F                  	xppc 	p3
(2)   33/    937A : C5 FF               	ld 		@-1(p1)												; unpick the get, first character of expression.
(2)   34/    937C : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; evaluate expression
(2)   34/    937C : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)   34/    937E : 37                          xpah    P3
(2)   34/    937F : C4 46                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)   34/    9381 : 33                          xpal    P3
(2)   35/    9382 : 3F                  	xppc 	p3
(2)   36/    9383 : 94 4F               	jp 		CPR_Over 											; exit on error.
(2)   37/    9385 : (MACRO)             	lpi 	p3,PrintInteger-1 									; and print it
(2)   37/    9385 : C4 91                       ldi     (PRINTINTEGER-1) / 256
(2)   37/    9387 : 37                          xpah    P3
(2)   37/    9388 : C4 3A                       ldi     (PRINTINTEGER-1) & 255
(2)   37/    938A : 33                          xpal    P3
(2)   38/    938B : 3F                  	xppc 	p3
(2)   39/    938C : C4 20               	ldi 	' '													; trailing space
(2)   40/    938E : 3F                  	xppc 	p3
(2)   41/    938F : 90 C2               	jmp 	CMD_Print
(2)   42/    9391 :                     ;
(2)   43/    9391 :                     ;	"<quoted string>"
 AS V1.42 Beta [Bld 102] - source file minol.asm(print.asm) - page 16 - 1/11/2016 13:50:19


(2)   44/    9391 :                     ;
(2)   45/    9391 :                     CPR_QuotedString:
(2)   46/    9391 : C5 01               	ld 		@1(p1) 												; get character
(2)   47/    9393 : 98 35               	jz 		CPR_Syntax 											; if NULL, syntax error.
(2)   48/    9395 : E4 22               	xri 	'"'													; if closing quote
(2)   49/    9397 : 98 BA               	jz 		CMD_Print
(2)   50/    9399 : C1 FF               	ld 		-1(p1)												; re-get it
(2)   51/    939B : 3F                  	xppc 	p3 													; print it
(2)   52/    939C : 90 F3               	jmp 	CPR_QuotedString
(2)   53/    939E :                     ;
(2)   54/    939E :                     ;	$(H,L) print string at address, ended by -ve or 0.
(2)   55/    939E :                     ;
(2)   56/    939E :                     CPR_StringAtAddress:
(2)   57/    939E : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate (H,L)
(2)   57/    939E : C4 96                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   57/    93A0 : 37                          xpah    P3
(2)   57/    93A1 : C4 9A                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   57/    93A3 : 33                          xpal    P3
(2)   58/    93A4 : 3F                  	xppc 	p3	
(2)   59/    93A5 : 94 2D               	jp 		CPR_Over											; exit on error
(2)   60/    93A7 :                     
(2)   61/    93A7 : C6 FF               	ld 		@-1(p2) 											; retrieve H to P1.H
(2)   62/    93A9 : 35                  	xpah 	p1
(2)   63/    93AA : CA 00               	st 		(p2)												; and save P1.H there
(2)   64/    93AC : C6 FF               	ld 		@-1(p2) 											; retrieve L to P1.L
(2)   65/    93AE : 31                  	xpal 	p1
(2)   66/    93AF : CA 00               	st 		(p2)
(2)   67/    93B1 : (MACRO)             	lpi 	p3,Print-1 											; set up P3 to print.
(2)   67/    93B1 : C4 91                       ldi     (PRINT-1) / 256
(2)   67/    93B3 : 37                          xpah    P3
(2)   67/    93B4 : C4 96                       ldi     (PRINT-1) & 255
(2)   67/    93B6 : 33                          xpal    P3
(2)   68/    93B7 :                     CPR_StringLoop:
(2)   69/    93B7 : C5 01               	ld 		@1(p1) 												; fetch and bump character
(2)   70/    93B9 : 98 02               	jz 		CPR_StringExit 										; if zero end of string
(2)   71/    93BB : 94 08               	jp 		CPR_StringPrint 									; if +ve printable character
(2)   72/    93BD :                     ;
(2)   73/    93BD :                     CPR_StringExit:
(2)   74/    93BD : C6 01               	ld 		@1(p2)												; restore P1.
(2)   75/    93BF : 31                  	xpal 	p1
(2)   76/    93C0 : C6 01               	ld 		@1(p2)
(2)   77/    93C2 : 35                  	xpah 	p1
(2)   78/    93C3 : 90 8E               	jmp 	CMD_Print 											; and print the next thing.
(2)   79/    93C5 :                     ;
(2)   80/    93C5 :                     CPR_StringPrint:
(2)   81/    93C5 : C1 FF               	ld 		-1(p1) 												; retrieve, print and loop
(2)   82/    93C7 : 3F                  	xppc 	p3
(2)   83/    93C8 : 90 ED               	jmp 	CPR_StringLoop
(2)   84/    93CA :                     ;
(2)   85/    93CA :                     ;	Syntax Error
(2)   86/    93CA :                     ;
(2)   87/    93CA :                     CPR_Syntax:
(2)   88/    93CA : C4 05               	ldi 	ERRC_Syntax
(2)   89/    93CC : 01                  	xae
(2)   90/    93CD : 02                  	ccl
(2)   91/    93CE :                     CPR_Over2:
(2)   92/    93CE : 90 04               	jmp 	CPR_Over
(2)   93/    93D0 :                     ;
(2)   94/    93D0 :                     ;	Print return and end okay.
(2)   95/    93D0 :                     ;
 AS V1.42 Beta [Bld 102] - source file minol.asm(print.asm) - page 17 - 1/11/2016 13:50:19


(2)   96/    93D0 :                     CPR_EndReturn:
(2)   97/    93D0 : C4 0D               	ldi 	13													; print a carriage return.
(2)   98/    93D2 : 3F                  	xppc 	p3
(2)   99/    93D3 :                     CPR_EndOk:														; end successfully.
(2)  100/    93D3 : 03                  	scl 														; set carry flag (no error)
(2)  101/    93D4 :                     
(2)  102/    93D4 :                     CPR_Over:
(2)  103/    93D4 :                     	
(1)   18/    93D4 :                     	include source\commands\call.asm 							; CALL
(2)    1/    93D4 :                     ; ****************************************************************************************************************
(2)    2/    93D4 :                     ; ****************************************************************************************************************
(2)    3/    93D4 :                     ;
(2)    4/    93D4 :                     ;												CALL command
(2)    5/    93D4 :                     ;	
(2)    6/    93D4 :                     ; ****************************************************************************************************************
(2)    7/    93D4 :                     ; ****************************************************************************************************************
(2)    8/    93D4 :                     
(2)    9/    93D4 : 90 27               	jmp		CCA_Over
(2)   10/    93D6 :                     
(2)   11/    93D6 :                     CMD_Call:
(2)   12/    93D6 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the address pair (e.g. (H,L))
(2)   12/    93D6 : C4 96                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   12/    93D8 : 37                          xpah    P3
(2)   12/    93D9 : C4 9A                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   12/    93DB : 33                          xpal    P3
(2)   13/    93DC : 3F                  	xppc 	p3
(2)   14/    93DD : 94 1E               	jp 		CCA_Over 											; exit on error.
(2)   15/    93DF : C2 FE               	ld 		-2(p2) 												; retrieve the L value to E
(2)   16/    93E1 : 01                  	xae 	
(2)   17/    93E2 : C2 FF               	ld 		-1(p2)												; retrieve the H value to P3.H
(2)   18/    93E4 : 37                  	xpah 	p3
(2)   19/    93E5 : 40                  	lde	 														; copy L value to P3.L
(2)   20/    93E6 : 33                  	xpal 	p3
(2)   21/    93E7 : C7 FF               	ld 		@-1(p3) 											; fix up for pre-increment
(2)   22/    93E9 : (MACRO)             	pushp 	p1 													; save P1
(2)   22/    93E9 : 35                          xpah    P1
(2)   22/    93EA : CE FF                       st              @-1(p2)
(2)   22/    93EC : 31                          xpal    P1
(2)   22/    93ED : CE FF                       st              @-1(p2)
(2)   23/    93EF : (MACRO)             	lpi 	p1,Variables 										; and point P1 to the variables
(2)   23/    93EF : C4 0C                       ldi     (VARIABLES) / 256
(2)   23/    93F1 : 35                          xpah    P1
(2)   23/    93F2 : C4 90                       ldi     (VARIABLES) & 255
(2)   23/    93F4 : 31                          xpal    P1
(2)   24/    93F5 : 03                  	scl 														; set CY/L flag, so the call can return an error.
(2)   25/    93F6 : 3F                  	xppc 	p3 													; call the routine
(2)   26/    93F7 : (MACRO)             	pullp	p1 													; restore P1
(2)   26/    93F7 : C6 01                       ld              @1(p2)
(2)   26/    93F9 : 31                          xpal    P1
(2)   26/    93FA : C6 01                       ld              @1(p2)
(2)   26/    93FC : 35                          xpah    P1
(2)   27/    93FD :                     	
(2)   28/    93FD :                     CCA_Over:
(1)   19/    93FD :                     	include source\commands\let.asm 							; LET (optional, but slower if not present)
(2)    1/    93FD :                     ; ****************************************************************************************************************
(2)    2/    93FD :                     ; ****************************************************************************************************************
(2)    3/    93FD :                     ;
(2)    4/    93FD :                     ;												LET command
(2)    5/    93FD :                     ;	
(2)    6/    93FD :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(let.asm) - page 18 - 1/11/2016 13:50:19


(2)    7/    93FD :                     ; ****************************************************************************************************************
(2)    8/    93FD :                     
(2)    9/    93FD : 90 51               	jmp 	CLE_Over
(2)   10/    93FF :                     
(2)   11/    93FF :                     CMD_Let:
(2)   12/    93FF : C1 00               	ld 		(p1) 												; look at character
(2)   13/    9401 : E4 28               	xri 	'('													; is it let (h,l) ?
(2)   14/    9403 : 98 20               	jz 		CLE_IsHL 											; if so, go to the (H,L) code
(2)   15/    9405 : C1 00               	ld 		(p1) 												; re-read it.
(2)   16/    9407 : 02                  	ccl
(2)   17/    9408 : F4 A5               	adi 	255-'Z' 											; will be +ve on error
(2)   18/    940A : 94 04               	jp 		CLE_Syntax 											; e.g. > Z
(2)   19/    940C : F4 1A               	adi 	26 													; will be 0-25 if A..Z
(2)   20/    940E : 94 06               	jp 		CLE_SingleVariable
(2)   21/    9410 :                     ;
(2)   22/    9410 :                     ;	Syntax Error
(2)   23/    9410 :                     ;
(2)   24/    9410 :                     CLE_Syntax:
(2)   25/    9410 : C4 05               	ldi 	ERRC_Syntax 										; set E to error code.
(2)   26/    9412 : 01                  	xae
(2)   27/    9413 : 02                  	ccl 														; CY/L = 0 = Error
(2)   28/    9414 : 90 3A               	jmp 	CLE_Over 											; and exit
(2)   29/    9416 :                     ;
(2)   30/    9416 :                     ;	A-Z. AC contains 0-25
(2)   31/    9416 :                     ;
(2)   32/    9416 :                     CLE_SingleVariable:
(2)   33/    9416 : 02                  	ccl  														; work out variable address, and put on stack.
(2)   34/    9417 : F4 90               	adi 	Variables & 255
(2)   35/    9419 : CE FE               	st 		@-2(p2) 
(2)   36/    941B : C4 0C               	ldi 	Variables / 256
(2)   37/    941D : F4 00               	adi 	0
(2)   38/    941F : CA 01               	st 		1(p2)
(2)   39/    9421 : C5 01               	ld 		@1(p1) 												; skip over the variable.
(2)   40/    9423 : 90 0B               	jmp 	CLE_EvaluateAndWrite
(2)   41/    9425 :                     ;
(2)   42/    9425 :                     ;	LET is (H,L) = <expr>
(2)   43/    9425 :                     ;
(2)   44/    9425 :                     CLE_IsHL:
(2)   45/    9425 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the (H,L)
(2)   45/    9425 : C4 96                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   45/    9427 : 37                          xpah    P3
(2)   45/    9428 : C4 9A                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   45/    942A : 33                          xpal    P3
(2)   46/    942B : 3F                  	xppc 	p3
(2)   47/    942C : 94 22               	jp 		CLE_Over 											; exit on error
(2)   48/    942E : C6 FE               	ld 		@-2(p2) 											; the address to write to is now on TOS.
(2)   49/    9430 :                     ;
(2)   50/    9430 :                     ;	Evaluate and write.
(2)   51/    9430 :                     ;
(2)   52/    9430 :                     CLE_EvaluateAndWrite:
(2)   53/    9430 : C5 01               	ld 		@1(p1) 												; skip over spaces
(2)   54/    9432 : E4 20               	xri 	' '
(2)   55/    9434 : 98 FA               	jz 		CLE_EvaluateAndWrite
(2)   56/    9436 : E4 1D               	xri 	' '!'='												; check first non space character is =
(2)   57/    9438 : 9C D6               	jnz 	CLE_Syntax 											; if not, a syntax error.
(2)   58/    943A :                     
(2)   59/    943A : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; set up to evaluate the RHS
(2)   59/    943A : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)   59/    943C : 37                          xpah    P3
(2)   59/    943D : C4 46                       ldi     (EVALUATEEXPRESSION-1) & 255
 AS V1.42 Beta [Bld 102] - source file minol.asm(let.asm) - page 19 - 1/11/2016 13:50:19


(2)   59/    943F : 33                          xpal    P3
(2)   60/    9440 : 3F                  	xppc 	p3													; do it
(2)   61/    9441 : C6 02               	ld 		@2(p2) 												; remove target from TOS but leave data there
(2)   62/    9443 : 06                  	csa 														; did that evaluate cause an error ?
(2)   63/    9444 : 94 0A               	jp 		CLE_Over 											; if so, exit with that error.
(2)   64/    9446 :                     
(2)   65/    9446 : C2 FE               	ld 		-2(p2) 												; load address into P3
(2)   66/    9448 : 33                  	xpal 	p3
(2)   67/    9449 : C2 FF               	ld 		-1(p2)
(2)   68/    944B : 37                  	xpah 	p3
(2)   69/    944C : 40                  	lde 														; get value
(2)   70/    944D : CB 00               	st 		(p3) 												; store there
(2)   71/    944F : 03                  	scl 														; no error and exit.
(2)   72/    9450 :                     
(2)   73/    9450 :                     CLE_Over:
(1)   20/    9450 :                     	include source\commands\if.asm								; IF
(2)    1/    9450 :                     ; ****************************************************************************************************************
(2)    2/    9450 :                     ; ****************************************************************************************************************
(2)    3/    9450 :                     ;
(2)    4/    9450 :                     ;												IF command
(2)    5/    9450 :                     ;	
(2)    6/    9450 :                     ; ****************************************************************************************************************
(2)    7/    9450 :                     ; ****************************************************************************************************************
(2)    8/    9450 :                     
(2)    9/    9450 : 90 4D               	jmp		CIF_Over
(2)   10/    9452 :                     
(2)   11/    9452 :                     CMD_If:
(2)   12/    9452 : 3F                  	xppc 	p3 													; calculate LHS of expr.
(2)   13/    9453 : 94 4A               	jp 		CIF_Over											; exit on error.
(2)   14/    9455 : C1 00               	ld 		(p1)												; get the relative operator.
(2)   15/    9457 : E4 3D               	xri 	'='													; check it is =, < or #
(2)   16/    9459 : 98 0E               	jz 		CIF_Continue
(2)   17/    945B : E4 1E               	xri 	'='!'#'
(2)   18/    945D : 98 0A               	jz 		CIF_Continue
(2)   19/    945F : E4 1F               	xri 	'#'!'<'
(2)   20/    9461 : 98 06               	jz 		CIF_Continue
(2)   21/    9463 :                     ;
(2)   22/    9463 :                     ;	Syntax error - bad relative operation.
(2)   23/    9463 :                     ;
(2)   24/    9463 :                     CIF_Syntax:
(2)   25/    9463 : C4 05               	ldi	 	ERRC_Syntax											; report syntax error
(2)   26/    9465 : 01                  	xae
(2)   27/    9466 : 02                  	ccl
(2)   28/    9467 : 90 36               	jmp 	CIF_Over
(2)   29/    9469 :                     ;
(2)   30/    9469 :                     ;	Continue IF - have LHS in E.
(2)   31/    9469 :                     ;
(2)   32/    9469 :                     CIF_Continue:
(2)   33/    9469 : C5 01               	ld 		@1(p1) 												; reget operator, and save on stack
(2)   34/    946B : CE FF               	st 		@-1(p2)
(2)   35/    946D : 40                  	lde 														; save LHS on stack.
(2)   36/    946E : CE FF               	st 		@-1(p2)
(2)   37/    9470 : 3F                  	xppc 	p3 													; evaluate the RHS of the expression
(2)   38/    9471 : C6 02               	ld 		@2(p2) 												; drop operator and LHS but the values still there.
(2)   39/    9473 : 06                  	csa 														; check for RHS error
(2)   40/    9474 : 94 29               	jp 		CIF_Over 											; and exit on error
(2)   41/    9476 : C2 FF               	ld 		-1(p2) 												; get operator
(2)   42/    9478 : E4 3C               	xri 	'<'
(2)   43/    947A : 9C 09               	jnz 	CIF_Equality 										; if not less than it's an equality test e.g. # or =
(2)   44/    947C :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(if.asm) - page 20 - 1/11/2016 13:50:19


(2)   45/    947C :                     ; ****************************************************************************************************************
(2)   46/    947C :                     ;												Less than test.
(2)   47/    947C :                     ; ****************************************************************************************************************
(2)   48/    947C :                     
(2)   49/    947C : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   50/    947E : 03                  	scl
(2)   51/    947F : 78                  	cae 														; subtract RHS.
(2)   52/    9480 : 06                  	csa 														; get CY/L flag
(2)   53/    9481 : D4 80               	ani 	0x80 												; now it is AC = 0 if < true.
(2)   54/    9483 : 90 0D               	jmp 	CIF_TestIfZero
(2)   55/    9485 :                     
(2)   56/    9485 :                     ; ****************************************************************************************************************
(2)   57/    9485 :                     ;											Equal/Not Equal Test.
(2)   58/    9485 :                     ; ****************************************************************************************************************
(2)   59/    9485 :                     	
(2)   60/    9485 :                     CIF_Equality:
(2)   61/    9485 : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   62/    9487 : 60                  	xre 														; compare to RHS. AC = 0 if *equal*
(2)   63/    9488 : 98 02               	jz 		CIF_Equality2
(2)   64/    948A : C4 02               	ldi 	2 													; AC = 0 if *equal* 2 if *different*
(2)   65/    948C :                     CIF_Equality2:
(2)   66/    948C : 01                  	xae 														; save in E
(2)   67/    948D : C2 FF               	ld 		-1(p2) 												; get operator.
(2)   68/    948F : D4 02               	ani 	2 													; is now 0 if '=' ($3D) 2 if '#' ($23)
(2)   69/    9491 : 60                  	xre 														; XOR with the result. Now 0 if passes test.
(2)   70/    9492 :                     
(2)   71/    9492 :                     ; ****************************************************************************************************************
(2)   72/    9492 :                     ;							Pass Test (e.g. execute statement following ;) if AC = 0
(2)   73/    9492 :                     ; ****************************************************************************************************************
(2)   74/    9492 :                     
(2)   75/    9492 :                     CIF_TestIfZero:
(2)   76/    9492 : 03                  	scl 														; set CY/L = No Error.
(2)   77/    9493 : 9C 0A               	jnz 	CIF_Over 											; if non-zero then do next command as normal.
(2)   78/    9495 :                     	
(2)   79/    9495 : C1 00               	ld 		(p1) 												; get next character
(2)   80/    9497 : E4 3B               	xri 	';'													; should be a semicolon
(2)   81/    9499 : 9C C8               	jnz 	CIF_Syntax 											; if not error
(2)   82/    949B : C5 01               	ld 		@1(p1) 												; step over it.
(2)   83/    949D : 90 54               	jmp 	ExecuteFromAddressDirect 							; and run from here.
(2)   84/    949F :                     
(2)   85/    949F :                     CIF_Over:
(2)   86/    949F :                     
(2)   87/    949F :                     
(1)   21/    949F :                     	include source\commands\goto_run.asm						; GOTO and RUN (has to be last, probably !)
(2)    1/    949F :                     ; ****************************************************************************************************************
(2)    2/    949F :                     ; ****************************************************************************************************************
(2)    3/    949F :                     ;
(2)    4/    949F :                     ;												GOTO and RUN
(2)    5/    949F :                     ;	
(2)    6/    949F :                     ; ****************************************************************************************************************
(2)    7/    949F :                     ; ****************************************************************************************************************
(2)    8/    949F :                     
(2)    9/    949F : 90 29               	jmp 	CRG_Over											; Skip over this command.
(2)   10/    94A1 :                     
(2)   11/    94A1 :                     ; ****************************************************************************************************************
(2)   12/    94A1 :                     ;												GOTO command
(2)   13/    94A1 :                     ; ****************************************************************************************************************
(2)   14/    94A1 :                     
(2)   15/    94A1 :                     CMD_Goto:	
(2)   16/    94A1 : 3F                  	xppc 	p3 													; evaluate the line number to GOTO, in E
 AS V1.42 Beta [Bld 102] - source file minol.asm(goto_run.asm) - page 21 - 1/11/2016 13:50:19


(2)   17/    94A2 : 94 26               	jp 		CRG_Over 											; exit if error occurred
(2)   18/    94A4 : 40                  	lde 														; get line number
(2)   19/    94A5 : CA FF               	st 		-1(p2) 												; save below TOS.
(2)   20/    94A7 : (MACRO)             	lpi 	p1,ProgramBase 										; point P1 to program Base.
(2)   20/    94A7 : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   20/    94A9 : 35                          xpah    P1
(2)   20/    94AA : C4 1F                       ldi     (PROGRAMBASE) & 255
(2)   20/    94AC : 31                          xpal    P1
(2)   21/    94AD :                     CRG_Find:
(2)   22/    94AD : C1 00               	ld 		0(p1) 												; look at offset
(2)   23/    94AF : 94 06               	jp 		CRG_NotEnd											; if -ve then end of program.
(2)   24/    94B1 : C4 01               	ldi 	ERRC_Label 											; return label error
(2)   25/    94B3 : 01                  	xae
(2)   26/    94B4 : 02                  	ccl 														; set error flag
(2)   27/    94B5 : 90 13               	jmp 	CRG_Over
(2)   28/    94B7 :                     ;
(2)   29/    94B7 :                     CRG_NotEnd:
(2)   30/    94B7 : 01                  	xae 														; offset in E
(2)   31/    94B8 : C1 01               	ld 		1(p1) 												; get line number
(2)   32/    94BA : E2 FF               	xor 	-1(p2) 												; go back if not required one.
(2)   33/    94BC : 98 0A               	jz 		CRG_ExecuteFromP1									; if found, run from P1.
(2)   34/    94BE : C5 80               	ld 		@-0x80(p1) 											; go to next line
(2)   35/    94C0 : 90 EB               	jmp 	CRG_Find 											; keep trying.
(2)   36/    94C2 :                     ;
(2)   37/    94C2 :                     ; ****************************************************************************************************************
(2)   38/    94C2 :                     ;												RUN command
(2)   39/    94C2 :                     ; ****************************************************************************************************************
(2)   40/    94C2 :                     
(2)   41/    94C2 :                     CMD_Run:	
(2)   42/    94C2 : (MACRO)             	lpi 	p1,ProgramBase 										; start from first line of program
(2)   42/    94C2 : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   42/    94C4 : 35                          xpah    P1
(2)   42/    94C5 : C4 1F                       ldi     (PROGRAMBASE) & 255
(2)   42/    94C7 : 31                          xpal    P1
(2)   43/    94C8 :                     CRG_ExecuteFromP1:
(2)   44/    94C8 : 90 0D               	jmp 	CheckLastCommandThenExecute 						; check if the last command and if not execute.
(2)   45/    94CA :                     
(2)   46/    94CA :                     CRG_Over:
(2)   47/    94CA :                     
(1)   22/    94CA :                     
(1)   23/    94CA :                     ; ****************************************************************************************************************
(1)   24/    94CA :                     ;								Command execution complete, check for error
(1)   25/    94CA :                     ; ****************************************************************************************************************
(1)   26/    94CA :                     
(1)   27/    94CA :                     EndOfCommandExecution:
(1)   28/    94CA : 06                  	csa 														; check CY/L error flag
(1)   29/    94CB : 94 12               	jp 		GotoCommandLine 									; if CY/L = 0 error so go to command line.
(1)   30/    94CD :                     
(1)   31/    94CD :                     ; ****************************************************************************************************************
(1)   32/    94CD :                     ;	Come here to execute the instruction P1 points to, after having executed, e.g. skips forward to : or NULL
(1)   33/    94CD :                     ; ****************************************************************************************************************
(1)   34/    94CD :                     
(1)   35/    94CD :                     ExecuteNextInstruction:
(1)   36/    94CD : C5 01               	ld 		@1(p1) 												; get next and skip
(1)   37/    94CF : 98 06               	jz 		CheckLastCommandThenExecute							; if NULL, check if running mode and continue if so.
(1)   38/    94D1 : E4 3A               	xri 	':'
(1)   39/    94D3 : 9C F8               	jnz 	ExecuteNextInstruction 								; keep going until colon read.
(1)   40/    94D5 : 90 1C               	jmp 	ExecuteFromAddressDirect 							; run code from the address given.
(1)   41/    94D7 :                     ;
(1)   42/    94D7 :                     ;	Test to see if the line is not the last one (e.g. offset is +ve) and if so, execute its code.
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 22 - 1/11/2016 13:50:19


(1)   43/    94D7 :                     ;
(1)   44/    94D7 :                     CheckLastCommandThenExecute:
(1)   45/    94D7 : C1 00               	ld 		(p1) 												; look at the offset to next.
(1)   46/    94D9 : 94 0C               	jp 		ExecuteFromCommandStart 							; if +ve value, execute the line here.
(1)   47/    94DB :                     ;
(1)   48/    94DB :                     ;	Have reached the end of the program. The buffer with typed commands has $FF on the end to 'fake' this.
(1)   49/    94DB :                     ; 	e.g. when it reaches the end of that command it thinks it's dropped off the top of the program
(1)   50/    94DB :                     ;
(1)   51/    94DB : 03                  	scl 														; there is no error.
(1)   52/    94DC : C4 FF               	ldi 	ERRC_End 											; set the error code to "End"
(1)   53/    94DE : 01                  	xae
(1)   54/    94DF :                     GotoCommandLine: 												; return to Command Line with CY/L = error and E = code
(1)   55/    94DF : 90 FE               	jmp 	GotoCommandLine										; if CY/L = 1 (no error) E not used.
(1)   56/    94E1 :                     ;
(1)   57/    94E1 :                     ;	Syntax error comes here.
(1)   58/    94E1 :                     ;
(1)   59/    94E1 :                     SyntaxError:
(1)   60/    94E1 : C4 05               	ldi 	ERRC_Syntax
(1)   61/    94E3 : 01                  	xae
(1)   62/    94E4 : 02                  	ccl
(1)   63/    94E5 : 90 F8               	jmp 	GotoCommandLine
(1)   64/    94E7 :                     
(1)   65/    94E7 :                     ; ****************************************************************************************************************
(1)   66/    94E7 :                     ;	  Execute from the instruction at P1 (preceded by offset, line number), which is known to be a valid line.
(1)   67/    94E7 :                     ; ****************************************************************************************************************
(1)   68/    94E7 :                     
(1)   69/    94E7 :                     ExecuteFromCommandStart:
(1)   70/    94E7 : (MACRO)             	lpi 	p3,CurrentLine 										; point P3 to the current line
(1)   70/    94E7 : C4 0C                       ldi     (CURRENTLINE) / 256
(1)   70/    94E9 : 37                          xpah    P3
(1)   70/    94EA : C4 8D                       ldi     (CURRENTLINE) & 255
(1)   70/    94EC : 33                          xpal    P3
(1)   71/    94ED : C1 01               	ld 		1(p1) 												; read the line number 
(1)   72/    94EF : CB 00               	st 		(p3)												; and save it - current line # updated.
(1)   73/    94F1 : C5 02               	ld 		@2(p1) 												; skip over offset (+0) line number (+1)
(1)   74/    94F3 :                     
(1)   75/    94F3 :                     ; ****************************************************************************************************************
(1)   76/    94F3 :                     ;				Run command where the instruction is at P1 (e.g. it is an ASCIIZ string)
(1)   77/    94F3 :                     ; ****************************************************************************************************************
(1)   78/    94F3 :                     
(1)   79/    94F3 :                     ExecuteFromAddressDirect:
(1)   80/    94F3 : C5 01               	ld 		@1(p1) 												; read next character
(1)   81/    94F5 : 98 E0               	jz 		CheckLastCommandThenExecute 						; if \0 then check for the next line.
(1)   82/    94F7 : E4 20               	xri	 	' '
(1)   83/    94F9 : 98 F8               	jz 		ExecuteFromAddressDirect 							; skip over spaces.
(1)   84/    94FB : E4 1A               	xri 	' '!':'												
(1)   85/    94FD : 98 F4               	jz 		ExecuteFromAddressDirect 							; skip over colons.
(1)   86/    94FF : E4 18               	xri 	':'!'"'					
(1)   87/    9501 : 98 CA               	jz 		ExecuteNextInstruction 								; if double quote (comment) found go to next instruction.
(1)   88/    9503 :                     ;
(1)   89/    9503 :                     ;	Now look the command up in the command list.
(1)   90/    9503 :                     ;
(1)   91/    9503 : C1 FF               	ld 		-1(p1) 												; read first character of command again
(1)   92/    9505 : 01                  	xae 														; put in E.
(1)   93/    9506 : (MACRO)             	lpi 	p3,CommandList
(1)   93/    9506 : C4 96                       ldi     (COMMANDLIST) / 256
(1)   93/    9508 : 37                          xpah    P3
(1)   93/    9509 : C4 E5                       ldi     (COMMANDLIST) & 255
(1)   93/    950B : 33                          xpal    P3
(1)   94/    950C :                     EAFD_Search:
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 23 - 1/11/2016 13:50:19


(1)   95/    950C : C7 05               	ld 		@5(p3) 												; read first character and bump to next.
(1)   96/    950E : 98 2C               	jz 		EAFD_LETCode 										; if zero then give up.
(1)   97/    9510 : 60                  	xre 														; same as first character ?
(1)   98/    9511 : 9C F9               	jnz		EAFD_Search 										; no, keep looking.
(1)   99/    9513 :                     
(1)  100/    9513 : C3 FC               	ld 		-4(p3) 												; read 2nd character
(1)  101/    9515 : E1 00               	xor 	(p1) 												; compare against actual second character
(1)  102/    9517 : 9C F3               	jnz 	EAFD_Search
(1)  103/    9519 :                     ;
(1)  104/    9519 :                     ;	Skip over characters in the command, checking for NULL and : which would be syntax errors.
(1)  105/    9519 :                     ;
(1)  106/    9519 : C3 FD               	ld 		-3(p3) 												; number of characters to skip (one less than total as one skipped)
(1)  107/    951B : CA FF               	st 		-1(p2) 												; temporary count.
(1)  108/    951D :                     EAFD_Skip:
(1)  109/    951D : C5 01               	ld 		@1(p1) 												; read a character and skip
(1)  110/    951F : 98 C0               	jz 		SyntaxError 										; if zero, then syntax error
(1)  111/    9521 : E4 3A               	xri 	':'
(1)  112/    9523 : 98 BC               	jz 		SyntaxError 										; if colon, then syntax error.
(1)  113/    9525 : BA FF               	dld 	-1(p2) 												; do it the requisite number of times.
(1)  114/    9527 : 9C F4               	jnz 	EAFD_Skip
(1)  115/    9529 :                     ;
(1)  116/    9529 :                     ;	Skip over any subsequent spaces
(1)  117/    9529 :                     ;
(1)  118/    9529 :                     EAFD_SkipSpaces:
(1)  119/    9529 : C5 01               	ld 		@1(p1) 												; check for spaces
(1)  120/    952B : E4 20               	xri 	' '													; space found
(1)  121/    952D : 98 FA               	jz 		EAFD_SkipSpaces
(1)  122/    952F : C5 FF               	ld 		@-1(p1) 											; undo last fetch so first character of next bit.
(1)  123/    9531 :                     ;
(1)  124/    9531 :                     ;	P1 is set up so execute the handler.
(1)  125/    9531 :                     ;
(1)  126/    9531 : C3 FE               	ld 		-2(p3)												; get execute LSB
(1)  127/    9533 : 01                  	xae 														; save in E
(1)  128/    9534 : C3 FF               	ld 		-1(p3) 												; get execute MSB
(1)  129/    9536 : 37                  	xpah 	p3 													; put in P3.H
(1)  130/    9537 : 40                  	lde 														; copy E to P3.L
(1)  131/    9538 : 33                  	xpal 	p3
(1)  132/    9539 : 3F                  	xppc 	p3
(1)  133/    953A : 90 0B               	jmp 	EvaluateExpression 									; is set up to have immediate evaluate call.
(1)  134/    953C :                     ;
(1)  135/    953C :                     ;	Couldn't find a command, so point P1 to first character, then call the LET code.
(1)  136/    953C :                     ;
(1)  137/    953C :                     EAFD_LETCode:
(1)  138/    953C : C5 FF               	ld 		@-1(p1) 											; point P1 to first character of command.
(1)  139/    953E : (MACRO)             	lpi 	p3,CMD_Let-1 										; go execute LET with evaluate re-entrancy
(1)  139/    953E : C4 93                       ldi     (CMD_LET-1) / 256
(1)  139/    9540 : 37                          xpah    P3
(1)  139/    9541 : C4 FE                       ldi     (CMD_LET-1) & 255
(1)  139/    9543 : 33                          xpal    P3
(1)  140/    9544 : 3F                  	xppc 	p3
(1)  141/    9545 : 90 00               	jmp 	EvaluateExpression
(1)  142/    9547 :                     
(1)  143/    9547 :                     	include source\expression.asm 								; expression evaluator.
(2)    1/    9547 :                     ; ****************************************************************************************************************
(2)    2/    9547 :                     ; ****************************************************************************************************************
(2)    3/    9547 :                     ;
(2)    4/    9547 :                     ;												Expression Evaluation
(2)    5/    9547 :                     ;
(2)    6/    9547 :                     ; ****************************************************************************************************************
(2)    7/    9547 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 24 - 1/11/2016 13:50:19


(2)    8/    9547 :                     
(2)    9/    9547 :                     ; ****************************************************************************************************************
(2)   10/    9547 :                     ; ****************************************************************************************************************
(2)   11/    9547 :                     ;
(2)   12/    9547 :                     ;		Evaluate expression at P1. Return 	CY/L = 0 : Error 	E = Error Code
(2)   13/    9547 :                     ;											CY/L = 1 : Okay 	E = Result
(2)   14/    9547 :                     ;
(2)   15/    9547 :                     ;		Terms are : 	A-Z 			Variables
(2)   16/    9547 :                     ;						[0-9]+			Constants
(2)   17/    9547 :                     ;						! 				Random byte
(2)   18/    9547 :                     ;						'?'				Character constant
(2)   19/    9547 :                     ;						(<expr>,<expr>)	Read Memory location
(2)   20/    9547 :                     ;
(2)   21/    9547 :                     ; ****************************************************************************************************************
(2)   22/    9547 :                     ; ****************************************************************************************************************
(2)   23/    9547 :                     
(2)   24/    9547 : =0x1                EEX_PendingOp = 1 												; offset to pending operation
(2)   25/    9547 : =0x0                EEX_Value = 0 													; offset to value
(2)   26/    9547 :                     
(2)   27/    9547 :                     EvaluateExpression:
(2)   28/    9547 : (MACRO)             	pushp 	p3 													; save P3 on stack
(2)   28/    9547 : 37                          xpah    P3
(2)   28/    9548 : CE FF                       st              @-1(p2)
(2)   28/    954A : 33                          xpal    P3
(2)   28/    954B : CE FF                       st              @-1(p2)
(2)   29/    954D : C4 2B               	ldi 	'+'													; push pending operation on stack
(2)   30/    954F : CE FF               	st 		@-1(p2)
(2)   31/    9551 : C4 00               	ldi 	0 													; push current value on stack
(2)   32/    9553 : CE FF               	st 		@-1(p2)												; effectively this puts 0+ on the front of the expression.
(2)   33/    9555 :                     
(2)   34/    9555 :                     ; ****************************************************************************************************************
(2)   35/    9555 :                     ;													Get Next Term
(2)   36/    9555 :                     ; ****************************************************************************************************************
(2)   37/    9555 :                     
(2)   38/    9555 :                     EEX_Term:
(2)   39/    9555 : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   39/    9555 : C4 0C                       ldi     (VARIABLES) / 256
(2)   39/    9557 : 37                          xpah    P3
(2)   39/    9558 : C4 90                       ldi     (VARIABLES) & 255
(2)   39/    955A : 33                          xpal    P3
(2)   40/    955B :                     EEX_NextChar:
(2)   41/    955B : C1 00               	ld 		(p1) 												; look at character
(2)   42/    955D : 98 4F               	jz 		EEX_TermError
(2)   43/    955F : C5 01               	ld 		@1(p1) 												; fetch and skip over.
(2)   44/    9561 : E4 20               	xri 	' '													; is it space ?
(2)   45/    9563 : 98 F6               	jz 		EEX_NextChar
(2)   46/    9565 : E4 08               	xri 	' '!'('												; is it memory access ?
(2)   47/    9567 : 98 55               	jz 		EEX_MemoryAccess
(2)   48/    9569 : E4 09               	xri 	'('!'!'												; is it a random value ?
(2)   49/    956B : 9C 1B               	jnz 	EEX_NotRandom
(2)   50/    956D :                     
(2)   51/    956D :                     ; ****************************************************************************************************************
(2)   52/    956D :                     ;												Term is ! (random byte)
(2)   53/    956D :                     ; ****************************************************************************************************************
(2)   54/    956D :                     
(2)   55/    956D :                     EEX_Random:
(2)   56/    956D : 02                  	ccl 	
(2)   57/    956E : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; shift the seed right
(2)   58/    9570 : 1F                  	rrl
(2)   59/    9571 : CB FF               	st 		RandomSeed+1-Variables(p3)
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 25 - 1/11/2016 13:50:19


(2)   60/    9573 : 01                  	xae 														; put MSB in E
(2)   61/    9574 : C3 FE               	ld 		RandomSeed-Variables(p3)
(2)   62/    9576 : 1F                  	rrl
(2)   63/    9577 : CB FE               	st 		RandomSeed-Variables(p3)
(2)   64/    9579 : 60                  	xre 														; XOR E into LSB
(2)   65/    957A : 01                  	xae
(2)   66/    957B : 06                  	csa 														; if CY/L is zero
(2)   67/    957C : D4 80               	ani 	0x80
(2)   68/    957E : 9C 06               	jnz 	EEX_NoTap 
(2)   69/    9580 : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; XOR MSB with $B4
(2)   70/    9582 : E4 B4               	xri 	0xB4
(2)   71/    9584 : CB FF               	st 		RandomSeed+1-Variables(p3)
(2)   72/    9586 :                     EEX_NoTap:
(2)   73/    9586 : 90 65               	jmp 	EEX_HaveTerm
(2)   74/    9588 :                     
(2)   75/    9588 :                     EEX_NotRandom:
(2)   76/    9588 : E4 06               	xri 	'!'!0x27											; is it a quote ?
(2)   77/    958A : 9C 0F               	jnz 	EEX_NotQuote
(2)   78/    958C :                     
(2)   79/    958C :                     ; ****************************************************************************************************************
(2)   80/    958C :                     ;													Term is '<char>'
(2)   81/    958C :                     ; ****************************************************************************************************************
(2)   82/    958C :                     
(2)   83/    958C : C1 00               	ld 		(p1) 												; get character that is quoted
(2)   84/    958E : 98 1E               	jz 		EEX_TermError 										; if zero, error.
(2)   85/    9590 : 01                  	xae 														; save in E if okay character.
(2)   86/    9591 : C1 01               	ld 		1(p1) 												; get character after that
(2)   87/    9593 : E4 27               	xri 	0x27 												; is it a quote ?
(2)   88/    9595 : 9C 17               	jnz 	EEX_TermError
(2)   89/    9597 : C5 02               	ld 		@2(p1) 												; skip over character and quote
(2)   90/    9599 : 90 52               	jmp 	EEX_HaveTerm 										; and execute as if a legal term
(2)   91/    959B :                     
(2)   92/    959B :                     ; ****************************************************************************************************************
(2)   93/    959B :                     ;									Not 'x' or !, so test for 0-9 and A-Z
(2)   94/    959B :                     ; ****************************************************************************************************************
(2)   95/    959B :                     
(2)   96/    959B :                     EEX_NotQuote:
(2)   97/    959B : C1 FF               	ld 		-1(p1)												; get old character.
(2)   98/    959D : 02                  	ccl
(2)   99/    959E : F4 A5               	adi 	255-'Z'												; if >= 'Z' then error.										
(2)  100/    95A0 : 94 0C               	jp 		EEX_TermError
(2)  101/    95A2 : F4 1A               	adi 	26 													; will be 0..25 if A..Z
(2)  102/    95A4 : 94 43               	jp 		EEX_Variable 										; so do as a variable.
(2)  103/    95A6 : F4 07               	adi 	'A'-1-'9'											; check if > 9
(2)  104/    95A8 : 94 04               	jp 		EEX_TermError
(2)  105/    95AA : F4 0A               	adi 	10 													; if 0-9
(2)  106/    95AC : 94 1D               	jp 		EEX_Constant
(2)  107/    95AE :                     
(2)  108/    95AE :                     ; ****************************************************************************************************************
(2)  109/    95AE :                     ;													 Error Exit.
(2)  110/    95AE :                     ; ****************************************************************************************************************
(2)  111/    95AE :                     
(2)  112/    95AE :                     EEX_TermError:
(2)  113/    95AE : C4 04               	ldi 	ERRC_Term 											; put term error in A
(2)  114/    95B0 :                     EEX_Error:
(2)  115/    95B0 : 01                  	xae 														; put error code in E
(2)  116/    95B1 : 02                  	ccl 														; clear CY/L indicating error
(2)  117/    95B2 :                     EEX_Exit:
(2)  118/    95B2 : C6 02               	ld 		@2(p2) 												; throw the pending operation and value
(2)  119/    95B4 : (MACRO)             	pullp 	p3 													; restore P3
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 26 - 1/11/2016 13:50:19


(2)  119/    95B4 : C6 01                       ld              @1(p2)
(2)  119/    95B6 : 33                          xpal    P3
(2)  119/    95B7 : C6 01                       ld              @1(p2)
(2)  119/    95B9 : 37                          xpah    P3
(2)  120/    95BA : 06                  	csa 														; put CY/L in A bit 7
(2)  121/    95BB : 3F                  	xppc 	p3 													; and exit
(2)  122/    95BC : 90 89               	jmp 	EvaluateExpression 									; make re-entrant
(2)  123/    95BE :                     
(2)  124/    95BE :                     ; ****************************************************************************************************************
(2)  125/    95BE :                     ;										Handle (<expr>,<expr>)
(2)  126/    95BE :                     ; ****************************************************************************************************************
(2)  127/    95BE :                     
(2)  128/    95BE :                     EEX_MemoryAccess:
(2)  129/    95BE : C5 FF               	ld 		@-1(p1) 											; point to the (
(2)  130/    95C0 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; call the evaluate/read of (h,l)
(2)  130/    95C0 : C4 96                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)  130/    95C2 : 37                          xpah    P3
(2)  130/    95C3 : C4 9A                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)  130/    95C5 : 33                          xpal    P3
(2)  131/    95C6 : 3F                  	xppc 	p3
(2)  132/    95C7 : 94 E9               	jp 		EEX_Exit 											; error occurred, so exit with it.
(2)  133/    95C9 : 90 22               	jmp 	EEX_HaveTerm
(2)  134/    95CB :                     
(2)  135/    95CB :                     ; ****************************************************************************************************************
(2)  136/    95CB :                     ;								Handle constant, first digit value is in A
(2)  137/    95CB :                     ; ****************************************************************************************************************
(2)  138/    95CB :                     
(2)  139/    95CB :                     EEX_Constant:
(2)  140/    95CB : 01                  	xae 														; put first digit value in E
(2)  141/    95CC :                     EEX_ConstantLoop:
(2)  142/    95CC : C1 00               	ld 		(p1) 												; get next character.
(2)  143/    95CE : 02                  	ccl
(2)  144/    95CF : F4 C6               	adi 	255-'9' 											; if >= 9 term is too large.
(2)  145/    95D1 : 94 1A               	jp 		EEX_HaveTerm
(2)  146/    95D3 : F4 8A               	adi 	10+128
(2)  147/    95D5 : 94 16               	jp 		EEX_HaveTerm
(2)  148/    95D7 : 02                  	ccl
(2)  149/    95D8 : 40                  	lde 														; A = n
(2)  150/    95D9 : 70                  	ade 														; A = n * 2
(2)  151/    95DA : 70                  	ade 														; A = n * 3
(2)  152/    95DB : 70                  	ade 														; A = n * 4
(2)  153/    95DC : 70                  	ade 														; A = n * 5
(2)  154/    95DD : 01                  	xae 														; E = n * 5
(2)  155/    95DE : 40                  	lde 														; A = n * 5
(2)  156/    95DF : 70                  	ade 														; A = n * 10
(2)  157/    95E0 : 01                  	xae
(2)  158/    95E1 : C5 01               	ld 		@1(p1) 												; read character convert to number
(2)  159/    95E3 : D4 0F               	ani 	0x0F
(2)  160/    95E5 : 70                  	ade
(2)  161/    95E6 : 01                  	xae
(2)  162/    95E7 : 90 E3               	jmp 	EEX_ConstantLoop
(2)  163/    95E9 :                     
(2)  164/    95E9 :                     
(2)  165/    95E9 :                     ; ****************************************************************************************************************
(2)  166/    95E9 :                     ;									Access variable, variable id (0-25) in A
(2)  167/    95E9 :                     ; ****************************************************************************************************************
(2)  168/    95E9 :                     
(2)  169/    95E9 :                     EEX_Variable:
(2)  170/    95E9 : 01                  	xae 														; put value 0-25 in E
(2)  171/    95EA : C3 80               	ld 		-0x80(p3) 											; load using E as index
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 27 - 1/11/2016 13:50:19


(2)  172/    95EC : 01                  	xae 														; put in E
(2)  173/    95ED :                     
(2)  174/    95ED :                     ; ****************************************************************************************************************
(2)  175/    95ED :                     ;										Have the right term in E, process it
(2)  176/    95ED :                     ; ****************************************************************************************************************
(2)  177/    95ED :                     
(2)  178/    95ED :                     EEX_HaveTerm:
(2)  179/    95ED : C2 01               	ld 		EEX_PendingOp(p2) 									; get pending operation.
(2)  180/    95EF : E4 2B               	xri 	'+'
(2)  181/    95F1 : 9C 06               	jnz 	EEX_NotAdd
(2)  182/    95F3 :                     
(2)  183/    95F3 :                     ; ****************************************************************************************************************
(2)  184/    95F3 :                     ;												Add Right Term to Value
(2)  185/    95F3 :                     ; ****************************************************************************************************************
(2)  186/    95F3 : 02                  	ccl
(2)  187/    95F4 : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  188/    95F6 : 70                  	ade 														; add right
(2)  189/    95F7 : 90 08               	jmp 	EEX_SaveAndExit 									; save and exit
(2)  190/    95F9 :                     
(2)  191/    95F9 :                     EEX_NotAdd:
(2)  192/    95F9 : E4 06               	xri 	'+'!'-'
(2)  193/    95FB : 9C 12               	jnz		EEX_NotSubtract
(2)  194/    95FD :                     
(2)  195/    95FD :                     ; ****************************************************************************************************************
(2)  196/    95FD :                     ;											 Subtract Right Term from Value
(2)  197/    95FD :                     ; ****************************************************************************************************************
(2)  198/    95FD : 03                  	scl
(2)  199/    95FE : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  200/    9600 : 78                  	cae 														; subtract right
(2)  201/    9601 :                     EEX_SaveAndExit:
(2)  202/    9601 : CA 00               	st 		EEX_Value(p2) 										; save value back
(2)  203/    9603 : 90 30               	jmp 	EEX_CheckNextOperation 								; and exit, look for next operator.
(2)  204/    9605 :                     
(2)  205/    9605 :                     EEX_Divide_Zero:												; handle divide by zero error.
(2)  206/    9605 : C4 07               	ldi 	ERRC_DivZero
(2)  207/    9607 : 90 A7               	jmp 	EEX_Error
(2)  208/    9609 :                     
(2)  209/    9609 :                     EEX_EndExpression:
(2)  210/    9609 : C2 00               	ld 		EEX_Value(p2) 										; get current value
(2)  211/    960B : 01                  	xae 														; put in E
(2)  212/    960C : 03                  	scl 														; set CY/L indicating expression okay.
(2)  213/    960D : 90 A3               	jmp 	EEX_Exit 											; and exit.
(2)  214/    960F :                     
(2)  215/    960F :                     EEX_NotSubtract:
(2)  216/    960F : E4 07               	xri 	'-'!'*'
(2)  217/    9611 : 9C 45               	jnz 	EEX_Divide
(2)  218/    9613 :                     
(2)  219/    9613 :                     ; ****************************************************************************************************************
(2)  220/    9613 :                     ;											 Multiply Right Term into Value
(2)  221/    9613 :                     ; ****************************************************************************************************************
(2)  222/    9613 :                     
(2)  223/    9613 : C2 00               	ld 		EEX_Value(p2) 										; a = left value
(2)  224/    9615 : CA 01               	st 		1(p2)
(2)  225/    9617 : C4 00               	ldi 	0													; res = 0(p2)
(2)  226/    9619 : CA 00               	st 		0(p2) 												; clear it.
(2)  227/    961B :                     EEX_MultiplyLoop:
(2)  228/    961B : 40                  	lde  														; if B == 0 then we are done.
(2)  229/    961C : 98 17               	jz 		EEX_CheckNextOperation
(2)  230/    961E : D4 01               	ani 	1 													; if B LSB is non zero.
(2)  231/    9620 : 98 07               	jz 		EEX_Multiply_B0IsZero
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 28 - 1/11/2016 13:50:19


(2)  232/    9622 : C2 00               	ld 		0(p2) 												; add A to Result
(2)  233/    9624 : 02                  	ccl
(2)  234/    9625 : F2 01               	add 	1(p2)
(2)  235/    9627 : CA 00               	st 		0(p2)
(2)  236/    9629 :                     EEX_Multiply_B0IsZero:
(2)  237/    9629 : 40                  	lde 														; shift B right
(2)  238/    962A : 1C                  	sr
(2)  239/    962B : 01                  	xae
(2)  240/    962C : C2 01               	ld 		1(p2) 												; shift A left
(2)  241/    962E : 02                  	ccl
(2)  242/    962F : F2 01               	add 	1(p2)
(2)  243/    9631 : CA 01               	st 		1(p2)
(2)  244/    9633 : 90 E6               	jmp 	EEX_MultiplyLoop
(2)  245/    9635 :                     
(2)  246/    9635 :                     ; ****************************************************************************************************************
(2)  247/    9635 :                     ;											Check next operation
(2)  248/    9635 :                     ; ****************************************************************************************************************
(2)  249/    9635 :                     
(2)  250/    9635 :                     EEX_CheckNextOperation:
(2)  251/    9635 : C5 01               	ld 		@1(p1)												; skip over spaces
(2)  252/    9637 : E4 20               	xri 	' '
(2)  253/    9639 : 98 FA               	jz 		EEX_CheckNextOperation
(2)  254/    963B : C5 FF               	ld 		@-1(p1)												; get operator
(2)  255/    963D : E4 2B               	xri 	'+'													; check if + - * /
(2)  256/    963F : 98 0C               	jz 		EEX_FoundOperator
(2)  257/    9641 : E4 06               	xri 	'+'!'-'
(2)  258/    9643 : 98 08               	jz 		EEX_FoundOperator
(2)  259/    9645 : E4 07               	xri 	'-'!'*'
(2)  260/    9647 : 98 04               	jz 		EEX_FoundOperator
(2)  261/    9649 : E4 05               	xri 	'*'!'/'
(2)  262/    964B : 9C BC               	jnz 	EEX_EndExpression
(2)  263/    964D :                     
(2)  264/    964D :                     EEX_FoundOperator:
(2)  265/    964D : C5 01               	ld  	@1(p1) 												; get and skip operator
(2)  266/    964F : CA 01               	st 		EEX_PendingOp(p2)									; save then pending operator
(2)  267/    9651 : (MACRO)             	lpi 	p3,EEX_Term-1
(2)  267/    9651 : C4 95                       ldi     (EEX_TERM-1) / 256
(2)  267/    9653 : 37                          xpah    P3
(2)  267/    9654 : C4 54                       ldi     (EEX_TERM-1) & 255
(2)  267/    9656 : 33                          xpal    P3
(2)  268/    9657 : 3F                  	xppc 	p3
(2)  269/    9658 :                     
(2)  270/    9658 :                     ; ****************************************************************************************************************
(2)  271/    9658 :                     ;											 Divide Right Term into Value
(2)  272/    9658 :                     ; ****************************************************************************************************************
(2)  273/    9658 :                     
(2)  274/    9658 :                     EEX_Divide:
(2)  275/    9658 : 40                  	lde 														; if denominator zero, error 2.
(2)  276/    9659 : 98 AA               	jz 		EEX_Divide_Zero
(2)  277/    965B : C2 00               	ld 		0(p2) 												; numerator into 1(p2)
(2)  278/    965D : CA 01               	st 		1(p2) 												; denominator is in E
(2)  279/    965F : C4 00               	ldi 	0
(2)  280/    9661 : CA 00               	st 		0(p2)												; quotient in 0(p2)
(2)  281/    9663 : CA FF               	st 		-1(p2) 												; remainder in -1(p2)
(2)  282/    9665 : C4 80               	ldi 	0x80 									
(2)  283/    9667 : CA FE               	st 		-2(p2) 												; bit in -2(p2)
(2)  284/    9669 :                     
(2)  285/    9669 :                     EEX_Divide_Loop:
(2)  286/    9669 : C2 FE               	ld 		-2(p2) 												; exit if bit = 0,we've finished.
(2)  287/    966B : 98 C8               	jz 		EEX_CheckNextOperation
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 29 - 1/11/2016 13:50:19


(2)  288/    966D :                     
(2)  289/    966D : 02                  	ccl 	 													; shift remainder left.
(2)  290/    966E : C2 FF               	ld 		-1(p2)
(2)  291/    9670 : F2 FF               	add 	-1(p2)
(2)  292/    9672 : CA FF               	st 		-1(p2)
(2)  293/    9674 :                     
(2)  294/    9674 : C2 01               	ld 		1(p2)												; get numerator.
(2)  295/    9676 : 94 02               	jp 		EEX_Divide_Numerator_Positive
(2)  296/    9678 : AA FF               	ild 	-1(p2)  											; if numerator -ve, increment remainder.
(2)  297/    967A :                     EEX_Divide_Numerator_Positive:
(2)  298/    967A :                     
(2)  299/    967A : C2 FF               	ld 		-1(p2) 												; calculate remainder - denominator
(2)  300/    967C : 03                  	scl
(2)  301/    967D : 78                  	cae 
(2)  302/    967E : CA FD               	st 		-3(p2) 												; save in temp -3(p2)
(2)  303/    9680 : 06                  	csa 														; if temp >= 0, CY/L is set
(2)  304/    9681 : 94 0A               	jp 		EEX_Divide_Temp_Positive
(2)  305/    9683 :                     
(2)  306/    9683 : C2 FD               	ld 		-3(p2) 												; copy temp to remainder
(2)  307/    9685 : CA FF               	st 		-1(p2)
(2)  308/    9687 : C2 FE               	ld 		-2(p2) 												; or bit into quotient
(2)  309/    9689 : DA 00               	or 		0(p2)
(2)  310/    968B : CA 00               	st 		0(p2)
(2)  311/    968D :                     EEX_Divide_Temp_Positive:
(2)  312/    968D : C2 FE               	ld 		-2(p2) 												; shift bit right
(2)  313/    968F : 1C                  	sr
(2)  314/    9690 : CA FE               	st 		-2(p2)
(2)  315/    9692 :                     
(2)  316/    9692 : C2 01               	ld 		1(p2)												; shift numerator positive
(2)  317/    9694 : 02                  	ccl
(2)  318/    9695 : F2 01               	add 	1(p2)
(2)  319/    9697 : CA 01               	st 		1(p2)
(2)  320/    9699 : 90 CE               	jmp 	EEX_Divide_Loop
(2)  321/    969B :                     
(2)  322/    969B :                     ; ****************************************************************************************************************
(2)  323/    969B :                     ; ****************************************************************************************************************
(2)  324/    969B :                     ;
(2)  325/    969B :                     ;	Evaluate an address pair at P1 e.g. (<expr>,<expr>).  Returns as for expression, but stack-2, stack-1 are
(2)  326/    969B :                     ;	the address (the data at that address is in E if no error occurs). Used for reading and writing.
(2)  327/    969B :                     ;
(2)  328/    969B :                     ; ****************************************************************************************************************
(2)  329/    969B :                     ; ****************************************************************************************************************
(2)  330/    969B :                     
(2)  331/    969B :                     EvaluateAddressPair:
(2)  332/    969B : C6 FE               	ld 		@-2(p2)												; make space to store HL
(2)  333/    969D : (MACRO)             	pushp 	p3 													; save return address.
(2)  333/    969D : 37                          xpah    P3
(2)  333/    969E : CE FF                       st              @-1(p2)
(2)  333/    96A0 : 33                          xpal    P3
(2)  333/    96A1 : CE FF                       st              @-1(p2)
(2)  334/    96A3 : C1 00               	ld 		(p1) 												; check first is '(', exit with term error if not
(2)  335/    96A5 : E4 28               	xri 	'('
(2)  336/    96A7 : 9C 2E               	jnz 	EAP_Error
(2)  337/    96A9 : C5 01               	ld 		@1(p1)												; skip over it.
(2)  338/    96AB : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; evaluate H
(2)  338/    96AB : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)  338/    96AD : 37                          xpah    P3
(2)  338/    96AE : C4 46                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)  338/    96B0 : 33                          xpal    P3
(2)  339/    96B1 : 3F                  	xppc 	p3
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 30 - 1/11/2016 13:50:19


(2)  340/    96B2 : 94 27               	jp 		EAP_Exit 											; exit if failed
(2)  341/    96B4 : 40                  	lde 														; store H at 3(P2)
(2)  342/    96B5 : CA 03               	st 		3(p2)
(2)  343/    96B7 : C1 00               	ld 		(p1) 												; check for ','
(2)  344/    96B9 : E4 2C               	xri 	','
(2)  345/    96BB : 9C 1A               	jnz 	EAP_Error											; fail if not present
(2)  346/    96BD : C5 01               	ld 		@1(p1)												; skip over comma
(2)  347/    96BF : 3F                  	xppc 	p3 													; evaluate L
(2)  348/    96C0 : 94 19               	jp 		EAP_Exit 											; exit on error
(2)  349/    96C2 : 40                  	lde 														; store L at 2(P2)
(2)  350/    96C3 : CA 02               	st 		2(p2)
(2)  351/    96C5 : 33                  	xpal 	p3 													; and put in P3.L for later
(2)  352/    96C6 : C1 00               	ld 		(p1) 												; check for ')'
(2)  353/    96C8 : E4 29               	xri 	')'
(2)  354/    96CA : 9C 0B               	jnz 	EAP_Error
(2)  355/    96CC : C5 01               	ld 		@1(p1) 												; skip over close bracket
(2)  356/    96CE : C2 03               	ld 		3(p2) 												; put 3(P2) in P3.H
(2)  357/    96D0 : 37                  	xpah 	p3
(2)  358/    96D1 : C3 00               	ld 		(p3) 												; read address
(2)  359/    96D3 : 01                  	xae 														; put in E
(2)  360/    96D4 : 03                  	scl 														; set carry to indicate okay
(2)  361/    96D5 : 90 04               	jmp 	EAP_Exit 											; and exit.
(2)  362/    96D7 :                     ;
(2)  363/    96D7 :                     EAP_Error:
(2)  364/    96D7 : C4 04               	ldi 	ERRC_TERM 											; set error up
(2)  365/    96D9 : 01                  	xae
(2)  366/    96DA : 02                  	ccl
(2)  367/    96DB :                     ;
(2)  368/    96DB :                     EAP_Exit:														; exit
(2)  369/    96DB : (MACRO)             	pullp 	p3 													; restore P3
(2)  369/    96DB : C6 01                       ld              @1(p2)
(2)  369/    96DD : 33                          xpal    P3
(2)  369/    96DE : C6 01                       ld              @1(p2)
(2)  369/    96E0 : 37                          xpah    P3
(2)  370/    96E1 : C6 02               	ld 		@2(p2) 												; drop the H L address store
(2)  371/    96E3 : 06                  	csa 														; A bit 7 = CY/L
(2)  372/    96E4 : 3F                  	xppc 	p3
(2)  373/    96E5 :                     
(2)  374/    96E5 :                     
(1)  144/    96E5 :                     
(1)  145/    96E5 :                     ; ****************************************************************************************************************
(1)  146/    96E5 :                     ;		Command look up table - should be ordered by degree of usage, and OS things (e.g. LIST) at the end
(1)  147/    96E5 :                     ; ****************************************************************************************************************
(1)  148/    96E5 :                     
(1)  149/    96E5 :                     CommandList:
(1)  150/    96E5 : (MACRO)             	cmd 	'L','E',3,CMD_Let 									; LET var|(h,l) = <expr>
(1)  150/    96E5 : 4C 45                       db              'L','E'                                                                                           ; first and second characters
(1)  150/    96E7 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  150/    96E8 : FE 93                       dw              (CMD_LET)-1                                                                                        ; execution point for prefetch.
(1)  151/    96EA : (MACRO)             	cmd 	'I','F',2,CMD_If 									; If [expr][=|#|<][expr]; [statement]
(1)  151/    96EA : 49 46                       db              'I','F'                                                                                           ; first and second characters
(1)  151/    96EC : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  151/    96ED : 51 94                       dw              (CMD_IF)-1                                                                                        ; execution point for prefetch.
(1)  152/    96EF : (MACRO)             	cmd 	'G','O',4,CMD_Goto									; GOTO [line number]
(1)  152/    96EF : 47 4F                       db              'G','O'                                                                                           ; first and second characters
(1)  152/    96F1 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  152/    96F2 : A0 94                       dw              (CMD_GOTO)-1                                                                                        ; execution point for prefetch.
(1)  153/    96F4 : (MACRO)             	cmd 	'C','A',4,CMD_Call									; CALL (high,low)
(1)  153/    96F4 : 43 41                       db              'C','A'                                                                                           ; first and second characters
(1)  153/    96F6 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 31 - 1/11/2016 13:50:19


(1)  153/    96F7 : D5 93                       dw              (CMD_CALL)-1                                                                                        ; execution point for prefetch.
(1)  154/    96F9 : (MACRO)             	cmd 	'P','R',2,CMD_Print 								; PRINT ["<text>"|<expr>|$(h,l)][,....][;]
(1)  154/    96F9 : 50 52                       db              'P','R'                                                                                           ; first and second characters
(1)  154/    96FB : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  154/    96FC : 52 93                       dw              (CMD_PRINT)-1                                                                                        ; execution point for prefetch.
(1)  155/    96FE : (MACRO)             	cmd 	'C','L',5,CMD_Clear									; CLEAR
(1)  155/    96FE : 43 4C                       db              'C','L'                                                                                           ; first and second characters
(1)  155/    9700 : 04                          db              (5)-1                                                                                      ; 5 -1 (first char already skipped)
(1)  155/    9701 : 3D 93                       dw              (CMD_CLEAR)-1                                                                                        ; execution point for prefetch.
(1)  156/    9703 : (MACRO)             	cmd 	'E','N',3,CMD_End 									; END
(1)  156/    9703 : 45 4E                       db              'E','N'                                                                                           ; first and second characters
(1)  156/    9705 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  156/    9706 : 37 93                       dw              (CMD_END)-1                                                                                        ; execution point for prefetch.
(1)  157/    9708 : (MACRO)             	cmd 	'N','E',3,CMD_New 									; NEW
(1)  157/    9708 : 4E 45                       db              'N','E'                                                                                           ; first and second characters
(1)  157/    970A : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  157/    970B : 2D 93                       dw              (CMD_NEW)-1                                                                                        ; execution point for prefetch.
(1)  158/    970D : (MACRO)             	cmd 	'R','U',3,CMD_Run									; RUN
(1)  158/    970D : 52 55                       db              'R','U'                                                                                           ; first and second characters
(1)  158/    970F : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  158/    9710 : C1 94                       dw              (CMD_RUN)-1                                                                                        ; execution point for prefetch.
(1)  159/    9712 : (MACRO)             	cmd 	'L','I',4,CMD_List 									; LIST
(1)  159/    9712 : 4C 49                       db              'L','I'                                                                                           ; first and second characters
(1)  159/    9714 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  159/    9715 : ED 92                       dw              (CMD_LIST)-1                                                                                        ; execution point for prefetch.
(1)  160/    9717 : (MACRO)             	cmd 	'O','S',2,CMD_OS 									; OS
(1)  160/    9717 : 4F 53                       db              'O','S'                                                                                           ; first and second characters
(1)  160/    9719 : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  160/    971A : E4 92                       dw              (CMD_OS)-1                                                                                        ; execution point for prefetch.
(1)  161/    971C : 00                  	db 		0
(1)  162/    971D :                     
(1)  163/    971D :                     ; Done:	GOTO, RUN, CLEAR, NEW, END, OS, CALL, LET (and optional version),IF, LIST
(1)  164/    971D :                     ; Not Done: PR,IN
      66/    971D :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 32 - 1/11/2016 13:50:19


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
 BOOTMONITOR :                  210 - | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CCA_OVER :                    93FD C |
 CCL_LOOP :                    9348 C |  CCL_OVER :                    9351 C |
 CHECKLASTCOMMANDTHENEXECUTE : 94D7 C |  CIF_CONTINUE :                9469 C |
 CIF_EQUALITY :                9485 C |  CIF_EQUALITY2 :               948C C |
 CIF_OVER :                    949F C |  CIF_SYNTAX :                  9463 C |
 CIF_TESTIFZERO :              9492 C |  CLE_EVALUATEANDWRITE :        9430 C |
 CLE_ISHL :                    9425 C |  CLE_OVER :                    9450 C |
 CLE_SINGLEVARIABLE :          9416 C |  CLE_SYNTAX :                  9410 C |
 CLI_END :                     9326 C |  CLI_ENDLINE :                 9312 C |
 CLI_LINE :                    930B C |  CLI_LOOP :                    92F8 C |
 CLI_OVER :                    932C C |  CMD_CALL :                    93D6 C |
 CMD_CLEAR :                   933E C |  CMD_END :                     9338 C |
 CMD_GOTO :                    94A1 C |  CMD_IF :                      9452 C |
 CMD_LET :                     93FF C |  CMD_LIST :                    92EE C |
 CMD_NEW :                     932E C |  CMD_OS :                      92E5 C |
 CMD_PRINT :                   9353 C |  CMD_RUN :                     94C2 C |
 CNE_OVER :                    933C C |  COMMANDLIST :                 96E5 C |
*CONSTPI :        3.141592653589793 - |  COS_OVER :                    92EC C |
 CPR_ENDOK :                   93D3 C |  CPR_ENDRETURN :               93D0 C |
 CPR_OVER :                    93D4 C |  CPR_OVER2 :                   93CE C |
 CPR_QUOTEDSTRING :            9391 C |  CPR_STRINGATADDRESS :         939E C |
 CPR_STRINGEXIT :              93BD C |  CPR_STRINGLOOP :              93B7 C |
 CPR_STRINGPRINT :             93C5 C |  CPR_SYNTAX :                  93CA C |
 CRG_EXECUTEFROMP1 :           94C8 C |  CRG_FIND :                    94AD C |
 CRG_NOTEND :                  94B7 C |  CRG_OVER :                    94CA C |
 CURRENTLINE :                  C8D - | *DATE :                   1/11/2016 - |
 EAFD_LETCODE :                953C C |  EAFD_SEARCH :                 950C C |
 EAFD_SKIP :                   951D C |  EAFD_SKIPSPACES :             9529 C |
 EAP_ERROR :                   96D7 C |  EAP_EXIT :                    96DB C |
 EEX_CHECKNEXTOPERATION :      9635 C |  EEX_CONSTANT :                95CB C |
 EEX_CONSTANTLOOP :            95CC C |  EEX_DIVIDE :                  9658 C |
 EEX_DIVIDE_LOOP :             9669 C |
 EEX_DIVIDE_NUMERATOR_POSITIVE :                                       967A C |
 EEX_DIVIDE_TEMP_POSITIVE :    968D C |  EEX_DIVIDE_ZERO :             9605 C |
 EEX_ENDEXPRESSION :           9609 C |  EEX_ERROR :                   95B0 C |
 EEX_EXIT :                    95B2 C |  EEX_FOUNDOPERATOR :           964D C |
 EEX_HAVETERM :                95ED C |  EEX_MEMORYACCESS :            95BE C |
 EEX_MULTIPLYLOOP :            961B C |  EEX_MULTIPLY_B0ISZERO :       9629 C |
 EEX_NEXTCHAR :                955B C |  EEX_NOTADD :                  95F9 C |
 EEX_NOTAP :                   9586 C |  EEX_NOTQUOTE :                959B C |
 EEX_NOTRANDOM :               9588 C |  EEX_NOTSUBTRACT :             960F C |
 EEX_PENDINGOP :                  1 - | *EEX_RANDOM :                  956D C |
 EEX_SAVEANDEXIT :             9601 C |  EEX_TERM :                    9555 C |
 EEX_TERMERROR :               95AE C |  EEX_VALUE :                      0 - |
 EEX_VARIABLE :                95E9 C | *ENDOFCOMMANDEXECUTION :       94CA C |
 ERRC_DIVZERO :                   7 - |  ERRC_END :                      FF - |
 ERRC_LABEL :                     1 - | *ERRC_MEMORY :                    6 - |
 ERRC_SYNTAX :                    5 - |  ERRC_TERM :                      4 - |
*ERRC_UNKNOWN :                   2 - |  EVALUATEADDRESSPAIR :         969B C |
 EVALUATEEXPRESSION :          9547 C |  EXECUTEFROMADDRESSDIRECT :    94F3 C |
 EXECUTEFROMCOMMANDSTART :     94E7 C |  EXECUTENEXTINSTRUCTION :      94CD C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
 GETCHAR :                     9257 C |  GETSTRING :                   927B C |
 GOTOCOMMANDLINE :             94DF C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 33 - 1/11/2016 13:50:19


*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*LISTON :                         1 - | *MACEXP :                         1 - |
*MOMCPU :                         C - | *MOMCPUNAME :                 SC/MP - |
*NESTMAX :                      100 - | *OSMATHLIBRARY :                  3 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PRINT :                       9197 C |  PRINTINTEGER :                913B C |
 PROGRAMBASE :                 901F C |  RANDOMSEED :                   C8E - |
*RELAXED :                        0 - |  SCREENCURSOR :                 C80 - |
 SCREENMIRROR :                 C00 - |  SYNTAXERROR :                 94E1 C |
 SYSTEMMEMORY :                 C90 - | *TIME :                    13:50:19 - |
*TRUE :                           1 - |  VARIABLES :                    C90 - |
*VERSION :                     142F - |  WAIT1 :                       901D C |
 __GCNOTLOWER [GETCHAR] :      9276 C |  __GCWAITKEY [GETCHAR] :       925C C |
 __GCWAITRELEASE [GETCHAR] :   9264 C |  __GSBACKSPACE [GETSTRING] :   92D6 C |
 __GSCONTROLKEY [GETSTRING] :  92B9 C |  __GSLOOP [GETSTRING] :        9289 C |
 __PIDIVIDEEND :               916C C |  __PIDIVIDELOOP :              914F C |
 __PIDIVIDEOUTER :             9149 C |  __PIEXIT :                    918E C |
 __PIPRINT :                   9181 C |  __PRCLEARFROMMOVETO [PRINT] : 9237 C |
 __PRCLEARLOOP [PRINT] :       9239 C |  __PRCLEARSCREEN [PRINT] :     9235 C |
 __PRCOPY [PRINT] :            9243 C |  __PREXIT [PRINT] :            91FA C |
 __PREXITNOCHECK [PRINT] :     91FE C |  __PRISCONTROLCHAR [PRINT] :   920C C |
 __PRISRETURN [PRINT] :        922C C |  __PRNOTASCII [PRINT] :        91D4 C |
 __PRPRINTCHARACTERA [PRINT] : 91B8 C |  __PRPRINTSTRING [PRINT] :     91A6 C |
 __PRSCROLLLOOP [PRINT] :      91EC C |  __PRUPDATECURSOR [PRINT] :    91DD C |

    164 symbols
     33 unused symbols

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 34 - 1/11/2016 13:50:19


  defined macros:
  ---------------

CMD                                   | CODE                                 
LPI                                   | PULLA                                
PULLE                                 | PULLP                                
PUSHA                                 | PUSHE                                
PUSHP                                 | SETV                                 

     10 macros

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 35 - 1/11/2016 13:50:19


  codepages:
  ----------

STANDARD (0 changed characters)


0.02 seconds assembly time

   1538 lines source file
   1798 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
