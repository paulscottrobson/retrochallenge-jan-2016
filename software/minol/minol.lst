 AS V1.42 Beta [Bld 102] - source file minol.asm - page 1 - 1/10/2016 11:47:39


       1/       0 :                     ; ****************************************************************************************************************
       2/       0 :                     ; ****************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;												Minol ROM Image
       5/       0 :                     ;
       6/       0 :                     ; ****************************************************************************************************************
       7/       0 :                     ; ****************************************************************************************************************
       8/       0 :                     
       9/       0 :                     	cpu 	sc/mp
      10/       0 :                     
      11/       0 :                     	include source\memorymacros.asm 							; Memory allocation and Macro definition.	
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;										Memory and Macro Allocation.
(1)    5/       0 :                     ;	
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0x3                OSMathLibrary = 0x0003 											; the Maths library is here.
(1)   10/       0 : =0x210              BootMonitor = 0x210 											; address to boot monitor
(1)   11/       0 :                     
(1)   12/       0 :                     ; ****************************************************************************************************************
(1)   13/       0 :                     ;												 Memory Allocation
(1)   14/       0 :                     ; ****************************************************************************************************************
(1)   15/       0 :                     
(1)   16/       0 : =0xC00              ScreenMirror = 0xC00 											; Screen mirror, 128 bytes, 256 byte page boundary.
(1)   17/       0 : =0xC80              ScreenCursor = ScreenMirror+0x80  								; Position on that screen (00..7F)
(1)   18/       0 :                     
(1)   19/       0 : =0xC90              SystemMemory = 0xC90 											; System Memory
(1)   20/       0 :                     
(1)   21/       0 : =0xC8E              RandomSeed = SystemMemory-2										; Random Seed Value (2 bytes)
(1)   22/       0 : =0xC8D              CurrentLine = SystemMemory-3 									; Current Line Number (1 byte)
(1)   23/       0 : =0xC90              Variables = SystemMemory 										; Variables (26 bytes)
(1)   24/       0 :                     
(1)   25/       0 :                     ; ****************************************************************************************************************
(1)   26/       0 :                     ;														Macros
(1)   27/       0 :                     ; ****************************************************************************************************************
(1)   28/       0 :                     
(1)   29/       0 :                     lpi	macro	ptr,addr											; load pointer register with constant
(1)   30/       0 :                     	ldi 	(addr) / 256
(1)   31/       0 :                     	xpah 	ptr
(1)   32/       0 :                     	ldi 	(addr) & 255
(1)   33/       0 :                     	xpal 	ptr
(1)   34/       0 :                     	endm
(1)   35/       0 :                     
(1)   36/       0 :                     pushp macro ptr 												; push pointer register on stack
(1)   37/       0 :                     	xpah 	ptr
(1)   38/       0 :                     	st 		@-1(p2)
(1)   39/       0 :                     	xpal 	ptr
(1)   40/       0 :                     	st 		@-1(p2)
(1)   41/       0 :                     	endm
(1)   42/       0 :                     
(1)   43/       0 :                     pullp macro ptr 												; pull pointer register off stack
(1)   44/       0 :                     	ld 		@1(p2)
(1)   45/       0 :                     	xpal 	ptr
(1)   46/       0 :                     	ld 		@1(p2)
(1)   47/       0 :                     	xpah 	ptr
(1)   48/       0 :                     	endm
(1)   49/       0 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(memorymacros.asm) - page 2 - 1/10/2016 11:47:39


(1)   50/       0 :                     pushe macro 													; push E on stack
(1)   51/       0 :                     	lde
(1)   52/       0 :                     	st 		@-1(p2)
(1)   53/       0 :                     	endm
(1)   54/       0 :                     
(1)   55/       0 :                     pulle macro 													; pull E off stack
(1)   56/       0 :                     	ld 		@1(p2)
(1)   57/       0 :                     	xae
(1)   58/       0 :                     	endm
(1)   59/       0 :                     
(1)   60/       0 :                     pusha macro 													; push A on stack
(1)   61/       0 :                     	st 		@-1(p2)
(1)   62/       0 :                     	endm
(1)   63/       0 :                     
(1)   64/       0 :                     pulla macro
(1)   65/       0 :                     	ld 		@1(p2)
(1)   66/       0 :                     	endm
(1)   67/       0 :                     
(1)   68/       0 :                     setv macro ch,value 											; sets a variable to a value, assumes P3 = Variables.
(1)   69/       0 :                     	ldi 	(value) & 255
(1)   70/       0 :                     	st 		((ch) - 'A')(p3)
(1)   71/       0 :                     	endm
(1)   72/       0 :                     
(1)   73/       0 :                     code macro lineNo,code 											; a debugging macro, which fakes up a line of code.
(1)   74/       0 :                     	db 		strlen(code)+3 										; one byte offset to next (255 = End of code)
(1)   75/       0 :                     	db 		lineNo 												; one byte line number 
(1)   76/       0 :                     	db 		code,0 												; ASCIIZ string
(1)   77/       0 :                     	endm
(1)   78/       0 :                     
(1)   79/       0 :                     cmd macro 	c1,c2,length,code
(1)   80/       0 :                     	db 		c1,c2 												; first and second characters
(1)   81/       0 :                     	db 		(length)-1											; length -1 (first char already skipped)
(1)   82/       0 :                     	dw 		(code)-1 											; execution point for prefetch.
(1)   83/       0 :                     	endm
      12/       0 :                     	include source\errors.asm 									; Error Codes
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;												Error Codes
(1)    5/       0 :                     ;
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0xFF               ERRC_END = 0xFF													; psuedo error, program stopped. Does "OK" as for no error.
(1)   10/       0 : =0x1                ERRC_LABEL = 1 													; Label does not exist (e.g. GOTO)
(1)   11/       0 : =0x2                ERRC_UNKNOWN = 2												; Unknown instruction
(1)   12/       0 : =0x4                ERRC_TERM = 4 													; Illegal term/expression
(1)   13/       0 : =0x5                ERRC_SYNTAX = 5													; Syntax Error
(1)   14/       0 : =0x6                ERRC_MEMORY = 6 												; Out of memory
(1)   15/       0 : =0x7                ERRC_DIVZERO = 7 												; Division by Zero Error.
(1)   16/       0 :                     
      13/       0 :                     
      14/       0 :                     ; ****************************************************************************************************************
      15/       0 :                     ; ****************************************************************************************************************
      16/       0 :                     ; 	NOTE: When executing line follow the line with $FF so it thinks it has reached the program end.
      17/       0 :                     ; ****************************************************************************************************************
      18/       0 :                     ; ****************************************************************************************************************
      19/       0 :                     
      20/       0 :                     
      21/       0 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 3 - 1/10/2016 11:47:39


      22/       0 :                     ;													Main Program
      23/       0 :                     ; ****************************************************************************************************************
      24/       0 :                     
      25/    9000 :                     	org 	0x9000 												; the ROM starts here
      26/    9000 :                     
      27/    9000 : 68                  	db 		0x68												; this makes it boot straight into this ROM.
      28/    9001 : (MACRO)             	lpi 	p2,0xFF8											; set up stack default value
      28/    9001 : C4 0F                       ldi     (0XFF8) / 256
      28/    9003 : 36                          xpah    P2
      28/    9004 : C4 F8                       ldi     (0XFF8) & 255
      28/    9006 : 32                          xpal    P2
      29/    9007 : (MACRO)             	lpi 	p3,SystemMemory
      29/    9007 : C4 0C                       ldi     (SYSTEMMEMORY) / 256
      29/    9009 : 37                          xpah    P3
      29/    900A : C4 90                       ldi     (SYSTEMMEMORY) & 255
      29/    900C : 33                          xpal    P3
      30/    900D :                     
      31/    900D : (MACRO)             	lpi 	p3,CMD_Run-1
      31/    900D : C4 93                       ldi     (CMD_RUN-1) / 256
      31/    900F : 37                          xpah    P3
      31/    9010 : C4 FD                       ldi     (CMD_RUN-1) & 255
      31/    9012 : 33                          xpal    P3
      32/    9013 : 3F                  	xppc	p3
      33/    9014 :                     
      34/    9014 :                     wait1:	
      35/    9014 : 90 FE               	jmp 	wait1
      36/    9016 :                     
      37/    9016 :                     
      38/    9016 :                     ProgramBase:
      39/    9016 : (MACRO)             	code 	1,"\"START\":CLEAR:GOTO 140"
      39/    9016 : 19                          db              strlen("\"START\":CLEAR:GOTO 140")+3                                                                          ; one byte offset to next (255 = End of "\"START\":CLEAR:GOTO 140")
      39/    9017 : 01                          db              1                                                                                          ; one byte line number 
      39/    9018 : 22 53 54 41 52 54           db              "\"START\":CLEAR:GOTO 140",0                                                                                          ; ASCIIZ string
                    22 3A 43 4C 45 41 
                    52 3A 47 4F 54 4F 
                    20 31 34 30 00 
      40/    902F : (MACRO)             	code 	10,"HELLO WORLD"
      40/    902F : 0E                          db              strlen("HELLO WORLD")+3                                                                          ; one byte offset to next (255 = End of "HELLO WORLD")
      40/    9030 : 0A                          db              10                                                                                          ; one byte line number 
      40/    9031 : 48 45 4C 4C 4F 20           db              "HELLO WORLD",0                                                                                          ; ASCIIZ string
                    57 4F 52 4C 44 00 
      41/    903D : (MACRO)             	code 	20,"GOTO 20"
      41/    903D : 0A                          db              strlen("GOTO 20")+3                                                                          ; one byte offset to next (255 = End of "GOTO 20")
      41/    903E : 14                          db              20                                                                                          ; one byte line number 
      41/    903F : 47 4F 54 4F 20 32           db              "GOTO 20",0                                                                                          ; ASCIIZ string
                    30 00 
      42/    9047 : (MACRO)             	code 	30,"LET B = 69:LET A = 42:C = A + B:END"
      42/    9047 : 26                          db              strlen("LET B = 69:LET A = 42:C = A + B:END")+3                                                                          ; one byte offset to next (255 = End of "LET B = 69:LET A = 42:C = A 
      42/    9048 : 1E                          db              30                                                                                          ; one byte line number 
      42/    9049 : 4C 45 54 20 42 20           db              "LET B = 69:LET A = 42:C = A + B:END",0                                                                                          ; ASCIIZ string
                    3D 20 36 39 3A 4C 
                    45 54 20 41 20 3D 
                    20 34 32 3A 43 20 
                    3D 20 41 20 2B 20 
                    42 3A 45 4E 44 00 
      43/    906D : (MACRO)             	code 	120,"D = D + 1:(0,4) = D:(12,130) = 69:GOTO 120"
      43/    906D : 2D                          db              strlen("D = D + 1:(0,4) = D:(12,130) = 69:GOTO 120")+3                                                                          ; one byte offset to next (255 = End of "D = D + 1:(0,4) = D:(
      43/    906E : 78                          db              120                                                                                          ; one byte line number 
      43/    906F : 44 20 3D 20 44 20           db              "D = D + 1:(0,4) = D:(12,130) = 69:GOTO 120",0                                                                                          ; ASCIIZ string
                    2B 20 31 3A 28 30 
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 4 - 1/10/2016 11:47:39


                    2C 34 29 20 3D 20 
                    44 3A 28 31 32 2C 
                    31 33 30 29 20 3D 
                    20 36 39 3A 47 4F 
                    54 4F 20 31 32 30 
                    00 
      44/    909A : (MACRO)             	code 	130,"A=!:B='@':C=42:D=0-1:GOTO 130"
      44/    909A : 20                          db              strlen("A=!:B='@':C=42:D=0-1:GOTO 130")+3                                                                          ; one byte offset to next (255 = End of "A=!:B='@':C=42:D=0-1:GOTO 130")
      44/    909B : 82                          db              130                                                                                          ; one byte line number 
      44/    909C : 41 3D 21 3A 42 3D           db              "A=!:B='@':C=42:D=0-1:GOTO 130",0                                                                                          ; ASCIIZ string
                    27 40 27 3A 43 3D 
                    34 32 3A 44 3D 30 
                    2D 31 3A 47 4F 54 
                    4F 20 31 33 30 00 
      45/    90BA : (MACRO)             	code 	140,"IF 1 # 255 ; A = A + 1: B = B + 1"
      45/    90BA : 24                          db              strlen("IF 1 # 255 ; A = A + 1: B = B + 1")+3                                                                          ; one byte offset to next (255 = End of "IF 1 # 255 ; A = A + 1: B = B 
      45/    90BB : 8C                          db              140                                                                                          ; one byte line number 
      45/    90BC : 49 46 20 31 20 23           db              "IF 1 # 255 ; A = A + 1: B = B + 1",0                                                                                          ; ASCIIZ string
                    20 32 35 35 20 3B 
                    20 41 20 3D 20 41 
                    20 2B 20 31 3A 20 
                    42 20 3D 20 42 20 
                    2B 20 31 00 
      46/    90DE : (MACRO)             	code 	150,"IF 255 # 255 ; C = C + 1: D = D + 1"
      46/    90DE : 26                          db              strlen("IF 255 # 255 ; C = C + 1: D = D + 1")+3                                                                          ; one byte offset to next (255 = End of "IF 255 # 255 ; C = C + 1: D 
      46/    90DF : 96                          db              150                                                                                          ; one byte line number 
      46/    90E0 : 49 46 20 32 35 35           db              "IF 255 # 255 ; C = C + 1: D = D + 1",0                                                                                          ; ASCIIZ string
                    20 23 20 32 35 35 
                    20 3B 20 43 20 3D 
                    20 43 20 2B 20 31 
                    3A 20 44 20 3D 20 
                    44 20 2B 20 31 00 
      47/    9104 : (MACRO)             	code 	200,"LET A = 0"
      47/    9104 : 0C                          db              strlen("LET A = 0")+3                                                                          ; one byte offset to next (255 = End of "LET A = 0")
      47/    9105 : C8                          db              200                                                                                          ; one byte line number 
      47/    9106 : 4C 45 54 20 41 20           db              "LET A = 0",0                                                                                          ; ASCIIZ string
                    3D 20 30 00 
      48/    9110 : (MACRO)             	code 	210,"LET A = A+1:(0,A)=A:IF A#250; GOTO 210"
      48/    9110 : 29                          db              strlen("LET A = A+1:(0,A)=A:IF A#250; GOTO 210")+3                                                                          ; one byte offset to next (255 = End of "LET A = A+1:(0,A)=A:IF A#
      48/    9111 : D2                          db              210                                                                                          ; one byte line number 
      48/    9112 : 4C 45 54 20 41 20           db              "LET A = A+1:(0,A)=A:IF A#250; GOTO 210",0                                                                                          ; ASCIIZ string
                    3D 20 41 2B 31 3A 
                    28 30 2C 41 29 3D 
                    41 3A 49 46 20 41 
                    23 32 35 30 3B 20 
                    47 4F 54 4F 20 32 
                    31 30 00 
      49/    9139 : FF                  	db 		255
      50/    913A :                     
      51/    913A :                     
      52/    913A :                     ; ****************************************************************************************************************
      53/    913A :                     ;													Source Files
      54/    913A :                     ; ****************************************************************************************************************
      55/    913A :                     
      56/    913A :                     	include source\itoa.asm 									; print integer routine.
(1)    1/    913A :                     ; ****************************************************************************************************************
(1)    2/    913A :                     ; ****************************************************************************************************************
(1)    3/    913A :                     ;
(1)    4/    913A :                     ;											Integer (Byte) Printer
(1)    5/    913A :                     ;	
 AS V1.42 Beta [Bld 102] - source file minol.asm(itoa.asm) - page 5 - 1/10/2016 11:47:39


(1)    6/    913A :                     ;	Print Integer in E as String to output routine. Uses stack space as temporary storage. Changes A/E but not
(1)    7/    913A :                     ;	P1.
(1)    8/    913A :                     ;
(1)    9/    913A :                     ; ****************************************************************************************************************
(1)   10/    913A :                     ; ****************************************************************************************************************
(1)   11/    913A :                     
(1)   12/    913A :                     PrintInteger:
(1)   13/    913A : (MACRO)             	pushp 	p3													; save P3
(1)   13/    913A : 37                          xpah    P3
(1)   13/    913B : CE FF                       st              @-1(p2)
(1)   13/    913D : 33                          xpal    P3
(1)   13/    913E : CE FF                       st              @-1(p2)
(1)   14/    9140 : C4 FF               	ldi 	0xFF 												; use $FF to mark stack top.
(1)   15/    9142 : CE FF               	st 		@-1(p2)
(1)   16/    9144 : CE FD               	st 		@-3(p2) 											; allocate space for results.
(1)   17/    9146 : C4 64               	ldi 	100 												; start with 100s
(1)   18/    9148 :                     __PIDivideOuter:
(1)   19/    9148 : CA 01               	st 		1(p2) 												; save subtractor at stack (1)
(1)   20/    914A : C4 FF               	ldi 	0xFF 												; clear stack (0) (count) to -1 because we pre-increment.
(1)   21/    914C : CA 00               	st 		0(p2)
(1)   22/    914E :                     __PIDivideLoop:
(1)   23/    914E : AA 00               	ild 	0(p2) 												; bump the counter.
(1)   24/    9150 : 40                  	lde 														; get value
(1)   25/    9151 : 03                  	scl 														; subtract divider
(1)   26/    9152 : FA 01               	cad 	1(p2) 												
(1)   27/    9154 : 01                  	xae 														; put back in E
(1)   28/    9155 : 06                  	csa 														; if no borrow
(1)   29/    9156 : D4 80               	ani 	0x80
(1)   30/    9158 : 9C F4               	jnz 	__PIDivideLoop 
(1)   31/    915A : 40                  	lde 														; add the divider.
(1)   32/    915B : 02                  	ccl
(1)   33/    915C : F2 01               	add 	1(p2)
(1)   34/    915E : 01                  	xae
(1)   35/    915F : C2 01               	ld 		1(p2) 												; get the divider back
(1)   36/    9161 : E4 0A               	xri 	10 													; is it 10 ?
(1)   37/    9163 : 98 06               	jz 		__PIDivideEnd 										; we have finished the division bit.
(1)   38/    9165 : C6 01               	ld 		@1(p2) 												; push stack up one.
(1)   39/    9167 : C4 0A               	ldi 	10 													; and divide by 10
(1)   40/    9169 : 90 DD               	jmp 	__PIDivideOuter
(1)   41/    916B :                     ;
(1)   42/    916B :                     __PIDivideEnd:
(1)   43/    916B :                     
(1)   44/    916B : 40                  	lde 														; write out the last digit.
(1)   45/    916C : CA 01               	st 		1(p2)
(1)   46/    916E : (MACRO)             	lpi 	p3,Print-1 											; point P3 to the print routine.
(1)   46/    916E : C4 91                       ldi     (PRINT-1) / 256
(1)   46/    9170 : 37                          xpah    P3
(1)   46/    9171 : C4 95                       ldi     (PRINT-1) & 255
(1)   46/    9173 : 33                          xpal    P3
(1)   47/    9174 :                     ;
(1)   48/    9174 :                     ;	Remove leading spaces
(1)   49/    9174 :                     ;
(1)   50/    9174 : C6 FF               	ld 		@-1(p2) 											; look at first digit, if non-zero go to print
(1)   51/    9176 : 9C 08               	jnz 	__PIPrint 
(1)   52/    9178 : C6 01               	ld 		@1(p2) 												; skip it, eliminate trailing zeros.
(1)   53/    917A : C2 00               	ld 		(p2) 												; now look at second digit
(1)   54/    917C : 9C 02               	jnz 	__PIPrint 											; skip it, eliminate trailing zeros.
(1)   55/    917E : C6 01               	ld 		@1(p2)
(1)   56/    9180 :                     ;
(1)   57/    9180 :                     __PIPrint:
 AS V1.42 Beta [Bld 102] - source file minol.asm(itoa.asm) - page 6 - 1/10/2016 11:47:39


(1)   58/    9180 : C6 01               	ld 		@1(p2) 												; read digit
(1)   59/    9182 : D4 80               	ani 	0x80												; if found -ve value then exit.
(1)   60/    9184 : 9C 07               	jnz 	__PIExit
(1)   61/    9186 : C2 FF               	ld 		-1(p2) 												; re-read it.
(1)   62/    9188 : DC 30               	ori 	'0'													; make ASCII
(1)   63/    918A : 3F                  	xppc 	p3 													; print it
(1)   64/    918B : 90 F3               	jmp 	__PIPrint 											; and keep printing.
(1)   65/    918D :                     ;
(1)   66/    918D :                     __PIExit:
(1)   67/    918D : (MACRO)             	pullp 	p3 													; restore P3
(1)   67/    918D : C6 01                       ld              @1(p2)
(1)   67/    918F : 33                          xpal    P3
(1)   67/    9190 : C6 01                       ld              @1(p2)
(1)   67/    9192 : 37                          xpah    P3
(1)   68/    9193 : 3F                  	xppc 	p3 													; and exit
(1)   69/    9194 : 90 00               	jmp 	Print
      57/    9196 :                     	include source\screen.asm 									; screen I/O stuff.
(1)    1/    9196 :                     ; ****************************************************************************************************************
(1)    2/    9196 :                     ; ****************************************************************************************************************
(1)    3/    9196 :                     ;
(1)    4/    9196 :                     ;											Screen I/O, VTL-2 ROM
(1)    5/    9196 :                     ;											=====================
(1)    6/    9196 :                     ;
(1)    7/    9196 :                     ;	Provides Character and String Input/Output functionality.
(1)    8/    9196 :                     ;
(1)    9/    9196 :                     ; ****************************************************************************************************************
(1)   10/    9196 :                     ; ****************************************************************************************************************
(1)   11/    9196 :                     
(1)   12/    9196 :                     ; ****************************************************************************************************************
(1)   13/    9196 :                     ; ****************************************************************************************************************
(1)   14/    9196 :                     ;
(1)   15/    9196 :                     ;	Print routine. Prints either character in A, or ASCIIZ string at P1 (if A is zero). Preserves all registers
(1)   16/    9196 :                     ;	except if printing string, P1 points to the character after the NULL terminator.
(1)   17/    9196 :                     ;
(1)   18/    9196 :                     ;	Scrolls automatically. Understands character codes 32-255, 8 (Backspace) 12 (Clear Screen) 13 (Carriage
(1)   19/    9196 :                     ;	Return). Others are currently ignored (except 0, see above). Note L/C values (97....) display those characters
(1)   20/    9196 :                     ;	in the ROM font *not* lower case :)
(1)   21/    9196 :                     ;
(1)   22/    9196 :                     ; ****************************************************************************************************************
(1)   23/    9196 :                     ; ****************************************************************************************************************
(1)   24/    9196 :                     
(1)   25/    9196 :                     Print:
(1)   26/    9196 :                     	section 	Print
(1)   27/    9196 :                     
(1)   28/    9196 : (MACRO)             	pusha														; push registers on stack
(1)   28/    9196 : CE FF                       st              @-1(p2)
(1)   29/    9198 : (MACRO)             	pushp 	p1
(1)   29/    9198 : 35                          xpah    P1
(1)   29/    9199 : CE FF                       st              @-1(p2)
(1)   29/    919B : 31                          xpal    P1
(1)   29/    919C : CE FF                       st              @-1(p2)
(1)   30/    919E : (MACRO)             	pushe
(1)   30/    919E : 40                          lde
(1)   30/    919F : CE FF                       st              @-1(p2)
(1)   31/    91A1 :                     
(1)   32/    91A1 : C2 03               	ld 		3(p2) 												; read character 
(1)   33/    91A3 : 9C 12               	jnz 	__PRPrintCharacterA 								; if non zero print it on its own.
(1)   34/    91A5 :                     
(1)   35/    91A5 :                     __PRPrintString:
(1)   36/    91A5 : C2 01               	ld 		1(p2) 												; restore original P1
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 7 - 1/10/2016 11:47:39


(1)   37/    91A7 : 31                  	xpal 	p1
(1)   38/    91A8 : C2 02               	ld 		2(p2)
(1)   39/    91AA : 35                  	xpah 	p1 													; read character at P1.
(1)   40/    91AB : C5 01               	ld 		@1(p1)
(1)   41/    91AD : 01                  	xae 														; save in E.
(1)   42/    91AE : 35                  	xpah 	p1 													; write P1 back.
(1)   43/    91AF : CA 02               	st 		2(p2)
(1)   44/    91B1 : 31                  	xpal 	p1
(1)   45/    91B2 : CA 01               	st 		1(p2)
(1)   46/    91B4 : 40                  	lde 														; get character from E
(1)   47/    91B5 : 98 46               	jz 		__PRExitNoCheck 									; exit without loop check.
(1)   48/    91B7 :                     ;
(1)   49/    91B7 :                     ;	Print character in A now ; throughout it is stored in E.
(1)   50/    91B7 :                     ;
(1)   51/    91B7 :                     __PRPrintCharacterA:
(1)   52/    91B7 : 01                  	xae 														; save character in E.
(1)   53/    91B8 :                     ;
(1)   54/    91B8 :                     ;	Read cursor and set P1 to that address
(1)   55/    91B8 :                     ;
(1)   56/    91B8 : C4 0C               	ldi 	ScreenCursor/256 									; set P1 to point to screen cursor
(1)   57/    91BA : 35                  	xpah 	p1
(1)   58/    91BB : C4 80               	ldi 	ScreenCursor&255
(1)   59/    91BD : 31                  	xpal 	p1
(1)   60/    91BE : C1 00               	ld 		0(p1) 												; put cursor position in P1.L
(1)   61/    91C0 : 31                  	xpal 	p1
(1)   62/    91C1 :                     ;
(1)   63/    91C1 :                     ;	Check for control
(1)   64/    91C1 :                     ;
(1)   65/    91C1 : 40                  	lde 														; look at character
(1)   66/    91C2 : D4 E0               	ani 	0xE0 												; is it code 0-31
(1)   67/    91C4 : 98 45               	jz 		__PRIsControlChar
(1)   68/    91C6 :                     ;
(1)   69/    91C6 :                     ;	Print non-control
(1)   70/    91C6 :                     ;
(1)   71/    91C6 : 40                  	lde 														; read character
(1)   72/    91C7 : 03                  	scl 														; CY/L clear if < 96
(1)   73/    91C8 : FC 60               	cai 	96 
(1)   74/    91CA : 06                  	csa 	 	 												; skip if carry set
(1)   75/    91CB : E4 80               	xri 	0x80													
(1)   76/    91CD : 94 04               	jp 		__PRNotASCII
(1)   77/    91CF : 40                  	lde 														; if ASCII make 6 bit.
(1)   78/    91D0 : D4 3F               	ani 	0x3F
(1)   79/    91D2 : 01                  	xae
(1)   80/    91D3 :                     __PRNotASCII:
(1)   81/    91D3 : 40                  	lde 														; get character.
(1)   82/    91D4 : C9 00               	st 		(p1) 												; save in shadow memory
(1)   83/    91D6 : 35                  	xpah 	p1 													; switch to VRAM, preserving A.
(1)   84/    91D7 : C4 00               	ldi 	0 													
(1)   85/    91D9 : 35                  	xpah 	p1
(1)   86/    91DA : CD 01               	st 		@1(p1) 												; save in screen memory, advance write position.
(1)   87/    91DC :                     ;
(1)   88/    91DC :                     ;	Write cursor position back from P1.L
(1)   89/    91DC :                     ;
(1)   90/    91DC :                     __PRUpdateCursor:
(1)   91/    91DC : C4 0C               	ldi		ScreenCursor / 256 									; set P1 to point to screen cursor, restore position to P1
(1)   92/    91DE : 35                  	xpah 	p1
(1)   93/    91DF : C4 80               	ldi 	ScreenCursor & 255 
(1)   94/    91E1 : 31                  	xpal 	p1 													; after this, adjusted cursor position is in AC.
(1)   95/    91E2 : C9 00               	st 		(p1) 												; write back in cursor position
(1)   96/    91E4 : 94 13               	jp 		__PRExit 											; if position is off the bottom then scroll.
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 8 - 1/10/2016 11:47:39


(1)   97/    91E6 :                     ;
(1)   98/    91E6 :                     ;	Scroll display
(1)   99/    91E6 :                     ;
(1)  100/    91E6 : C4 0C               	ldi 	(ScreenMirror+16) / 256 							; point P1 to 2nd line.
(1)  101/    91E8 : 35                  	xpah 	p1
(1)  102/    91E9 : C4 10               	ldi 	(ScreenMirror+16) & 255
(1)  103/    91EB :                     __PRScrollLoop:
(1)  104/    91EB : 31                  	xpal 	p1
(1)  105/    91EC : C1 00               	ld 		0(p1) 												; copy char to previous line
(1)  106/    91EE : C9 F0               	st 		-16(p1)
(1)  107/    91F0 : C5 01               	ld 		@1(p1) 												; bump pointer.
(1)  108/    91F2 : 31                  	xpal 	p1
(1)  109/    91F3 : 94 F6               	jp 		__PRScrollLoop
(1)  110/    91F5 : C4 70               	ldi 	128-16 												; clear from and move to last line
(1)  111/    91F7 : 90 3D               	jmp 	__PRClearFromMoveTo
(1)  112/    91F9 :                     ;
(1)  113/    91F9 :                     ;	Exit screen drawing routine.
(1)  114/    91F9 :                     ;
(1)  115/    91F9 :                     __PRExit:
(1)  116/    91F9 : C2 03               	ld 		3(p2) 												; if character was zero, loop
(1)  117/    91FB : 98 A8               	jz 		__PRPrintString 									; back as printing string at P1.
(1)  118/    91FD :                     __PRExitNoCheck:
(1)  119/    91FD : (MACRO)             	pulle 														; restore registers
(1)  119/    91FD : C6 01                       ld              @1(p2)
(1)  119/    91FF : 01                          xae
(1)  120/    9200 : (MACRO)             	pullp 	p1
(1)  120/    9200 : C6 01                       ld              @1(p2)
(1)  120/    9202 : 31                          xpal    P1
(1)  120/    9203 : C6 01                       ld              @1(p2)
(1)  120/    9205 : 35                          xpah    P1
(1)  121/    9206 : (MACRO)             	pulla
(1)  121/    9206 : C6 01                       ld              @1(p2)
(1)  122/    9208 : 3F                  	xppc 	p3 													; return
(1)  123/    9209 : 90 8B               	jmp 	Print 												; make re-entrant.
(1)  124/    920B :                     ;
(1)  125/    920B :                     ;	Check for supported control characters 8 (Backspace) 12 (Clear) 13 (Carriage Return)
(1)  126/    920B :                     ;
(1)  127/    920B :                     __PRIsControlChar:
(1)  128/    920B : 40                  	lde 														; restore character.
(1)  129/    920C : E4 0D               	xri 	13 													; carriage return ? (13)
(1)  130/    920E : 98 1B               	jz 		__PRIsReturn
(1)  131/    9210 : E4 01               	xri 	13!12 												; form feed ? (12)
(1)  132/    9212 : 98 20               	jz 		__PRClearScreen
(1)  133/    9214 : E4 04               	xri 	12!8 												; backspace ? (8)
(1)  134/    9216 : 9C E1               	jnz 	__PRExit 
(1)  135/    9218 :                     ;
(1)  136/    9218 :                     ;	Handle backspace (8)
(1)  137/    9218 :                     ;
(1)  138/    9218 : 31                  	xpal 	p1 													; check cursor position is zero
(1)  139/    9219 : 98 DE               	jz 		__PRExit 											; if it is, cannot backspace so exit.
(1)  140/    921B : 31                  	xpal 	p1  												; put it back
(1)  141/    921C : C5 FF               	ld 		@-1(p1)												; move it back one
(1)  142/    921E : C4 20               	ldi 	' '	 												; erase in shadow
(1)  143/    9220 : C9 00               	st 		(p1)
(1)  144/    9222 : C4 00               	ldi 	0 													; point P1 to VRAM
(1)  145/    9224 : 35                  	xpah 	p1
(1)  146/    9225 : C4 20               	ldi 	' '													; erase in VRAM
(1)  147/    9227 : C9 00               	st 		(p1)
(1)  148/    9229 : 90 B1               	jmp 	__PRUpdateCursor 									; and exit
(1)  149/    922B :                     ;
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 9 - 1/10/2016 11:47:39


(1)  150/    922B :                     ;	Handle carriage return (13)
(1)  151/    922B :                     ;
(1)  152/    922B :                     __PRIsReturn:
(1)  153/    922B : 31                  	xpal 	p1 													; cursor position in A
(1)  154/    922C : D4 F0               	ani 	0xF0 												; start of current line
(1)  155/    922E : 02                  	ccl 														; down one line
(1)  156/    922F : F4 10               	adi 	0x10 	
(1)  157/    9231 : 31                  	xpal 	p1 													; put it back in P1.
(1)  158/    9232 : 90 A8               	jmp 	__PRUpdateCursor
(1)  159/    9234 :                     ;
(1)  160/    9234 :                     ;	Handle clear screen (12)
(1)  161/    9234 :                     ;
(1)  162/    9234 :                     __PRClearScreen:
(1)  163/    9234 : C4 00               	ldi 	0 													; clear shadow memory from here.
(1)  164/    9236 :                     ;
(1)  165/    9236 :                     ;	From position A, clear the memory in the shadow screen to the end, copy the shadow screen to VRAM
(1)  166/    9236 :                     ;	then use position A as the new cursor position.
(1)  167/    9236 :                     ;
(1)  168/    9236 :                     __PRClearFromMoveTo:
(1)  169/    9236 : CE FF               	st 		@-1(p2) 											; save this position, the cursor goes here.
(1)  170/    9238 :                     __PRClearLoop:
(1)  171/    9238 : 31                  	xpal 	p1 													; save position in P1.
(1)  172/    9239 : C4 20               	ldi 	' '													; write space there.
(1)  173/    923B : CD 01               	st 		@1(p1)
(1)  174/    923D : 31                  	xpal 	p1
(1)  175/    923E : 94 F8               	jp 		__PRClearLoop 										; until reached shadow memory start.
(1)  176/    9240 : C4 00               	ldi 	0 													; now copy shadow memory to screen memory.
(1)  177/    9242 :                     __PRCopy:
(1)  178/    9242 : 31                  	xpal 	p1 													; set up P1.L
(1)  179/    9243 : C4 0C               	ldi 	ScreenMirror/256 									; point to shadow memory.
(1)  180/    9245 : 35                  	xpah 	p1 													
(1)  181/    9246 : C1 00               	ld 		(p1) 												; read shadow memory
(1)  182/    9248 : 35                  	xpah 	p1 													; zero P1.H preserving A
(1)  183/    9249 : C4 00               	ldi 	0
(1)  184/    924B : 35                  	xpah 	p1
(1)  185/    924C : CD 01               	st 		@1(p1) 												; save and increment p1
(1)  186/    924E : 31                  	xpal 	p1 
(1)  187/    924F : 94 F1               	jp 		__PRCopy 											; keep doing till all copied.
(1)  188/    9251 : C6 01               	ld 		@1(p2) 												; read cursor position
(1)  189/    9253 : 31                  	xpal 	p1 													; put in P1.L
(1)  190/    9254 : 90 86               	jmp 	__PRUpdateCursor
(1)  191/    9256 :                     
(1)  192/    9256 :                     	endsection 	Print
(1)  193/    9256 :                     
(1)  194/    9256 :                     ; ****************************************************************************************************************
(1)  195/    9256 :                     ; ****************************************************************************************************************
(1)  196/    9256 :                     ;
(1)  197/    9256 :                     ;		Input a single character into A. Case is converted to Upper. All registers preserved except A
(1)  198/    9256 :                     ;
(1)  199/    9256 :                     ; ****************************************************************************************************************
(1)  200/    9256 :                     ; ****************************************************************************************************************
(1)  201/    9256 :                     
(1)  202/    9256 :                     GetChar:
(1)  203/    9256 :                     	section 	GetChar
(1)  204/    9256 : C4 08               	ldi 	0x8 												; set P1 to $8xx, and save P1.H
(1)  205/    9258 : 35                  	xpah 	p1
(1)  206/    9259 : CE FF               	st 		@-1(p2)
(1)  207/    925B :                     __GCWaitKey: 													; wait for key press
(1)  208/    925B : C1 00               	ld 		0(p1)
(1)  209/    925D : 94 FC               	jp 		__GCWaitKey
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 10 - 1/10/2016 11:47:39


(1)  210/    925F : D4 7F               	ani	 	0x7F 												; throw away the upper bit.
(1)  211/    9261 : CA FF               	st 		-1(p2) 												; save it below stack
(1)  212/    9263 :                     __GCWaitRelease:
(1)  213/    9263 : C1 00               	ld 		0(p1) 												; wait for release
(1)  214/    9265 : D4 80               	ani 	0x80
(1)  215/    9267 : 9C FA               	jnz 	__GCWaitRelease
(1)  216/    9269 : C6 01               	ld 		@1(p2) 												; restore P1.H
(1)  217/    926B : 35                  	xpah 	p1
(1)  218/    926C : C2 FE               	ld 		-2(p2) 												; restore saved value
(1)  219/    926E : 02                  	ccl
(1)  220/    926F : F4 20               	adi 	0x20												; will make lower case -ve
(1)  221/    9271 : 94 02               	jp 		__GCNotLower
(1)  222/    9273 : FC 20               	cai 	0x20 												; capitalise
(1)  223/    9275 :                     __GCNotLower:
(1)  224/    9275 : F4 E0               	adi 	0xE0 												; fix up.
(1)  225/    9277 : 3F                  	xppc 	p3 													; return
(1)  226/    9278 : 90 DC               	jmp 	GetChar 											; make re-entrant
(1)  227/    927A :                     	endsection 	GetChar
(1)  228/    927A :                     
(1)  229/    927A :                     ; ****************************************************************************************************************
(1)  230/    927A :                     ; ****************************************************************************************************************
(1)  231/    927A :                     ;
(1)  232/    927A :                     ;			Read an ASCIIZ string from keyboard into P1 of length A maximum (excludes NULL terminator)
(1)  233/    927A :                     ;
(1)  234/    927A :                     ; ****************************************************************************************************************
(1)  235/    927A :                     ; ****************************************************************************************************************
(1)  236/    927A :                     
(1)  237/    927A :                     GetString:
(1)  238/    927A :                     	section GetString
(1)  239/    927A : (MACRO)             	pusha 														; save A,P3,E
(1)  239/    927A : CE FF                       st              @-1(p2)
(1)  240/    927C : (MACRO)             	pushp 	p3
(1)  240/    927C : 37                          xpah    P3
(1)  240/    927D : CE FF                       st              @-1(p2)
(1)  240/    927F : 33                          xpal    P3
(1)  240/    9280 : CE FF                       st              @-1(p2)
(1)  241/    9282 : (MACRO)             	pushe 
(1)  241/    9282 : 40                          lde
(1)  241/    9283 : CE FF                       st              @-1(p2)
(1)  242/    9285 : C4 00               	ldi 	0 													; set E (current position) to A.
(1)  243/    9287 : 01                  	xae
(1)  244/    9288 :                     __GSLoop:
(1)  245/    9288 : (MACRO)             	lpi 	p3,Print-1 											; print the prompt (half coloured square)
(1)  245/    9288 : C4 91                       ldi     (PRINT-1) / 256
(1)  245/    928A : 37                          xpah    P3
(1)  245/    928B : C4 95                       ldi     (PRINT-1) & 255
(1)  245/    928D : 33                          xpal    P3
(1)  246/    928E : C4 9B               	ldi 	155
(1)  247/    9290 : 3F                  	xppc 	p3
(1)  248/    9291 : (MACRO)             	lpi 	p3,GetChar-1 										; get a character
(1)  248/    9291 : C4 92                       ldi     (GETCHAR-1) / 256
(1)  248/    9293 : 37                          xpah    P3
(1)  248/    9294 : C4 55                       ldi     (GETCHAR-1) & 255
(1)  248/    9296 : 33                          xpal    P3
(1)  249/    9297 : 3F                  	xppc 	p3
(1)  250/    9298 : C9 80               	st 		-0x80(p1) 											; save it in the current position.
(1)  251/    929A : (MACRO)             	lpi 	p3,Print-1 											; erase the prompt with backspace.
(1)  251/    929A : C4 91                       ldi     (PRINT-1) / 256
(1)  251/    929C : 37                          xpah    P3
(1)  251/    929D : C4 95                       ldi     (PRINT-1) & 255
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 11 - 1/10/2016 11:47:39


(1)  251/    929F : 33                          xpal    P3
(1)  252/    92A0 : C4 08               	ldi 	8
(1)  253/    92A2 : 3F                  	xppc 	p3
(1)  254/    92A3 : C1 80               	ld 		-0x80(p1) 											; re-read character
(1)  255/    92A5 : D4 E0               	ani 	0xE0 												; check if control key.
(1)  256/    92A7 : 98 0F               	jz 		__GSControlKey 
(1)  257/    92A9 : 40                  	lde 														; get current position.
(1)  258/    92AA : E2 03               	xor 	3(p2) 												; reached maximum length of buffer ?
(1)  259/    92AC : 98 DA               	jz 		__GSLoop 											; if so, ignore the key and go round again.
(1)  260/    92AE : C1 80               	ld 		-0x80(p1) 											; get character and print it
(1)  261/    92B0 : 3F                  	xppc 	p3
(1)  262/    92B1 : C4 01               	ldi 	1 													; increment E
(1)  263/    92B3 : 02                  	ccl
(1)  264/    92B4 : 70                  	ade
(1)  265/    92B5 : 01                  	xae
(1)  266/    92B6 : 90 D0               	jmp 	__GSLoop 											; and go round again.
(1)  267/    92B8 :                     ;
(1)  268/    92B8 :                     ;	Handle control keys (0x00-0x1F)
(1)  269/    92B8 :                     ;
(1)  270/    92B8 :                     __GSControlKey:
(1)  271/    92B8 : C1 80               	ld 		-0x80(p1) 											; get typed in key
(1)  272/    92BA : E4 08               	xri 	8 													; check for backspace.
(1)  273/    92BC : 98 17               	jz 		__GSBackspace 			
(1)  274/    92BE : E4 05               	xri 	8!13 												; check for CR
(1)  275/    92C0 : 9C C6               	jnz 	__GSLoop 											; if not, ignore the key.
(1)  276/    92C2 :                     ;
(1)  277/    92C2 :                     ;	Carriage Return, ending input.
(1)  278/    92C2 :                     ;
(1)  279/    92C2 : C9 80               	st 		-0x80(p1) 											; replace the CR written with NULL terminator.
(1)  280/    92C4 : C4 0D               	ldi 	13 													; print CR
(1)  281/    92C6 : 3F                  	xppc 	p3
(1)  282/    92C7 : (MACRO)             	pulle 														; restore E,P3,A
(1)  282/    92C7 : C6 01                       ld              @1(p2)
(1)  282/    92C9 : 01                          xae
(1)  283/    92CA : (MACRO)             	pullp	p3
(1)  283/    92CA : C6 01                       ld              @1(p2)
(1)  283/    92CC : 33                          xpal    P3
(1)  283/    92CD : C6 01                       ld              @1(p2)
(1)  283/    92CF : 37                          xpah    P3
(1)  284/    92D0 : (MACRO)             	pulla
(1)  284/    92D0 : C6 01                       ld              @1(p2)
(1)  285/    92D2 : 3F                  	xppc 	p3 													; return
(1)  286/    92D3 : 90 A5               	jmp 	GetString 											; make re-entrant (probably unneccessary !!)
(1)  287/    92D5 :                     ;
(1)  288/    92D5 :                     ;	Backspace entered
(1)  289/    92D5 :                     ;
(1)  290/    92D5 :                     __GSBackspace
(1)  291/    92D5 : 40                  	lde 														; if E = 0 we can't backspace any further.
(1)  292/    92D6 : 98 B0               	jz 		__GSLoop
(1)  293/    92D8 : C4 08               	ldi 	8 													; backspace on screen
(1)  294/    92DA : 3F                  	xppc 	p3
(1)  295/    92DB : C4 FF               	ldi 	0xFF 												; decrement E
(1)  296/    92DD : 02                  	ccl
(1)  297/    92DE : 70                  	ade
(1)  298/    92DF : 01                  	xae
(1)  299/    92E0 : 90 A6               	jmp 	__GSLoop 											; and go round again.
(1)  300/    92E2 :                     
(1)  301/    92E2 :                     	endsection GetString
(1)  302/    92E2 :                     
      58/    92E2 :                     	include source\execute.asm 									; statement exec main loop
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 12 - 1/10/2016 11:47:39


(1)    1/    92E2 :                     ; ****************************************************************************************************************
(1)    2/    92E2 :                     ; ****************************************************************************************************************
(1)    3/    92E2 :                     ;
(1)    4/    92E2 :                     ;										Instruction Execution
(1)    5/    92E2 :                     ;	
(1)    6/    92E2 :                     ; ****************************************************************************************************************
(1)    7/    92E2 :                     ; ****************************************************************************************************************
(1)    8/    92E2 :                     
(1)    9/    92E2 :                     ; ****************************************************************************************************************
(1)   10/    92E2 :                     ;							Source codes for execution, with skip-over go here
(1)   11/    92E2 :                     ; ****************************************************************************************************************
(1)   12/    92E2 :                     
(1)   13/    92E2 :                     	include source\commands\os.asm 								; OS
(2)    1/    92E2 :                     ; ****************************************************************************************************************
(2)    2/    92E2 :                     ; ****************************************************************************************************************
(2)    3/    92E2 :                     ;
(2)    4/    92E2 :                     ;												OS command
(2)    5/    92E2 :                     ;	
(2)    6/    92E2 :                     ; ****************************************************************************************************************
(2)    7/    92E2 :                     ; ****************************************************************************************************************
(2)    8/    92E2 :                     
(2)    9/    92E2 : 90 07               	jmp 	COS_Over
(2)   10/    92E4 :                     
(2)   11/    92E4 :                     CMD_OS:
(2)   12/    92E4 : (MACRO)             	lpi 	p3,BootMonitor-1 									; monitor re-entry point
(2)   12/    92E4 : C4 02                       ldi     (BOOTMONITOR-1) / 256
(2)   12/    92E6 : 37                          xpah    P3
(2)   12/    92E7 : C4 0F                       ldi     (BOOTMONITOR-1) & 255
(2)   12/    92E9 : 33                          xpal    P3
(2)   13/    92EA : 3F                  	xppc 	p3													; go there.
(2)   14/    92EB :                     
(2)   15/    92EB :                     COS_Over:
(1)   14/    92EB :                     	include source\commands\new_end.asm 						; NEW and END
(2)    1/    92EB :                     ; ****************************************************************************************************************
(2)    2/    92EB :                     ; ****************************************************************************************************************
(2)    3/    92EB :                     ;
(2)    4/    92EB :                     ;												NEW and END
(2)    5/    92EB :                     ;	
(2)    6/    92EB :                     ; ****************************************************************************************************************
(2)    7/    92EB :                     ; ****************************************************************************************************************
(2)    8/    92EB :                     
(2)    9/    92EB : 90 0E               	jmp 	CNE_Over
(2)   10/    92ED :                     
(2)   11/    92ED :                     ; ****************************************************************************************************************
(2)   12/    92ED :                     ;						NEW (Erase program) also executes END in case in running program
(2)   13/    92ED :                     ; ****************************************************************************************************************
(2)   14/    92ED :                     
(2)   15/    92ED :                     CMD_New:
(2)   16/    92ED : (MACRO)             	lpi 	p3,ProgramBase 										; write $FF at program base
(2)   16/    92ED : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   16/    92EF : 37                          xpah    P3
(2)   16/    92F0 : C4 16                       ldi     (PROGRAMBASE) & 255
(2)   16/    92F2 : 33                          xpal    P3
(2)   17/    92F3 : C4 FF               	ldi 	0xFF
(2)   18/    92F5 : CB 00               	st 		0(p3) 												; this erases the program
(2)   19/    92F7 :                     
(2)   20/    92F7 :                     ; ****************************************************************************************************************
(2)   21/    92F7 :                     ;													END program
(2)   22/    92F7 :                     ; ****************************************************************************************************************
(2)   23/    92F7 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(new_end.asm) - page 13 - 1/10/2016 11:47:39


(2)   24/    92F7 :                     CMD_End:
(2)   25/    92F7 : 02                  	ccl 														; we cause an error, but it is ERRC_End which is 
(2)   26/    92F8 : C4 FF               	ldi 	ERRC_End 											; not an error and not reported as such.
(2)   27/    92FA : 01                  	xae
(2)   28/    92FB :                     
(2)   29/    92FB :                     CNE_Over:
(1)   15/    92FB :                     	include source\commands\clear.asm							; CLEAR
(2)    1/    92FB :                     ; ****************************************************************************************************************
(2)    2/    92FB :                     ; ****************************************************************************************************************
(2)    3/    92FB :                     ;
(2)    4/    92FB :                     ;													CLEAR
(2)    5/    92FB :                     ;	
(2)    6/    92FB :                     ; ****************************************************************************************************************
(2)    7/    92FB :                     ; ****************************************************************************************************************
(2)    8/    92FB :                     
(2)    9/    92FB : 90 13               	jmp	CCL_Over
(2)   10/    92FD :                     
(2)   11/    92FD :                     ; ****************************************************************************************************************
(2)   12/    92FD :                     ;												CLEAR command
(2)   13/    92FD :                     ; ****************************************************************************************************************
(2)   14/    92FD :                     
(2)   15/    92FD :                     CMD_Clear:
(2)   16/    92FD : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   16/    92FD : C4 0C                       ldi     (VARIABLES) / 256
(2)   16/    92FF : 37                          xpah    P3
(2)   16/    9300 : C4 90                       ldi     (VARIABLES) & 255
(2)   16/    9302 : 33                          xpal    P3
(2)   17/    9303 : C4 1A               	ldi 	26 													; loop counter to 26
(2)   18/    9305 : CA FF               	st 		-1(p2)
(2)   19/    9307 :                     CCL_Loop:
(2)   20/    9307 : C4 00               	ldi 	0x00												; clear a variable
(2)   21/    9309 : CF 01               	st 		@1(p3)
(2)   22/    930B : BA FF               	dld 	-1(p2) 												; done all
(2)   23/    930D : 9C F8               	jnz 	CCL_Loop											; loop back
(2)   24/    930F : 03                  	scl 														; no error
(2)   25/    9310 :                     
(2)   26/    9310 :                     CCL_Over:
(1)   16/    9310 :                     	include source\commands\call.asm 							; CALL
(2)    1/    9310 :                     ; ****************************************************************************************************************
(2)    2/    9310 :                     ; ****************************************************************************************************************
(2)    3/    9310 :                     ;
(2)    4/    9310 :                     ;												CALL command
(2)    5/    9310 :                     ;	
(2)    6/    9310 :                     ; ****************************************************************************************************************
(2)    7/    9310 :                     ; ****************************************************************************************************************
(2)    8/    9310 :                     
(2)    9/    9310 : 90 27               	jmp		CCA_Over
(2)   10/    9312 :                     
(2)   11/    9312 :                     CMD_Call:
(2)   12/    9312 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the address pair (e.g. (H,L))
(2)   12/    9312 : C4 95                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   12/    9314 : 37                          xpah    P3
(2)   12/    9315 : C4 D6                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   12/    9317 : 33                          xpal    P3
(2)   13/    9318 : 3F                  	xppc 	p3
(2)   14/    9319 : 94 1E               	jp 		CCA_Over 											; exit on error.
(2)   15/    931B : C2 FE               	ld 		-2(p2) 												; retrieve the L value to E
(2)   16/    931D : 01                  	xae 	
(2)   17/    931E : C2 FF               	ld 		-1(p2)												; retrieve the H value to P3.H
(2)   18/    9320 : 37                  	xpah 	p3
 AS V1.42 Beta [Bld 102] - source file minol.asm(call.asm) - page 14 - 1/10/2016 11:47:39


(2)   19/    9321 : 40                  	lde	 														; copy L value to P3.L
(2)   20/    9322 : 33                  	xpal 	p3
(2)   21/    9323 : C7 FF               	ld 		@-1(p3) 											; fix up for pre-increment
(2)   22/    9325 : (MACRO)             	pushp 	p1 													; save P1
(2)   22/    9325 : 35                          xpah    P1
(2)   22/    9326 : CE FF                       st              @-1(p2)
(2)   22/    9328 : 31                          xpal    P1
(2)   22/    9329 : CE FF                       st              @-1(p2)
(2)   23/    932B : (MACRO)             	lpi 	p1,Variables 										; and point P1 to the variables
(2)   23/    932B : C4 0C                       ldi     (VARIABLES) / 256
(2)   23/    932D : 35                          xpah    P1
(2)   23/    932E : C4 90                       ldi     (VARIABLES) & 255
(2)   23/    9330 : 31                          xpal    P1
(2)   24/    9331 : 03                  	scl 														; set CY/L flag, so the call can return an error.
(2)   25/    9332 : 3F                  	xppc 	p3 													; call the routine
(2)   26/    9333 : (MACRO)             	pullp	p1 													; restore P1
(2)   26/    9333 : C6 01                       ld              @1(p2)
(2)   26/    9335 : 31                          xpal    P1
(2)   26/    9336 : C6 01                       ld              @1(p2)
(2)   26/    9338 : 35                          xpah    P1
(2)   27/    9339 :                     	
(2)   28/    9339 :                     CCA_Over:
(1)   17/    9339 :                     	include source\commands\let.asm 							; LET (optional, but slower if not present)
(2)    1/    9339 :                     ; ****************************************************************************************************************
(2)    2/    9339 :                     ; ****************************************************************************************************************
(2)    3/    9339 :                     ;
(2)    4/    9339 :                     ;												LET command
(2)    5/    9339 :                     ;	
(2)    6/    9339 :                     ; ****************************************************************************************************************
(2)    7/    9339 :                     ; ****************************************************************************************************************
(2)    8/    9339 :                     
(2)    9/    9339 : 90 51               	jmp 	CLE_Over
(2)   10/    933B :                     
(2)   11/    933B :                     CMD_Let:
(2)   12/    933B : C1 00               	ld 		(p1) 												; look at character
(2)   13/    933D : E4 28               	xri 	'('													; is it let (h,l) ?
(2)   14/    933F : 98 20               	jz 		CLE_IsHL 											; if so, go to the (H,L) code
(2)   15/    9341 : C1 00               	ld 		(p1) 												; re-read it.
(2)   16/    9343 : 02                  	ccl
(2)   17/    9344 : F4 A5               	adi 	255-'Z' 											; will be +ve on error
(2)   18/    9346 : 94 04               	jp 		CLE_Syntax 											; e.g. > Z
(2)   19/    9348 : F4 1A               	adi 	26 													; will be 0-25 if A..Z
(2)   20/    934A : 94 06               	jp 		CLE_SingleVariable
(2)   21/    934C :                     ;
(2)   22/    934C :                     ;	Syntax Error
(2)   23/    934C :                     ;
(2)   24/    934C :                     CLE_Syntax:
(2)   25/    934C : C4 05               	ldi 	ERRC_Syntax 										; set E to error code.
(2)   26/    934E : 01                  	xae
(2)   27/    934F : 02                  	ccl 														; CY/L = 0 = Error
(2)   28/    9350 : 90 3A               	jmp 	CLE_Over 											; and exit
(2)   29/    9352 :                     ;
(2)   30/    9352 :                     ;	A-Z. AC contains 0-25
(2)   31/    9352 :                     ;
(2)   32/    9352 :                     CLE_SingleVariable:
(2)   33/    9352 : 02                  	ccl  														; work out variable address, and put on stack.
(2)   34/    9353 : F4 90               	adi 	Variables & 255
(2)   35/    9355 : CE FE               	st 		@-2(p2) 
(2)   36/    9357 : C4 0C               	ldi 	Variables / 256
(2)   37/    9359 : F4 00               	adi 	0
 AS V1.42 Beta [Bld 102] - source file minol.asm(let.asm) - page 15 - 1/10/2016 11:47:39


(2)   38/    935B : CA 01               	st 		1(p2)
(2)   39/    935D : C5 01               	ld 		@1(p1) 												; skip over the variable.
(2)   40/    935F : 90 0B               	jmp 	CLE_EvaluateAndWrite
(2)   41/    9361 :                     ;
(2)   42/    9361 :                     ;	LET is (H,L) = <expr>
(2)   43/    9361 :                     ;
(2)   44/    9361 :                     CLE_IsHL:
(2)   45/    9361 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the (H,L)
(2)   45/    9361 : C4 95                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   45/    9363 : 37                          xpah    P3
(2)   45/    9364 : C4 D6                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   45/    9366 : 33                          xpal    P3
(2)   46/    9367 : 3F                  	xppc 	p3
(2)   47/    9368 : 94 22               	jp 		CLE_Over 											; exit on error
(2)   48/    936A : C6 FE               	ld 		@-2(p2) 											; the address to write to is now on TOS.
(2)   49/    936C :                     ;
(2)   50/    936C :                     ;	Evaluate and write.
(2)   51/    936C :                     ;
(2)   52/    936C :                     CLE_EvaluateAndWrite:
(2)   53/    936C : C5 01               	ld 		@1(p1) 												; skip over spaces
(2)   54/    936E : E4 20               	xri 	' '
(2)   55/    9370 : 98 FA               	jz 		CLE_EvaluateAndWrite
(2)   56/    9372 : E4 1D               	xri 	' '!'='												; check first non space character is =
(2)   57/    9374 : 9C D6               	jnz 	CLE_Syntax 											; if not, a syntax error.
(2)   58/    9376 :                     
(2)   59/    9376 : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; set up to evaluate the RHS
(2)   59/    9376 : C4 94                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)   59/    9378 : 37                          xpah    P3
(2)   59/    9379 : C4 82                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)   59/    937B : 33                          xpal    P3
(2)   60/    937C : 3F                  	xppc 	p3													; do it
(2)   61/    937D : C6 02               	ld 		@2(p2) 												; remove target from TOS but leave data there
(2)   62/    937F : 06                  	csa 														; did that evaluate cause an error ?
(2)   63/    9380 : 94 0A               	jp 		CLE_Over 											; if so, exit with that error.
(2)   64/    9382 :                     
(2)   65/    9382 : C2 FE               	ld 		-2(p2) 												; load address into P3
(2)   66/    9384 : 33                  	xpal 	p3
(2)   67/    9385 : C2 FF               	ld 		-1(p2)
(2)   68/    9387 : 37                  	xpah 	p3
(2)   69/    9388 : 40                  	lde 														; get value
(2)   70/    9389 : CB 00               	st 		(p3) 												; store there
(2)   71/    938B : 03                  	scl 														; no error and exit.
(2)   72/    938C :                     
(2)   73/    938C :                     CLE_Over:
(1)   18/    938C :                     	include source\commands\if.asm								; IF
(2)    1/    938C :                     ; ****************************************************************************************************************
(2)    2/    938C :                     ; ****************************************************************************************************************
(2)    3/    938C :                     ;
(2)    4/    938C :                     ;												IF command
(2)    5/    938C :                     ;	
(2)    6/    938C :                     ; ****************************************************************************************************************
(2)    7/    938C :                     ; ****************************************************************************************************************
(2)    8/    938C :                     
(2)    9/    938C : 90 4D               	jmp		CIF_Over
(2)   10/    938E :                     
(2)   11/    938E :                     CMD_If:
(2)   12/    938E : 3F                  	xppc 	p3 													; calculate LHS of expr.
(2)   13/    938F : 94 4A               	jp 		CIF_Over											; exit on error.
(2)   14/    9391 : C1 00               	ld 		(p1)												; get the relative operator.
(2)   15/    9393 : E4 3D               	xri 	'='													; check it is =, < or #
 AS V1.42 Beta [Bld 102] - source file minol.asm(if.asm) - page 16 - 1/10/2016 11:47:39


(2)   16/    9395 : 98 0E               	jz 		CIF_Continue
(2)   17/    9397 : E4 1E               	xri 	'='!'#'
(2)   18/    9399 : 98 0A               	jz 		CIF_Continue
(2)   19/    939B : E4 1F               	xri 	'#'!'<'
(2)   20/    939D : 98 06               	jz 		CIF_Continue
(2)   21/    939F :                     ;
(2)   22/    939F :                     ;	Syntax error - bad relative operation.
(2)   23/    939F :                     ;
(2)   24/    939F :                     CIF_Syntax:
(2)   25/    939F : C4 05               	ldi	 	ERRC_Syntax											; report syntax error
(2)   26/    93A1 : 01                  	xae
(2)   27/    93A2 : 02                  	ccl
(2)   28/    93A3 : 90 36               	jmp 	CIF_Over
(2)   29/    93A5 :                     ;
(2)   30/    93A5 :                     ;	Continue IF - have LHS in E.
(2)   31/    93A5 :                     ;
(2)   32/    93A5 :                     CIF_Continue:
(2)   33/    93A5 : C5 01               	ld 		@1(p1) 												; reget operator, and save on stack
(2)   34/    93A7 : CE FF               	st 		@-1(p2)
(2)   35/    93A9 : 40                  	lde 														; save LHS on stack.
(2)   36/    93AA : CE FF               	st 		@-1(p2)
(2)   37/    93AC : 3F                  	xppc 	p3 													; evaluate the RHS of the expression
(2)   38/    93AD : C6 02               	ld 		@2(p2) 												; drop operator and LHS but the values still there.
(2)   39/    93AF : 06                  	csa 														; check for RHS error
(2)   40/    93B0 : 94 29               	jp 		CIF_Over 											; and exit on error
(2)   41/    93B2 : C2 FF               	ld 		-1(p2) 												; get operator
(2)   42/    93B4 : E4 3C               	xri 	'<'
(2)   43/    93B6 : 9C 09               	jnz 	CIF_Equality 										; if not less than it's an equality test e.g. # or =
(2)   44/    93B8 :                     
(2)   45/    93B8 :                     ; ****************************************************************************************************************
(2)   46/    93B8 :                     ;												Less than test.
(2)   47/    93B8 :                     ; ****************************************************************************************************************
(2)   48/    93B8 :                     
(2)   49/    93B8 : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   50/    93BA : 03                  	scl
(2)   51/    93BB : 78                  	cae 														; subtract RHS.
(2)   52/    93BC : 06                  	csa 														; get CY/L flag
(2)   53/    93BD : D4 80               	ani 	0x80 												; now it is AC = 0 if < true.
(2)   54/    93BF : 90 0D               	jmp 	CIF_TestIfZero
(2)   55/    93C1 :                     
(2)   56/    93C1 :                     ; ****************************************************************************************************************
(2)   57/    93C1 :                     ;											Equal/Not Equal Test.
(2)   58/    93C1 :                     ; ****************************************************************************************************************
(2)   59/    93C1 :                     	
(2)   60/    93C1 :                     CIF_Equality:
(2)   61/    93C1 : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   62/    93C3 : 60                  	xre 														; compare to RHS. AC = 0 if *equal*
(2)   63/    93C4 : 98 02               	jz 		CIF_Equality2
(2)   64/    93C6 : C4 02               	ldi 	2 													; AC = 0 if *equal* 2 if *different*
(2)   65/    93C8 :                     CIF_Equality2:
(2)   66/    93C8 : 01                  	xae 														; save in E
(2)   67/    93C9 : C2 FF               	ld 		-1(p2) 												; get operator.
(2)   68/    93CB : D4 02               	ani 	2 													; is now 0 if '=' ($3D) 2 if '#' ($23)
(2)   69/    93CD : 60                  	xre 														; XOR with the result. Now 0 if passes test.
(2)   70/    93CE :                     
(2)   71/    93CE :                     ; ****************************************************************************************************************
(2)   72/    93CE :                     ;							Pass Test (e.g. execute statement following ;) if AC = 0
(2)   73/    93CE :                     ; ****************************************************************************************************************
(2)   74/    93CE :                     
(2)   75/    93CE :                     CIF_TestIfZero:
 AS V1.42 Beta [Bld 102] - source file minol.asm(if.asm) - page 17 - 1/10/2016 11:47:39


(2)   76/    93CE : 03                  	scl 														; set CY/L = No Error.
(2)   77/    93CF : 9C 0A               	jnz 	CIF_Over 											; if non-zero then do next command as normal.
(2)   78/    93D1 :                     	
(2)   79/    93D1 : C1 00               	ld 		(p1) 												; get next character
(2)   80/    93D3 : E4 3B               	xri 	';'													; should be a semicolon
(2)   81/    93D5 : 9C C8               	jnz 	CIF_Syntax 											; if not error
(2)   82/    93D7 : C5 01               	ld 		@1(p1) 												; step over it.
(2)   83/    93D9 : 90 54               	jmp 	ExecuteFromAddressDirect 							; and run from here.
(2)   84/    93DB :                     
(2)   85/    93DB :                     CIF_Over:
(2)   86/    93DB :                     
(2)   87/    93DB :                     
(1)   19/    93DB :                     	include source\commands\goto_run.asm						; GOTO and RUN (has to be last, probably !)
(2)    1/    93DB :                     ; ****************************************************************************************************************
(2)    2/    93DB :                     ; ****************************************************************************************************************
(2)    3/    93DB :                     ;
(2)    4/    93DB :                     ;												GOTO and RUN
(2)    5/    93DB :                     ;	
(2)    6/    93DB :                     ; ****************************************************************************************************************
(2)    7/    93DB :                     ; ****************************************************************************************************************
(2)    8/    93DB :                     
(2)    9/    93DB : 90 29               	jmp 	CRG_Over											; Skip over this command.
(2)   10/    93DD :                     
(2)   11/    93DD :                     ; ****************************************************************************************************************
(2)   12/    93DD :                     ;												GOTO command
(2)   13/    93DD :                     ; ****************************************************************************************************************
(2)   14/    93DD :                     
(2)   15/    93DD :                     CMD_Goto:	
(2)   16/    93DD : 3F                  	xppc 	p3 													; evaluate the line number to GOTO, in E
(2)   17/    93DE : 94 26               	jp 		CRG_Over 											; exit if error occurred
(2)   18/    93E0 : 40                  	lde 														; get line number
(2)   19/    93E1 : CA FF               	st 		-1(p2) 												; save below TOS.
(2)   20/    93E3 : (MACRO)             	lpi 	p1,ProgramBase 										; point P1 to program Base.
(2)   20/    93E3 : C4 90                       ldi     (PROGRAMBASE) / 256
(2)   20/    93E5 : 35                          xpah    P1
(2)   20/    93E6 : C4 16                       ldi     (PROGRAMBASE) & 255
(2)   20/    93E8 : 31                          xpal    P1
(2)   21/    93E9 :                     CRG_Find:
(2)   22/    93E9 : C1 00               	ld 		0(p1) 												; look at offset
(2)   23/    93EB : 94 06               	jp 		CRG_NotEnd											; if -ve then end of program.
(2)   24/    93ED : C4 01               	ldi 	ERRC_Label 											; return label error
(2)   25/    93EF : 01                  	xae
(2)   26/    93F0 : 02                  	ccl 														; set error flag
(2)   27/    93F1 : 90 13               	jmp 	CRG_Over
(2)   28/    93F3 :                     ;
(2)   29/    93F3 :                     CRG_NotEnd:
(2)   30/    93F3 : 01                  	xae 														; offset in E
(2)   31/    93F4 : C1 01               	ld 		1(p1) 												; get line number
(2)   32/    93F6 : E2 FF               	xor 	-1(p2) 												; go back if not required one.
(2)   33/    93F8 : 98 0A               	jz 		CRG_ExecuteFromP1									; if found, run from P1.
(2)   34/    93FA : C5 80               	ld 		@-0x80(p1) 											; go to next line
(2)   35/    93FC : 90 EB               	jmp 	CRG_Find 											; keep trying.
(2)   36/    93FE :                     ;
(2)   37/    93FE :                     ; ****************************************************************************************************************
(2)   38/    93FE :                     ;												RUN command
(2)   39/    93FE :                     ; ****************************************************************************************************************
(2)   40/    93FE :                     
(2)   41/    93FE :                     CMD_Run:	
(2)   42/    93FE : (MACRO)             	lpi 	p1,ProgramBase 										; start from first line of program
(2)   42/    93FE : C4 90                       ldi     (PROGRAMBASE) / 256
 AS V1.42 Beta [Bld 102] - source file minol.asm(goto_run.asm) - page 18 - 1/10/2016 11:47:39


(2)   42/    9400 : 35                          xpah    P1
(2)   42/    9401 : C4 16                       ldi     (PROGRAMBASE) & 255
(2)   42/    9403 : 31                          xpal    P1
(2)   43/    9404 :                     CRG_ExecuteFromP1:
(2)   44/    9404 : 90 0D               	jmp 	CheckLastCommandThenExecute 						; check if the last command and if not execute.
(2)   45/    9406 :                     
(2)   46/    9406 :                     CRG_Over:
(2)   47/    9406 :                     
(1)   20/    9406 :                     
(1)   21/    9406 :                     ; ****************************************************************************************************************
(1)   22/    9406 :                     ;								Command execution complete, check for error
(1)   23/    9406 :                     ; ****************************************************************************************************************
(1)   24/    9406 :                     
(1)   25/    9406 :                     EndOfCommandExecution:
(1)   26/    9406 : 06                  	csa 														; check CY/L error flag
(1)   27/    9407 : 94 12               	jp 		GotoCommandLine 									; if CY/L = 0 error so go to command line.
(1)   28/    9409 :                     
(1)   29/    9409 :                     ; ****************************************************************************************************************
(1)   30/    9409 :                     ;	Come here to execute the instruction P1 points to, after having executed, e.g. skips forward to : or NULL
(1)   31/    9409 :                     ; ****************************************************************************************************************
(1)   32/    9409 :                     
(1)   33/    9409 :                     ExecuteNextInstruction:
(1)   34/    9409 : C5 01               	ld 		@1(p1) 												; get next and skip
(1)   35/    940B : 98 06               	jz 		CheckLastCommandThenExecute							; if NULL, check if running mode and continue if so.
(1)   36/    940D : E4 3A               	xri 	':'
(1)   37/    940F : 9C F8               	jnz 	ExecuteNextInstruction 								; keep going until colon read.
(1)   38/    9411 : 90 1C               	jmp 	ExecuteFromAddressDirect 							; run code from the address given.
(1)   39/    9413 :                     ;
(1)   40/    9413 :                     ;	Test to see if the line is not the last one (e.g. offset is +ve) and if so, execute its code.
(1)   41/    9413 :                     ;
(1)   42/    9413 :                     CheckLastCommandThenExecute:
(1)   43/    9413 : C1 00               	ld 		(p1) 												; look at the offset to next.
(1)   44/    9415 : 94 0C               	jp 		ExecuteFromCommandStart 							; if +ve value, execute the line here.
(1)   45/    9417 :                     ;
(1)   46/    9417 :                     ;	Have reached the end of the program. The buffer with typed commands has $FF on the end to 'fake' this.
(1)   47/    9417 :                     ; 	e.g. when it reaches the end of that command it thinks it's dropped off the top of the program
(1)   48/    9417 :                     ;
(1)   49/    9417 : 03                  	scl 														; there is no error.
(1)   50/    9418 : C4 FF               	ldi 	ERRC_End 											; set the error code to "End"
(1)   51/    941A : 01                  	xae
(1)   52/    941B :                     GotoCommandLine: 												; return to Command Line with CY/L = error and E = code
(1)   53/    941B : 90 FE               	jmp 	GotoCommandLine										; if CY/L = 1 (no error) E not used.
(1)   54/    941D :                     ;
(1)   55/    941D :                     ;	Syntax error comes here.
(1)   56/    941D :                     ;
(1)   57/    941D :                     SyntaxError:
(1)   58/    941D : C4 05               	ldi 	ERRC_Syntax
(1)   59/    941F : 01                  	xae
(1)   60/    9420 : 02                  	ccl
(1)   61/    9421 : 90 F8               	jmp 	GotoCommandLine
(1)   62/    9423 :                     
(1)   63/    9423 :                     ; ****************************************************************************************************************
(1)   64/    9423 :                     ;	  Execute from the instruction at P1 (preceded by offset, line number), which is known to be a valid line.
(1)   65/    9423 :                     ; ****************************************************************************************************************
(1)   66/    9423 :                     
(1)   67/    9423 :                     ExecuteFromCommandStart:
(1)   68/    9423 : (MACRO)             	lpi 	p3,CurrentLine 										; point P3 to the current line
(1)   68/    9423 : C4 0C                       ldi     (CURRENTLINE) / 256
(1)   68/    9425 : 37                          xpah    P3
(1)   68/    9426 : C4 8D                       ldi     (CURRENTLINE) & 255
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 19 - 1/10/2016 11:47:39


(1)   68/    9428 : 33                          xpal    P3
(1)   69/    9429 : C1 01               	ld 		1(p1) 												; read the line number 
(1)   70/    942B : CB 00               	st 		(p3)												; and save it - current line # updated.
(1)   71/    942D : C5 02               	ld 		@2(p1) 												; skip over offset (+0) line number (+1)
(1)   72/    942F :                     
(1)   73/    942F :                     ; ****************************************************************************************************************
(1)   74/    942F :                     ;				Run command where the instruction is at P1 (e.g. it is an ASCIIZ string)
(1)   75/    942F :                     ; ****************************************************************************************************************
(1)   76/    942F :                     
(1)   77/    942F :                     ExecuteFromAddressDirect:
(1)   78/    942F : C5 01               	ld 		@1(p1) 												; read next character
(1)   79/    9431 : 98 E0               	jz 		CheckLastCommandThenExecute 						; if \0 then check for the next line.
(1)   80/    9433 : E4 20               	xri	 	' '
(1)   81/    9435 : 98 F8               	jz 		ExecuteFromAddressDirect 							; skip over spaces.
(1)   82/    9437 : E4 1A               	xri 	' '!':'												
(1)   83/    9439 : 98 F4               	jz 		ExecuteFromAddressDirect 							; skip over colons.
(1)   84/    943B : E4 18               	xri 	':'!'"'					
(1)   85/    943D : 98 CA               	jz 		ExecuteNextInstruction 								; if double quote (comment) found go to next instruction.
(1)   86/    943F :                     ;
(1)   87/    943F :                     ;	Now look the command up in the command list.
(1)   88/    943F :                     ;
(1)   89/    943F : C1 FF               	ld 		-1(p1) 												; read first character of command again
(1)   90/    9441 : 01                  	xae 														; put in E.
(1)   91/    9442 : (MACRO)             	lpi 	p3,CommandList
(1)   91/    9442 : C4 96                       ldi     (COMMANDLIST) / 256
(1)   91/    9444 : 37                          xpah    P3
(1)   91/    9445 : C4 21                       ldi     (COMMANDLIST) & 255
(1)   91/    9447 : 33                          xpal    P3
(1)   92/    9448 :                     EAFD_Search:
(1)   93/    9448 : C7 05               	ld 		@5(p3) 												; read first character and bump to next.
(1)   94/    944A : 98 2C               	jz 		EAFD_LETCode 										; if zero then give up.
(1)   95/    944C : 60                  	xre 														; same as first character ?
(1)   96/    944D : 9C F9               	jnz		EAFD_Search 										; no, keep looking.
(1)   97/    944F :                     
(1)   98/    944F : C3 FC               	ld 		-4(p3) 												; read 2nd character
(1)   99/    9451 : E1 00               	xor 	(p1) 												; compare against actual second character
(1)  100/    9453 : 9C F3               	jnz 	EAFD_Search
(1)  101/    9455 :                     ;
(1)  102/    9455 :                     ;	Skip over characters in the command, checking for NULL and : which would be syntax errors.
(1)  103/    9455 :                     ;
(1)  104/    9455 : C3 FD               	ld 		-3(p3) 												; number of characters to skip (one less than total as one skipped)
(1)  105/    9457 : CA FF               	st 		-1(p2) 												; temporary count.
(1)  106/    9459 :                     EAFD_Skip:
(1)  107/    9459 : C5 01               	ld 		@1(p1) 												; read a character and skip
(1)  108/    945B : 98 C0               	jz 		SyntaxError 										; if zero, then syntax error
(1)  109/    945D : E4 3A               	xri 	':'
(1)  110/    945F : 98 BC               	jz 		SyntaxError 										; if colon, then syntax error.
(1)  111/    9461 : BA FF               	dld 	-1(p2) 												; do it the requisite number of times.
(1)  112/    9463 : 9C F4               	jnz 	EAFD_Skip
(1)  113/    9465 :                     ;
(1)  114/    9465 :                     ;	Skip over any subsequent spaces
(1)  115/    9465 :                     ;
(1)  116/    9465 :                     EAFD_SkipSpaces:
(1)  117/    9465 : C5 01               	ld 		@1(p1) 												; check for spaces
(1)  118/    9467 : E4 20               	xri 	' '													; space found
(1)  119/    9469 : 98 FA               	jz 		EAFD_SkipSpaces
(1)  120/    946B : C5 FF               	ld 		@-1(p1) 											; undo last fetch so first character of next bit.
(1)  121/    946D :                     ;
(1)  122/    946D :                     ;	P1 is set up so execute the handler.
(1)  123/    946D :                     ;
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 20 - 1/10/2016 11:47:39


(1)  124/    946D : C3 FE               	ld 		-2(p3)												; get execute LSB
(1)  125/    946F : 01                  	xae 														; save in E
(1)  126/    9470 : C3 FF               	ld 		-1(p3) 												; get execute MSB
(1)  127/    9472 : 37                  	xpah 	p3 													; put in P3.H
(1)  128/    9473 : 40                  	lde 														; copy E to P3.L
(1)  129/    9474 : 33                  	xpal 	p3
(1)  130/    9475 : 3F                  	xppc 	p3
(1)  131/    9476 : 90 0B               	jmp 	EvaluateExpression 									; is set up to have immediate evaluate call.
(1)  132/    9478 :                     ;
(1)  133/    9478 :                     ;	Couldn't find a command, so point P1 to first character, then call the LET code.
(1)  134/    9478 :                     ;
(1)  135/    9478 :                     EAFD_LETCode:
(1)  136/    9478 : C5 FF               	ld 		@-1(p1) 											; point P1 to first character of command.
(1)  137/    947A : (MACRO)             	lpi 	p3,CMD_Let-1 										; go execute LET with evaluate re-entrancy
(1)  137/    947A : C4 93                       ldi     (CMD_LET-1) / 256
(1)  137/    947C : 37                          xpah    P3
(1)  137/    947D : C4 3A                       ldi     (CMD_LET-1) & 255
(1)  137/    947F : 33                          xpal    P3
(1)  138/    9480 : 3F                  	xppc 	p3
(1)  139/    9481 : 90 00               	jmp 	EvaluateExpression
(1)  140/    9483 :                     
(1)  141/    9483 :                     	include source\expression.asm 								; expression evaluator.
(2)    1/    9483 :                     ; ****************************************************************************************************************
(2)    2/    9483 :                     ; ****************************************************************************************************************
(2)    3/    9483 :                     ;
(2)    4/    9483 :                     ;												Expression Evaluation
(2)    5/    9483 :                     ;
(2)    6/    9483 :                     ; ****************************************************************************************************************
(2)    7/    9483 :                     ; ****************************************************************************************************************
(2)    8/    9483 :                     
(2)    9/    9483 :                     ; ****************************************************************************************************************
(2)   10/    9483 :                     ; ****************************************************************************************************************
(2)   11/    9483 :                     ;
(2)   12/    9483 :                     ;		Evaluate expression at P1. Return 	CY/L = 0 : Error 	E = Error Code
(2)   13/    9483 :                     ;											CY/L = 1 : Okay 	E = Result
(2)   14/    9483 :                     ;
(2)   15/    9483 :                     ;		Terms are : 	A-Z 			Variables
(2)   16/    9483 :                     ;						[0-9]+			Constants
(2)   17/    9483 :                     ;						! 				Random byte
(2)   18/    9483 :                     ;						'?'				Character constant
(2)   19/    9483 :                     ;						(<expr>,<expr>)	Read Memory location
(2)   20/    9483 :                     ;
(2)   21/    9483 :                     ; ****************************************************************************************************************
(2)   22/    9483 :                     ; ****************************************************************************************************************
(2)   23/    9483 :                     
(2)   24/    9483 : =0x1                EEX_PendingOp = 1 												; offset to pending operation
(2)   25/    9483 : =0x0                EEX_Value = 0 													; offset to value
(2)   26/    9483 :                     
(2)   27/    9483 :                     EvaluateExpression:
(2)   28/    9483 : (MACRO)             	pushp 	p3 													; save P3 on stack
(2)   28/    9483 : 37                          xpah    P3
(2)   28/    9484 : CE FF                       st              @-1(p2)
(2)   28/    9486 : 33                          xpal    P3
(2)   28/    9487 : CE FF                       st              @-1(p2)
(2)   29/    9489 : C4 2B               	ldi 	'+'													; push pending operation on stack
(2)   30/    948B : CE FF               	st 		@-1(p2)
(2)   31/    948D : C4 00               	ldi 	0 													; push current value on stack
(2)   32/    948F : CE FF               	st 		@-1(p2)												; effectively this puts 0+ on the front of the expression.
(2)   33/    9491 :                     
(2)   34/    9491 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 21 - 1/10/2016 11:47:39


(2)   35/    9491 :                     ;													Get Next Term
(2)   36/    9491 :                     ; ****************************************************************************************************************
(2)   37/    9491 :                     
(2)   38/    9491 :                     EEX_Term:
(2)   39/    9491 : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   39/    9491 : C4 0C                       ldi     (VARIABLES) / 256
(2)   39/    9493 : 37                          xpah    P3
(2)   39/    9494 : C4 90                       ldi     (VARIABLES) & 255
(2)   39/    9496 : 33                          xpal    P3
(2)   40/    9497 :                     EEX_NextChar:
(2)   41/    9497 : C1 00               	ld 		(p1) 												; look at character
(2)   42/    9499 : 98 4F               	jz 		EEX_TermError
(2)   43/    949B : C5 01               	ld 		@1(p1) 												; fetch and skip over.
(2)   44/    949D : E4 20               	xri 	' '													; is it space ?
(2)   45/    949F : 98 F6               	jz 		EEX_NextChar
(2)   46/    94A1 : E4 08               	xri 	' '!'('												; is it memory access ?
(2)   47/    94A3 : 98 55               	jz 		EEX_MemoryAccess
(2)   48/    94A5 : E4 09               	xri 	'('!'!'												; is it a random value ?
(2)   49/    94A7 : 9C 1B               	jnz 	EEX_NotRandom
(2)   50/    94A9 :                     
(2)   51/    94A9 :                     ; ****************************************************************************************************************
(2)   52/    94A9 :                     ;												Term is ! (random byte)
(2)   53/    94A9 :                     ; ****************************************************************************************************************
(2)   54/    94A9 :                     
(2)   55/    94A9 :                     EEX_Random:
(2)   56/    94A9 : 02                  	ccl 	
(2)   57/    94AA : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; shift the seed right
(2)   58/    94AC : 1F                  	rrl
(2)   59/    94AD : CB FF               	st 		RandomSeed+1-Variables(p3)
(2)   60/    94AF : 01                  	xae 														; put MSB in E
(2)   61/    94B0 : C3 FE               	ld 		RandomSeed-Variables(p3)
(2)   62/    94B2 : 1F                  	rrl
(2)   63/    94B3 : CB FE               	st 		RandomSeed-Variables(p3)
(2)   64/    94B5 : 60                  	xre 														; XOR E into LSB
(2)   65/    94B6 : 01                  	xae
(2)   66/    94B7 : 06                  	csa 														; if CY/L is zero
(2)   67/    94B8 : D4 80               	ani 	0x80
(2)   68/    94BA : 9C 06               	jnz 	EEX_NoTap 
(2)   69/    94BC : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; XOR MSB with $B4
(2)   70/    94BE : E4 B4               	xri 	0xB4
(2)   71/    94C0 : CB FF               	st 		RandomSeed+1-Variables(p3)
(2)   72/    94C2 :                     EEX_NoTap:
(2)   73/    94C2 : 90 65               	jmp 	EEX_HaveTerm
(2)   74/    94C4 :                     
(2)   75/    94C4 :                     EEX_NotRandom:
(2)   76/    94C4 : E4 06               	xri 	'!'!0x27											; is it a quote ?
(2)   77/    94C6 : 9C 0F               	jnz 	EEX_NotQuote
(2)   78/    94C8 :                     
(2)   79/    94C8 :                     ; ****************************************************************************************************************
(2)   80/    94C8 :                     ;													Term is '<char>'
(2)   81/    94C8 :                     ; ****************************************************************************************************************
(2)   82/    94C8 :                     
(2)   83/    94C8 : C1 00               	ld 		(p1) 												; get character that is quoted
(2)   84/    94CA : 98 1E               	jz 		EEX_TermError 										; if zero, error.
(2)   85/    94CC : 01                  	xae 														; save in E if okay character.
(2)   86/    94CD : C1 01               	ld 		1(p1) 												; get character after that
(2)   87/    94CF : E4 27               	xri 	0x27 												; is it a quote ?
(2)   88/    94D1 : 9C 17               	jnz 	EEX_TermError
(2)   89/    94D3 : C5 02               	ld 		@2(p1) 												; skip over character and quote
(2)   90/    94D5 : 90 52               	jmp 	EEX_HaveTerm 										; and execute as if a legal term
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 22 - 1/10/2016 11:47:39


(2)   91/    94D7 :                     
(2)   92/    94D7 :                     ; ****************************************************************************************************************
(2)   93/    94D7 :                     ;									Not 'x' or !, so test for 0-9 and A-Z
(2)   94/    94D7 :                     ; ****************************************************************************************************************
(2)   95/    94D7 :                     
(2)   96/    94D7 :                     EEX_NotQuote:
(2)   97/    94D7 : C1 FF               	ld 		-1(p1)												; get old character.
(2)   98/    94D9 : 02                  	ccl
(2)   99/    94DA : F4 A5               	adi 	255-'Z'												; if >= 'Z' then error.										
(2)  100/    94DC : 94 0C               	jp 		EEX_TermError
(2)  101/    94DE : F4 1A               	adi 	26 													; will be 0..25 if A..Z
(2)  102/    94E0 : 94 43               	jp 		EEX_Variable 										; so do as a variable.
(2)  103/    94E2 : F4 07               	adi 	'A'-1-'9'											; check if > 9
(2)  104/    94E4 : 94 04               	jp 		EEX_TermError
(2)  105/    94E6 : F4 0A               	adi 	10 													; if 0-9
(2)  106/    94E8 : 94 1D               	jp 		EEX_Constant
(2)  107/    94EA :                     
(2)  108/    94EA :                     ; ****************************************************************************************************************
(2)  109/    94EA :                     ;													 Error Exit.
(2)  110/    94EA :                     ; ****************************************************************************************************************
(2)  111/    94EA :                     
(2)  112/    94EA :                     EEX_TermError:
(2)  113/    94EA : C4 04               	ldi 	ERRC_Term 											; put term error in A
(2)  114/    94EC :                     EEX_Error:
(2)  115/    94EC : 01                  	xae 														; put error code in E
(2)  116/    94ED : 02                  	ccl 														; clear CY/L indicating error
(2)  117/    94EE :                     EEX_Exit:
(2)  118/    94EE : C6 02               	ld 		@2(p2) 												; throw the pending operation and value
(2)  119/    94F0 : (MACRO)             	pullp 	p3 													; restore P3
(2)  119/    94F0 : C6 01                       ld              @1(p2)
(2)  119/    94F2 : 33                          xpal    P3
(2)  119/    94F3 : C6 01                       ld              @1(p2)
(2)  119/    94F5 : 37                          xpah    P3
(2)  120/    94F6 : 06                  	csa 														; put CY/L in A bit 7
(2)  121/    94F7 : 3F                  	xppc 	p3 													; and exit
(2)  122/    94F8 : 90 89               	jmp 	EvaluateExpression 									; make re-entrant
(2)  123/    94FA :                     
(2)  124/    94FA :                     ; ****************************************************************************************************************
(2)  125/    94FA :                     ;										Handle (<expr>,<expr>)
(2)  126/    94FA :                     ; ****************************************************************************************************************
(2)  127/    94FA :                     
(2)  128/    94FA :                     EEX_MemoryAccess:
(2)  129/    94FA : C5 FF               	ld 		@-1(p1) 											; point to the (
(2)  130/    94FC : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; call the evaluate/read of (h,l)
(2)  130/    94FC : C4 95                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)  130/    94FE : 37                          xpah    P3
(2)  130/    94FF : C4 D6                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)  130/    9501 : 33                          xpal    P3
(2)  131/    9502 : 3F                  	xppc 	p3
(2)  132/    9503 : 94 E9               	jp 		EEX_Exit 											; error occurred, so exit with it.
(2)  133/    9505 : 90 22               	jmp 	EEX_HaveTerm
(2)  134/    9507 :                     
(2)  135/    9507 :                     ; ****************************************************************************************************************
(2)  136/    9507 :                     ;								Handle constant, first digit value is in A
(2)  137/    9507 :                     ; ****************************************************************************************************************
(2)  138/    9507 :                     
(2)  139/    9507 :                     EEX_Constant:
(2)  140/    9507 : 01                  	xae 														; put first digit value in E
(2)  141/    9508 :                     EEX_ConstantLoop:
(2)  142/    9508 : C1 00               	ld 		(p1) 												; get next character.
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 23 - 1/10/2016 11:47:39


(2)  143/    950A : 02                  	ccl
(2)  144/    950B : F4 C6               	adi 	255-'9' 											; if >= 9 term is too large.
(2)  145/    950D : 94 1A               	jp 		EEX_HaveTerm
(2)  146/    950F : F4 8A               	adi 	10+128
(2)  147/    9511 : 94 16               	jp 		EEX_HaveTerm
(2)  148/    9513 : 02                  	ccl
(2)  149/    9514 : 40                  	lde 														; A = n
(2)  150/    9515 : 70                  	ade 														; A = n * 2
(2)  151/    9516 : 70                  	ade 														; A = n * 3
(2)  152/    9517 : 70                  	ade 														; A = n * 4
(2)  153/    9518 : 70                  	ade 														; A = n * 5
(2)  154/    9519 : 01                  	xae 														; E = n * 5
(2)  155/    951A : 40                  	lde 														; A = n * 5
(2)  156/    951B : 70                  	ade 														; A = n * 10
(2)  157/    951C : 01                  	xae
(2)  158/    951D : C5 01               	ld 		@1(p1) 												; read character convert to number
(2)  159/    951F : D4 0F               	ani 	0x0F
(2)  160/    9521 : 70                  	ade
(2)  161/    9522 : 01                  	xae
(2)  162/    9523 : 90 E3               	jmp 	EEX_ConstantLoop
(2)  163/    9525 :                     
(2)  164/    9525 :                     
(2)  165/    9525 :                     ; ****************************************************************************************************************
(2)  166/    9525 :                     ;									Access variable, variable id (0-25) in A
(2)  167/    9525 :                     ; ****************************************************************************************************************
(2)  168/    9525 :                     
(2)  169/    9525 :                     EEX_Variable:
(2)  170/    9525 : 01                  	xae 														; put value 0-25 in E
(2)  171/    9526 : C3 80               	ld 		-0x80(p3) 											; load using E as index
(2)  172/    9528 : 01                  	xae 														; put in E
(2)  173/    9529 :                     
(2)  174/    9529 :                     ; ****************************************************************************************************************
(2)  175/    9529 :                     ;										Have the right term in E, process it
(2)  176/    9529 :                     ; ****************************************************************************************************************
(2)  177/    9529 :                     
(2)  178/    9529 :                     EEX_HaveTerm:
(2)  179/    9529 : C2 01               	ld 		EEX_PendingOp(p2) 									; get pending operation.
(2)  180/    952B : E4 2B               	xri 	'+'
(2)  181/    952D : 9C 06               	jnz 	EEX_NotAdd
(2)  182/    952F :                     
(2)  183/    952F :                     ; ****************************************************************************************************************
(2)  184/    952F :                     ;												Add Right Term to Value
(2)  185/    952F :                     ; ****************************************************************************************************************
(2)  186/    952F : 02                  	ccl
(2)  187/    9530 : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  188/    9532 : 70                  	ade 														; add right
(2)  189/    9533 : 90 08               	jmp 	EEX_SaveAndExit 									; save and exit
(2)  190/    9535 :                     
(2)  191/    9535 :                     EEX_NotAdd:
(2)  192/    9535 : E4 06               	xri 	'+'!'-'
(2)  193/    9537 : 9C 12               	jnz		EEX_NotSubtract
(2)  194/    9539 :                     
(2)  195/    9539 :                     ; ****************************************************************************************************************
(2)  196/    9539 :                     ;											 Subtract Right Term from Value
(2)  197/    9539 :                     ; ****************************************************************************************************************
(2)  198/    9539 : 03                  	scl
(2)  199/    953A : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  200/    953C : 78                  	cae 														; subtract right
(2)  201/    953D :                     EEX_SaveAndExit:
(2)  202/    953D : CA 00               	st 		EEX_Value(p2) 										; save value back
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 24 - 1/10/2016 11:47:39


(2)  203/    953F : 90 30               	jmp 	EEX_CheckNextOperation 								; and exit, look for next operator.
(2)  204/    9541 :                     
(2)  205/    9541 :                     EEX_Divide_Zero:												; handle divide by zero error.
(2)  206/    9541 : C4 07               	ldi 	ERRC_DivZero
(2)  207/    9543 : 90 A7               	jmp 	EEX_Error
(2)  208/    9545 :                     
(2)  209/    9545 :                     EEX_EndExpression:
(2)  210/    9545 : C2 00               	ld 		EEX_Value(p2) 										; get current value
(2)  211/    9547 : 01                  	xae 														; put in E
(2)  212/    9548 : 03                  	scl 														; set CY/L indicating expression okay.
(2)  213/    9549 : 90 A3               	jmp 	EEX_Exit 											; and exit.
(2)  214/    954B :                     
(2)  215/    954B :                     EEX_NotSubtract:
(2)  216/    954B : E4 07               	xri 	'-'!'*'
(2)  217/    954D : 9C 45               	jnz 	EEX_Divide
(2)  218/    954F :                     
(2)  219/    954F :                     ; ****************************************************************************************************************
(2)  220/    954F :                     ;											 Multiply Right Term into Value
(2)  221/    954F :                     ; ****************************************************************************************************************
(2)  222/    954F :                     
(2)  223/    954F : C2 00               	ld 		EEX_Value(p2) 										; a = left value
(2)  224/    9551 : CA 01               	st 		1(p2)
(2)  225/    9553 : C4 00               	ldi 	0													; res = 0(p2)
(2)  226/    9555 : CA 00               	st 		0(p2) 												; clear it.
(2)  227/    9557 :                     EEX_MultiplyLoop:
(2)  228/    9557 : 40                  	lde  														; if B == 0 then we are done.
(2)  229/    9558 : 98 17               	jz 		EEX_CheckNextOperation
(2)  230/    955A : D4 01               	ani 	1 													; if B LSB is non zero.
(2)  231/    955C : 98 07               	jz 		EEX_Multiply_B0IsZero
(2)  232/    955E : C2 00               	ld 		0(p2) 												; add A to Result
(2)  233/    9560 : 02                  	ccl
(2)  234/    9561 : F2 01               	add 	1(p2)
(2)  235/    9563 : CA 00               	st 		0(p2)
(2)  236/    9565 :                     EEX_Multiply_B0IsZero:
(2)  237/    9565 : 40                  	lde 														; shift B right
(2)  238/    9566 : 1C                  	sr
(2)  239/    9567 : 01                  	xae
(2)  240/    9568 : C2 01               	ld 		1(p2) 												; shift A left
(2)  241/    956A : 02                  	ccl
(2)  242/    956B : F2 01               	add 	1(p2)
(2)  243/    956D : CA 01               	st 		1(p2)
(2)  244/    956F : 90 E6               	jmp 	EEX_MultiplyLoop
(2)  245/    9571 :                     
(2)  246/    9571 :                     ; ****************************************************************************************************************
(2)  247/    9571 :                     ;											Check next operation
(2)  248/    9571 :                     ; ****************************************************************************************************************
(2)  249/    9571 :                     
(2)  250/    9571 :                     EEX_CheckNextOperation:
(2)  251/    9571 : C5 01               	ld 		@1(p1)												; skip over spaces
(2)  252/    9573 : E4 20               	xri 	' '
(2)  253/    9575 : 98 FA               	jz 		EEX_CheckNextOperation
(2)  254/    9577 : C5 FF               	ld 		@-1(p1)												; get operator
(2)  255/    9579 : E4 2B               	xri 	'+'													; check if + - * /
(2)  256/    957B : 98 0C               	jz 		EEX_FoundOperator
(2)  257/    957D : E4 06               	xri 	'+'!'-'
(2)  258/    957F : 98 08               	jz 		EEX_FoundOperator
(2)  259/    9581 : E4 07               	xri 	'-'!'*'
(2)  260/    9583 : 98 04               	jz 		EEX_FoundOperator
(2)  261/    9585 : E4 05               	xri 	'*'!'/'
(2)  262/    9587 : 9C BC               	jnz 	EEX_EndExpression
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 25 - 1/10/2016 11:47:39


(2)  263/    9589 :                     
(2)  264/    9589 :                     EEX_FoundOperator:
(2)  265/    9589 : C5 01               	ld  	@1(p1) 												; get and skip operator
(2)  266/    958B : CA 01               	st 		EEX_PendingOp(p2)									; save then pending operator
(2)  267/    958D : (MACRO)             	lpi 	p3,EEX_Term-1
(2)  267/    958D : C4 94                       ldi     (EEX_TERM-1) / 256
(2)  267/    958F : 37                          xpah    P3
(2)  267/    9590 : C4 90                       ldi     (EEX_TERM-1) & 255
(2)  267/    9592 : 33                          xpal    P3
(2)  268/    9593 : 3F                  	xppc 	p3
(2)  269/    9594 :                     
(2)  270/    9594 :                     ; ****************************************************************************************************************
(2)  271/    9594 :                     ;											 Divide Right Term into Value
(2)  272/    9594 :                     ; ****************************************************************************************************************
(2)  273/    9594 :                     
(2)  274/    9594 :                     EEX_Divide:
(2)  275/    9594 : 40                  	lde 														; if denominator zero, error 2.
(2)  276/    9595 : 98 AA               	jz 		EEX_Divide_Zero
(2)  277/    9597 : C2 00               	ld 		0(p2) 												; numerator into 1(p2)
(2)  278/    9599 : CA 01               	st 		1(p2) 												; denominator is in E
(2)  279/    959B : C4 00               	ldi 	0
(2)  280/    959D : CA 00               	st 		0(p2)												; quotient in 0(p2)
(2)  281/    959F : CA FF               	st 		-1(p2) 												; remainder in -1(p2)
(2)  282/    95A1 : C4 80               	ldi 	0x80 									
(2)  283/    95A3 : CA FE               	st 		-2(p2) 												; bit in -2(p2)
(2)  284/    95A5 :                     
(2)  285/    95A5 :                     EEX_Divide_Loop:
(2)  286/    95A5 : C2 FE               	ld 		-2(p2) 												; exit if bit = 0,we've finished.
(2)  287/    95A7 : 98 C8               	jz 		EEX_CheckNextOperation
(2)  288/    95A9 :                     
(2)  289/    95A9 : 02                  	ccl 	 													; shift remainder left.
(2)  290/    95AA : C2 FF               	ld 		-1(p2)
(2)  291/    95AC : F2 FF               	add 	-1(p2)
(2)  292/    95AE : CA FF               	st 		-1(p2)
(2)  293/    95B0 :                     
(2)  294/    95B0 : C2 01               	ld 		1(p2)												; get numerator.
(2)  295/    95B2 : 94 02               	jp 		EEX_Divide_Numerator_Positive
(2)  296/    95B4 : AA FF               	ild 	-1(p2)  											; if numerator -ve, increment remainder.
(2)  297/    95B6 :                     EEX_Divide_Numerator_Positive:
(2)  298/    95B6 :                     
(2)  299/    95B6 : C2 FF               	ld 		-1(p2) 												; calculate remainder - denominator
(2)  300/    95B8 : 03                  	scl
(2)  301/    95B9 : 78                  	cae 
(2)  302/    95BA : CA FD               	st 		-3(p2) 												; save in temp -3(p2)
(2)  303/    95BC : 06                  	csa 														; if temp >= 0, CY/L is set
(2)  304/    95BD : 94 0A               	jp 		EEX_Divide_Temp_Positive
(2)  305/    95BF :                     
(2)  306/    95BF : C2 FD               	ld 		-3(p2) 												; copy temp to remainder
(2)  307/    95C1 : CA FF               	st 		-1(p2)
(2)  308/    95C3 : C2 FE               	ld 		-2(p2) 												; or bit into quotient
(2)  309/    95C5 : DA 00               	or 		0(p2)
(2)  310/    95C7 : CA 00               	st 		0(p2)
(2)  311/    95C9 :                     EEX_Divide_Temp_Positive:
(2)  312/    95C9 : C2 FE               	ld 		-2(p2) 												; shift bit right
(2)  313/    95CB : 1C                  	sr
(2)  314/    95CC : CA FE               	st 		-2(p2)
(2)  315/    95CE :                     
(2)  316/    95CE : C2 01               	ld 		1(p2)												; shift numerator positive
(2)  317/    95D0 : 02                  	ccl
(2)  318/    95D1 : F2 01               	add 	1(p2)
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 26 - 1/10/2016 11:47:39


(2)  319/    95D3 : CA 01               	st 		1(p2)
(2)  320/    95D5 : 90 CE               	jmp 	EEX_Divide_Loop
(2)  321/    95D7 :                     
(2)  322/    95D7 :                     ; ****************************************************************************************************************
(2)  323/    95D7 :                     ; ****************************************************************************************************************
(2)  324/    95D7 :                     ;
(2)  325/    95D7 :                     ;	Evaluate an address pair at P1 e.g. (<expr>,<expr>).  Returns as for expression, but stack-2, stack-1 are
(2)  326/    95D7 :                     ;	the address (the data at that address is in E if no error occurs). Used for reading and writing.
(2)  327/    95D7 :                     ;
(2)  328/    95D7 :                     ; ****************************************************************************************************************
(2)  329/    95D7 :                     ; ****************************************************************************************************************
(2)  330/    95D7 :                     
(2)  331/    95D7 :                     EvaluateAddressPair:
(2)  332/    95D7 : C6 FE               	ld 		@-2(p2)												; make space to store HL
(2)  333/    95D9 : (MACRO)             	pushp 	p3 													; save return address.
(2)  333/    95D9 : 37                          xpah    P3
(2)  333/    95DA : CE FF                       st              @-1(p2)
(2)  333/    95DC : 33                          xpal    P3
(2)  333/    95DD : CE FF                       st              @-1(p2)
(2)  334/    95DF : C1 00               	ld 		(p1) 												; check first is '(', exit with term error if not
(2)  335/    95E1 : E4 28               	xri 	'('
(2)  336/    95E3 : 9C 2E               	jnz 	EAP_Error
(2)  337/    95E5 : C5 01               	ld 		@1(p1)												; skip over it.
(2)  338/    95E7 : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; evaluate H
(2)  338/    95E7 : C4 94                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)  338/    95E9 : 37                          xpah    P3
(2)  338/    95EA : C4 82                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)  338/    95EC : 33                          xpal    P3
(2)  339/    95ED : 3F                  	xppc 	p3
(2)  340/    95EE : 94 27               	jp 		EAP_Exit 											; exit if failed
(2)  341/    95F0 : 40                  	lde 														; store H at 3(P2)
(2)  342/    95F1 : CA 03               	st 		3(p2)
(2)  343/    95F3 : C1 00               	ld 		(p1) 												; check for ','
(2)  344/    95F5 : E4 2C               	xri 	','
(2)  345/    95F7 : 9C 1A               	jnz 	EAP_Error											; fail if not present
(2)  346/    95F9 : C5 01               	ld 		@1(p1)												; skip over comma
(2)  347/    95FB : 3F                  	xppc 	p3 													; evaluate L
(2)  348/    95FC : 94 19               	jp 		EAP_Exit 											; exit on error
(2)  349/    95FE : 40                  	lde 														; store L at 2(P2)
(2)  350/    95FF : CA 02               	st 		2(p2)
(2)  351/    9601 : 33                  	xpal 	p3 													; and put in P3.L for later
(2)  352/    9602 : C1 00               	ld 		(p1) 												; check for ')'
(2)  353/    9604 : E4 29               	xri 	')'
(2)  354/    9606 : 9C 0B               	jnz 	EAP_Error
(2)  355/    9608 : C5 01               	ld 		@1(p1) 												; skip over close bracket
(2)  356/    960A : C2 03               	ld 		3(p2) 												; put 3(P2) in P3.H
(2)  357/    960C : 37                  	xpah 	p3
(2)  358/    960D : C3 00               	ld 		(p3) 												; read address
(2)  359/    960F : 01                  	xae 														; put in E
(2)  360/    9610 : 03                  	scl 														; set carry to indicate okay
(2)  361/    9611 : 90 04               	jmp 	EAP_Exit 											; and exit.
(2)  362/    9613 :                     ;
(2)  363/    9613 :                     EAP_Error:
(2)  364/    9613 : C4 04               	ldi 	ERRC_TERM 											; set error up
(2)  365/    9615 : 01                  	xae
(2)  366/    9616 : 02                  	ccl
(2)  367/    9617 :                     ;
(2)  368/    9617 :                     EAP_Exit:														; exit
(2)  369/    9617 : (MACRO)             	pullp 	p3 													; restore P3
(2)  369/    9617 : C6 01                       ld              @1(p2)
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 27 - 1/10/2016 11:47:39


(2)  369/    9619 : 33                          xpal    P3
(2)  369/    961A : C6 01                       ld              @1(p2)
(2)  369/    961C : 37                          xpah    P3
(2)  370/    961D : C6 02               	ld 		@2(p2) 												; drop the H L address store
(2)  371/    961F : 06                  	csa 														; A bit 7 = CY/L
(2)  372/    9620 : 3F                  	xppc 	p3
(2)  373/    9621 :                     
(2)  374/    9621 :                     
(1)  142/    9621 :                     
(1)  143/    9621 :                     ; ****************************************************************************************************************
(1)  144/    9621 :                     ;		Command look up table - should be ordered by degree of usage, and OS things (e.g. LIST) at the end
(1)  145/    9621 :                     ; ****************************************************************************************************************
(1)  146/    9621 :                     
(1)  147/    9621 :                     CommandList:
(1)  148/    9621 : (MACRO)             	cmd 	'L','E',3,CMD_Let 									; LET var|(h,l) = <expr>
(1)  148/    9621 : 4C 45                       db              'L','E'                                                                                           ; first and second characters
(1)  148/    9623 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  148/    9624 : 3A 93                       dw              (CMD_LET)-1                                                                                        ; execution point for prefetch.
(1)  149/    9626 : (MACRO)             	cmd 	'I','F',2,CMD_If 									; If [expr][=|#|<][expr]; [statement]
(1)  149/    9626 : 49 46                       db              'I','F'                                                                                           ; first and second characters
(1)  149/    9628 : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  149/    9629 : 8D 93                       dw              (CMD_IF)-1                                                                                        ; execution point for prefetch.
(1)  150/    962B : (MACRO)             	cmd 	'G','O',4,CMD_Goto									; GOTO [line number]
(1)  150/    962B : 47 4F                       db              'G','O'                                                                                           ; first and second characters
(1)  150/    962D : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  150/    962E : DC 93                       dw              (CMD_GOTO)-1                                                                                        ; execution point for prefetch.
(1)  151/    9630 : (MACRO)             	cmd 	'C','A',4,CMD_Call									; CALL (high,low)
(1)  151/    9630 : 43 41                       db              'C','A'                                                                                           ; first and second characters
(1)  151/    9632 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  151/    9633 : 11 93                       dw              (CMD_CALL)-1                                                                                        ; execution point for prefetch.
(1)  152/    9635 : (MACRO)             	cmd 	'C','L',5,CMD_Clear									; CLEAR
(1)  152/    9635 : 43 4C                       db              'C','L'                                                                                           ; first and second characters
(1)  152/    9637 : 04                          db              (5)-1                                                                                      ; 5 -1 (first char already skipped)
(1)  152/    9638 : FC 92                       dw              (CMD_CLEAR)-1                                                                                        ; execution point for prefetch.
(1)  153/    963A : (MACRO)             	cmd 	'E','N',3,CMD_End 									; END
(1)  153/    963A : 45 4E                       db              'E','N'                                                                                           ; first and second characters
(1)  153/    963C : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  153/    963D : F6 92                       dw              (CMD_END)-1                                                                                        ; execution point for prefetch.
(1)  154/    963F : (MACRO)             	cmd 	'N','E',3,CMD_New 									; NEW
(1)  154/    963F : 4E 45                       db              'N','E'                                                                                           ; first and second characters
(1)  154/    9641 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  154/    9642 : EC 92                       dw              (CMD_NEW)-1                                                                                        ; execution point for prefetch.
(1)  155/    9644 : (MACRO)             	cmd 	'R','U',3,CMD_Run									; RUN
(1)  155/    9644 : 52 55                       db              'R','U'                                                                                           ; first and second characters
(1)  155/    9646 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  155/    9647 : FD 93                       dw              (CMD_RUN)-1                                                                                        ; execution point for prefetch.
(1)  156/    9649 : (MACRO)             	cmd 	'O','S',2,CMD_OS 									; OS
(1)  156/    9649 : 4F 53                       db              'O','S'                                                                                           ; first and second characters
(1)  156/    964B : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  156/    964C : E3 92                       dw              (CMD_OS)-1                                                                                        ; execution point for prefetch.
(1)  157/    964E : 00                  	db 		0
(1)  158/    964F :                     
(1)  159/    964F :                     ; Done:	GOTO, RUN, CLEAR, NEW, END, OS, CALL, LET (and optional version),IF
(1)  160/    964F :                     ; Not Done: PR,IN,LIST
      59/    964F :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 28 - 1/10/2016 11:47:39


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
 BOOTMONITOR :                  210 - | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CCA_OVER :                    9339 C |
 CCL_LOOP :                    9307 C |  CCL_OVER :                    9310 C |
 CHECKLASTCOMMANDTHENEXECUTE : 9413 C |  CIF_CONTINUE :                93A5 C |
 CIF_EQUALITY :                93C1 C |  CIF_EQUALITY2 :               93C8 C |
 CIF_OVER :                    93DB C |  CIF_SYNTAX :                  939F C |
 CIF_TESTIFZERO :              93CE C |  CLE_EVALUATEANDWRITE :        936C C |
 CLE_ISHL :                    9361 C |  CLE_OVER :                    938C C |
 CLE_SINGLEVARIABLE :          9352 C |  CLE_SYNTAX :                  934C C |
 CMD_CALL :                    9312 C |  CMD_CLEAR :                   92FD C |
 CMD_END :                     92F7 C |  CMD_GOTO :                    93DD C |
 CMD_IF :                      938E C |  CMD_LET :                     933B C |
 CMD_NEW :                     92ED C |  CMD_OS :                      92E4 C |
 CMD_RUN :                     93FE C |  CNE_OVER :                    92FB C |
 COMMANDLIST :                 9621 C | *CONSTPI :        3.141592653589793 - |
 COS_OVER :                    92EB C |  CRG_EXECUTEFROMP1 :           9404 C |
 CRG_FIND :                    93E9 C |  CRG_NOTEND :                  93F3 C |
 CRG_OVER :                    9406 C |  CURRENTLINE :                  C8D - |
*DATE :                   1/10/2016 - |  EAFD_LETCODE :                9478 C |
 EAFD_SEARCH :                 9448 C |  EAFD_SKIP :                   9459 C |
 EAFD_SKIPSPACES :             9465 C |  EAP_ERROR :                   9613 C |
 EAP_EXIT :                    9617 C |  EEX_CHECKNEXTOPERATION :      9571 C |
 EEX_CONSTANT :                9507 C |  EEX_CONSTANTLOOP :            9508 C |
 EEX_DIVIDE :                  9594 C |  EEX_DIVIDE_LOOP :             95A5 C |
 EEX_DIVIDE_NUMERATOR_POSITIVE :                                       95B6 C |
 EEX_DIVIDE_TEMP_POSITIVE :    95C9 C |  EEX_DIVIDE_ZERO :             9541 C |
 EEX_ENDEXPRESSION :           9545 C |  EEX_ERROR :                   94EC C |
 EEX_EXIT :                    94EE C |  EEX_FOUNDOPERATOR :           9589 C |
 EEX_HAVETERM :                9529 C |  EEX_MEMORYACCESS :            94FA C |
 EEX_MULTIPLYLOOP :            9557 C |  EEX_MULTIPLY_B0ISZERO :       9565 C |
 EEX_NEXTCHAR :                9497 C |  EEX_NOTADD :                  9535 C |
 EEX_NOTAP :                   94C2 C |  EEX_NOTQUOTE :                94D7 C |
 EEX_NOTRANDOM :               94C4 C |  EEX_NOTSUBTRACT :             954B C |
 EEX_PENDINGOP :                  1 - | *EEX_RANDOM :                  94A9 C |
 EEX_SAVEANDEXIT :             953D C |  EEX_TERM :                    9491 C |
 EEX_TERMERROR :               94EA C |  EEX_VALUE :                      0 - |
 EEX_VARIABLE :                9525 C | *ENDOFCOMMANDEXECUTION :       9406 C |
 ERRC_DIVZERO :                   7 - |  ERRC_END :                      FF - |
 ERRC_LABEL :                     1 - | *ERRC_MEMORY :                    6 - |
 ERRC_SYNTAX :                    5 - |  ERRC_TERM :                      4 - |
*ERRC_UNKNOWN :                   2 - |  EVALUATEADDRESSPAIR :         95D7 C |
 EVALUATEEXPRESSION :          9483 C |  EXECUTEFROMADDRESSDIRECT :    942F C |
 EXECUTEFROMCOMMANDSTART :     9423 C |  EXECUTENEXTINSTRUCTION :      9409 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
 GETCHAR :                     9256 C |  GETSTRING :                   927A C |
 GOTOCOMMANDLINE :             941B C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*LISTON :                         1 - | *MACEXP :                         1 - |
*MOMCPU :                         C - | *MOMCPUNAME :                 SC/MP - |
*NESTMAX :                      100 - | *OSMATHLIBRARY :                  3 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PRINT :                       9196 C | *PRINTINTEGER :                913A C |
 PROGRAMBASE :                 9016 C |  RANDOMSEED :                   C8E - |
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 29 - 1/10/2016 11:47:39


*RELAXED :                        0 - |  SCREENCURSOR :                 C80 - |
 SCREENMIRROR :                 C00 - |  SYNTAXERROR :                 941D C |
 SYSTEMMEMORY :                 C90 - | *TIME :                    11:47:39 - |
*TRUE :                           1 - |  VARIABLES :                    C90 - |
*VERSION :                     142F - |  WAIT1 :                       9014 C |
 __GCNOTLOWER [GETCHAR] :      9275 C |  __GCWAITKEY [GETCHAR] :       925B C |
 __GCWAITRELEASE [GETCHAR] :   9263 C |  __GSBACKSPACE [GETSTRING] :   92D5 C |
 __GSCONTROLKEY [GETSTRING] :  92B8 C |  __GSLOOP [GETSTRING] :        9288 C |
 __PIDIVIDEEND :               916B C |  __PIDIVIDELOOP :              914E C |
 __PIDIVIDEOUTER :             9148 C |  __PIEXIT :                    918D C |
 __PIPRINT :                   9180 C |  __PRCLEARFROMMOVETO [PRINT] : 9236 C |
 __PRCLEARLOOP [PRINT] :       9238 C |  __PRCLEARSCREEN [PRINT] :     9234 C |
 __PRCOPY [PRINT] :            9242 C |  __PREXIT [PRINT] :            91F9 C |
 __PREXITNOCHECK [PRINT] :     91FD C |  __PRISCONTROLCHAR [PRINT] :   920B C |
 __PRISRETURN [PRINT] :        922B C |  __PRNOTASCII [PRINT] :        91D3 C |
 __PRPRINTCHARACTERA [PRINT] : 91B7 C |  __PRPRINTSTRING [PRINT] :     91A5 C |
 __PRSCROLLLOOP [PRINT] :      91EB C |  __PRUPDATECURSOR [PRINT] :    91DC C |

    147 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 30 - 1/10/2016 11:47:39


  defined macros:
  ---------------

CMD                                   | CODE                                 
LPI                                   | PULLA                                
PULLE                                 | PULLP                                
PUSHA                                 | PUSHE                                
PUSHP                                 | SETV                                 

     10 macros

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 31 - 1/10/2016 11:47:39


  codepages:
  ----------

STANDARD (0 changed characters)


0.03 seconds assembly time

   1368 lines source file
   1577 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
