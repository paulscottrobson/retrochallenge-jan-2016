 AS V1.42 Beta [Bld 102] - source file minol.asm - page 1 - 1/16/2016 12:24:34


       1/       0 :                     ; ****************************************************************************************************************
       2/       0 :                     ; ****************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;												Minol ROM Image
       5/       0 :                     ;
       6/       0 :                     ; ****************************************************************************************************************
       7/       0 :                     ; ****************************************************************************************************************
       8/       0 :                     
       9/       0 :                     	cpu 	sc/mp
      10/       0 :                     
      11/       0 :                     	include source\memorymacros.asm 							; Memory allocation and Macro definition.	
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;										Memory and Macro Allocation.
(1)    5/       0 :                     ;	
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0x3                OSMathLibrary = 0x0003 											; the Maths library is here.
(1)   10/       0 : =0x210              BootMonitor = 0x210 											; address to boot monitor
(1)   11/       0 :                     
(1)   12/       0 :                     ; ****************************************************************************************************************
(1)   13/       0 :                     ;												 Memory Allocation
(1)   14/       0 :                     ; ****************************************************************************************************************
(1)   15/       0 :                     
(1)   16/       0 : =0xC00              ScreenMirror = 0xC00 											; Screen mirror, 128 bytes, 256 byte page boundary.
(1)   17/       0 : =0xC80              ScreenCursor = ScreenMirror+0x80  								; Position on that screen (00..7F)
(1)   18/       0 :                     
(1)   19/       0 : =0xC90              SystemMemory = 0xC90 											; System Memory
(1)   20/       0 :                     
(1)   21/       0 : =0xC8E              RandomSeed = SystemMemory-2										; Random Seed Value (2 bytes)
(1)   22/       0 : =0xC8D              CurrentLine = SystemMemory-3 									; Current Line Number (1 byte)
(1)   23/       0 : =0xC90              Variables = SystemMemory 										; Variables (26 bytes)
(1)   24/       0 :                     
(1)   25/       0 : =0xCB0              KeyboardBuffer = SystemMemory+32 								; Keyboard input buffer
(1)   26/       0 : =0x48               KeyboardBufferSize = 72 										; Number of characters allowed to be typed in.
(1)   27/       0 :                     
(1)   28/       0 : =0x1004             ProgramBase = 0x1004 											; Program memory here.
(1)   29/       0 :                     
(1)   30/       0 : =0xFD               Marker1 = 	0xFD 												; Markers indicating "Code here"
(1)   31/       0 : =0xB5               Marker2 = 	0xB5
(1)   32/       0 : =0xAE               Marker3 = 	0xAE
(1)   33/       0 : =0x76               Marker4 = 	0x76
(1)   34/       0 :                     
(1)   35/       0 :                     ; ****************************************************************************************************************
(1)   36/       0 :                     ;														Macros
(1)   37/       0 :                     ; ****************************************************************************************************************
(1)   38/       0 :                     
(1)   39/       0 :                     lpi	macro	ptr,addr											; load pointer register with constant
(1)   40/       0 :                     	ldi 	(addr) / 256
(1)   41/       0 :                     	xpah 	ptr
(1)   42/       0 :                     	ldi 	(addr) & 255
(1)   43/       0 :                     	xpal 	ptr
(1)   44/       0 :                     	endm
(1)   45/       0 :                     
(1)   46/       0 :                     pushp macro ptr 												; push pointer register on stack
(1)   47/       0 :                     	xpah 	ptr
(1)   48/       0 :                     	st 		@-1(p2)
(1)   49/       0 :                     	xpal 	ptr
 AS V1.42 Beta [Bld 102] - source file minol.asm(memorymacros.asm) - page 2 - 1/16/2016 12:24:34


(1)   50/       0 :                     	st 		@-1(p2)
(1)   51/       0 :                     	endm
(1)   52/       0 :                     
(1)   53/       0 :                     pullp macro ptr 												; pull pointer register off stack
(1)   54/       0 :                     	ld 		@1(p2)
(1)   55/       0 :                     	xpal 	ptr
(1)   56/       0 :                     	ld 		@1(p2)
(1)   57/       0 :                     	xpah 	ptr
(1)   58/       0 :                     	endm
(1)   59/       0 :                     
(1)   60/       0 :                     pushe macro 													; push E on stack
(1)   61/       0 :                     	lde
(1)   62/       0 :                     	st 		@-1(p2)
(1)   63/       0 :                     	endm
(1)   64/       0 :                     
(1)   65/       0 :                     pulle macro 													; pull E off stack
(1)   66/       0 :                     	ld 		@1(p2)
(1)   67/       0 :                     	xae
(1)   68/       0 :                     	endm
(1)   69/       0 :                     
(1)   70/       0 :                     pusha macro 													; push A on stack
(1)   71/       0 :                     	st 		@-1(p2)
(1)   72/       0 :                     	endm
(1)   73/       0 :                     
(1)   74/       0 :                     pulla macro
(1)   75/       0 :                     	ld 		@1(p2)
(1)   76/       0 :                     	endm
(1)   77/       0 :                     
(1)   78/       0 :                     setv macro ch,value 											; sets a variable to a value, assumes P3 = Variables.
(1)   79/       0 :                     	ldi 	(value) & 255
(1)   80/       0 :                     	st 		((ch) - 'A')(p3)
(1)   81/       0 :                     	endm
(1)   82/       0 :                     
(1)   83/       0 :                     code macro lineNo,code 											; a debugging macro, which fakes up a line of code.
(1)   84/       0 :                     	db 		strlen(code)+3 										; one byte offset to next (255 = End of code)
(1)   85/       0 :                     	db 		lineNo 												; one byte line number 
(1)   86/       0 :                     	db 		code,0 												; ASCIIZ string
(1)   87/       0 :                     	endm
(1)   88/       0 :                     
(1)   89/       0 :                     cmd macro 	c1,c2,length,code
(1)   90/       0 :                     	db 		c1,c2 												; first and second characters
(1)   91/       0 :                     	db 		(length)-1											; length -1 (first char already skipped)
(1)   92/       0 :                     	dw 		(code)-1 											; execution point for prefetch.
(1)   93/       0 :                     	endm
      12/       0 :                     	include source\errors.asm 									; Error codes
(1)    1/       0 :                     ; ****************************************************************************************************************
(1)    2/       0 :                     ; ****************************************************************************************************************
(1)    3/       0 :                     ;
(1)    4/       0 :                     ;												Error Codes
(1)    5/       0 :                     ;
(1)    6/       0 :                     ; ****************************************************************************************************************
(1)    7/       0 :                     ; ****************************************************************************************************************
(1)    8/       0 :                     
(1)    9/       0 : =0xFF               ERRC_END = 0xFF													; psuedo error, program stopped. Does "OK" as for no error.
(1)   10/       0 : =0x31               ERRC_LABEL = '1' 												; Label does not exist (e.g. GOTO)
(1)   11/       0 : =0x32               ERRC_UNKNOWN = '2'												; Unknown instruction
(1)   12/       0 : =0x34               ERRC_TERM = '4' 												; Illegal term/expression
(1)   13/       0 : =0x35               ERRC_SYNTAX = '5'												; Syntax Error
(1)   14/       0 : =0x36               ERRC_MEMORY = '6' 												; Out of memory
(1)   15/       0 : =0x37               ERRC_DIVZERO = '7' 												; Division by Zero Error.
 AS V1.42 Beta [Bld 102] - source file minol.asm(errors.asm) - page 3 - 1/16/2016 12:24:34


(1)   16/       0 : =0x38               ERRC_BREAK = '8' 												; Break.
      13/       0 :                     
      14/       0 :                     ; ****************************************************************************************************************
      15/       0 :                     ;													Main Program
      16/       0 :                     ; ****************************************************************************************************************
      17/       0 :                     
      18/    9000 :                     	org 	0x9000 												; the ROM starts here
      19/    9000 :                     
      20/    9000 : 68                  	db 		0x68												; this makes it boot straight into this ROM.
      21/    9001 : (MACRO)             	lpi 	p2,0xFFF											; set up top stack value
      21/    9001 : C4 0F                       ldi     (0XFFF) / 256
      21/    9003 : 36                          xpah    P2
      21/    9004 : C4 FF                       ldi     (0XFFF) & 255
      21/    9006 : 32                          xpal    P2
      22/    9007 :                     FindTOS:
      23/    9007 : C4 75               	ldi 	0x75												; can we write there, if so, found TOS.
      24/    9009 : CA 00               	st 		(p2)
      25/    900B : E2 00               	xor 	(p2)
      26/    900D : 98 04               	jz 		StackFound
      27/    900F : C2 C0               	ld 		-64(p2) 											; wind backwards 64 bytes
      28/    9011 : 90 F4               	jmp 	FindTOS	
      29/    9013 :                     StackFound:
      30/    9013 :                     
      31/    9013 : (MACRO)             	lpi 	p3,ProgramCode 										; copy program default code to memory.
      31/    9013 : C4 90                       ldi     (PROGRAMCODE) / 256
      31/    9015 : 37                          xpah    P3
      31/    9016 : C4 80                       ldi     (PROGRAMCODE) & 255
      31/    9018 : 33                          xpal    P3
      32/    9019 : (MACRO)             	lpi 	p1,ProgramBase-4
      32/    9019 : C4 10                       ldi     (PROGRAMBASE-4) / 256
      32/    901B : 35                          xpah    P1
      32/    901C : C4 00                       ldi     (PROGRAMBASE-4) & 255
      32/    901E : 31                          xpal    P1
      33/    901F :                     Copy1:
      34/    901F : C7 01               	ld 		@1(p3)
      35/    9021 : CD 01               	st 		@1(p1)
      36/    9023 : E4 FF               	xri 	0xFF
      37/    9025 : 9C F8               	jnz 	Copy1
      38/    9027 :                     
      39/    9027 : (MACRO)             	lpi 	p3,Print-1											; Print Boot Message
      39/    9027 : C4 91                       ldi     (PRINT-1) / 256
      39/    9029 : 37                          xpah    P3
      39/    902A : C4 50                       ldi     (PRINT-1) & 255
      39/    902C : 33                          xpal    P3
      40/    902D : (MACRO)             	lpi 	p1,BootMessage
      40/    902D : C4 90                       ldi     (BOOTMESSAGE) / 256
      40/    902F : 35                          xpah    P1
      40/    9030 : C4 63                       ldi     (BOOTMESSAGE) & 255
      40/    9032 : 31                          xpal    P1
      41/    9033 : C4 00               	ldi 	0
      42/    9035 : 3F                  	xppc 	p3
      43/    9036 :                     
      44/    9036 : (MACRO)             	lpi 	p3,ProgramBase 										; check to see if MINOL code resident.
      44/    9036 : C4 10                       ldi     (PROGRAMBASE) / 256
      44/    9038 : 37                          xpah    P3
      44/    9039 : C4 04                       ldi     (PROGRAMBASE) & 255
      44/    903B : 33                          xpal    P3
      45/    903C : C3 FC               	ld 		-4(p3) 												; which requires the 4 byte markers to be loaded.
      46/    903E : E4 FD               	xri 	Marker1
      47/    9040 : 9C 1A               	jnz 	RunNew
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 4 - 1/16/2016 12:24:34


      48/    9042 : C3 FD               	ld 		-3(p3) 			
      49/    9044 : E4 B5               	xri 	Marker2
      50/    9046 : 9C 14               	jnz 	RunNew
      51/    9048 : C3 FE               	ld 		-2(p3) 			
      52/    904A : E4 AE               	xri 	Marker3
      53/    904C : 9C 0E               	jnz 	RunNew
      54/    904E : C3 FF               	ld 		-1(p3) 			
      55/    9050 : E4 76               	xri 	Marker4
      56/    9052 : 9C 08               	jnz 	RunNew
      57/    9054 :                     
      58/    9054 : (MACRO)             	lpi 	p3,ConsoleStart-1 									; run the console if code present
      58/    9054 : C4 98                       ldi     (CONSOLESTART-1) / 256
      58/    9056 : 37                          xpah    P3
      58/    9057 : C4 53                       ldi     (CONSOLESTART-1) & 255
      58/    9059 : 33                          xpal    P3
      59/    905A : 03                  	scl 														; non-error (so it prints ok)
      60/    905B : 3F                  	xppc	p3
      61/    905C :                     
      62/    905C :                     RunNew:															; otherwise execute NEW.
      63/    905C : (MACRO)             	lpi 	p3,CMD_New-1
      63/    905C : C4 92                       ldi     (CMD_NEW-1) / 256
      63/    905E : 37                          xpah    P3
      63/    905F : C4 E7                       ldi     (CMD_NEW-1) & 255
      63/    9061 : 33                          xpal    P3
      64/    9062 : 3F                  	xppc 	p3
      65/    9063 :                     
      66/    9063 :                     
      67/    9063 :                     
      68/    9063 :                     BootMessage:
      69/    9063 : 0C 2A 2A 20 4D 49   	db 		12,"** MINOL **",13,"V0.91 PSR 2016",13,0
                    4E 4F 4C 20 2A 2A 
                    0D 56 30 2E 39 31 
                    20 50 53 52 20 32 
                    30 31 36 0D 00 
      70/    9080 :                     
      71/    9080 :                     ProgramCode:
      72/    9080 : FD B5 AE 76         	db 		Marker1,Marker2,Marker3,Marker4
      73/    9084 : (MACRO)             	code 	10,"\"TEST PROGRAM\""
      73/    9084 : 11                          db              strlen("\"TEST PROGRAM\"")+3                                                                          ; one byte offset to next (255 = End of "\"TEST PROGRAM\"")
      73/    9085 : 0A                          db              10                                                                                          ; one byte line number 
      73/    9086 : 22 54 45 53 54 20           db              "\"TEST PROGRAM\"",0                                                                                          ; ASCIIZ string
                    50 52 4F 47 52 41 
                    4D 22 00 
      74/    9095 : (MACRO)             	code 	15,"PR A;:GOTO 15"
      74/    9095 : 10                          db              strlen("PR A;:GOTO 15")+3                                                                          ; one byte offset to next (255 = End of "PR A;:GOTO 15")
      74/    9096 : 0F                          db              15                                                                                          ; one byte line number 
      74/    9097 : 50 52 20 41 3B 3A           db              "PR A;:GOTO 15",0                                                                                          ; ASCIIZ string
                    47 4F 54 4F 20 31 
                    35 00 
      75/    90A5 : (MACRO)             	code 	20,"IN A"
      75/    90A5 : 07                          db              strlen("IN A")+3                                                                          ; one byte offset to next (255 = End of "IN A")
      75/    90A6 : 14                          db              20                                                                                          ; one byte line number 
      75/    90A7 : 49 4E 20 41 00              db              "IN A",0                                                                                          ; ASCIIZ string
      76/    90AC : (MACRO)             	code 	30,"PR A*2"
      76/    90AC : 09                          db              strlen("PR A*2")+3                                                                          ; one byte offset to next (255 = End of "PR A*2")
      76/    90AD : 1E                          db              30                                                                                          ; one byte line number 
      76/    90AE : 50 52 20 41 2A 32           db              "PR A*2",0                                                                                          ; ASCIIZ string
                    00 
      77/    90B5 : (MACRO)             	code 	40,"PR A*A"
      77/    90B5 : 09                          db              strlen("PR A*A")+3                                                                          ; one byte offset to next (255 = End of "PR A*A")
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 5 - 1/16/2016 12:24:34


      77/    90B6 : 28                          db              40                                                                                          ; one byte line number 
      77/    90B7 : 50 52 20 41 2A 41           db              "PR A*A",0                                                                                          ; ASCIIZ string
                    00 
      78/    90BE : (MACRO)             	code 	50,"END"
      78/    90BE : 06                          db              strlen("END")+3                                                                          ; one byte offset to next (255 = End of "END")
      78/    90BF : 32                          db              50                                                                                          ; one byte line number 
      78/    90C0 : 45 4E 44 00                 db              "END",0                                                                                          ; ASCIIZ string
      79/    90C4 : FF                  	db 		255
      80/    90C5 :                     
      81/    90C5 :                     ; ****************************************************************************************************************
      82/    90C5 :                     ;													Source Files
      83/    90C5 :                     ; ****************************************************************************************************************
      84/    90C5 :                     
      85/    90C5 :                     	include source\itoa.asm 									; print integer routine.
(1)    1/    90C5 :                     ; ****************************************************************************************************************
(1)    2/    90C5 :                     ; ****************************************************************************************************************
(1)    3/    90C5 :                     ;
(1)    4/    90C5 :                     ;											Integer (Byte) Printer
(1)    5/    90C5 :                     ;											======================
(1)    6/    90C5 :                     ;	
(1)    7/    90C5 :                     ;	Print Integer in E as String to output routine. Uses stack space as temporary storage. Changes A/E but not
(1)    8/    90C5 :                     ;	P1 or P2. Unsigned.
(1)    9/    90C5 :                     ;	
(1)   10/    90C5 :                     ;	On exit P3 is set up to Print routine.
(1)   11/    90C5 :                     ;
(1)   12/    90C5 :                     ; ****************************************************************************************************************
(1)   13/    90C5 :                     ; ****************************************************************************************************************
(1)   14/    90C5 :                     
(1)   15/    90C5 :                     PrintInteger:
(1)   16/    90C5 : (MACRO)             	pushp 	p3													; save P3
(1)   16/    90C5 : 37                          xpah    P3
(1)   16/    90C6 : CE FF                       st              @-1(p2)
(1)   16/    90C8 : 33                          xpal    P3
(1)   16/    90C9 : CE FF                       st              @-1(p2)
(1)   17/    90CB : C4 FF               	ldi 	0xFF 												; use $FF to mark stack top.
(1)   18/    90CD : CE FF               	st 		@-1(p2)
(1)   19/    90CF : CE FD               	st 		@-3(p2) 											; allocate space for results.
(1)   20/    90D1 : C4 64               	ldi 	100 												; start with 100s
(1)   21/    90D3 :                     __PIDivideOuter:
(1)   22/    90D3 : CA 01               	st 		1(p2) 												; save subtractor at stack (1)
(1)   23/    90D5 : C4 FF               	ldi 	0xFF 												; clear stack (0) (count) to -1 because we pre-increment.
(1)   24/    90D7 : CA 00               	st 		0(p2)
(1)   25/    90D9 :                     __PIDivideLoop:
(1)   26/    90D9 : AA 00               	ild 	0(p2) 												; bump the counter.
(1)   27/    90DB : 40                  	lde 														; get value
(1)   28/    90DC : 03                  	scl 														; subtract divider
(1)   29/    90DD : FA 01               	cad 	1(p2) 												
(1)   30/    90DF : 01                  	xae 														; put back in E
(1)   31/    90E0 : 06                  	csa 														; if no borrow
(1)   32/    90E1 : D4 80               	ani 	0x80
(1)   33/    90E3 : 9C F4               	jnz 	__PIDivideLoop 
(1)   34/    90E5 : 40                  	lde 														; add the divider.
(1)   35/    90E6 : 02                  	ccl
(1)   36/    90E7 : F2 01               	add 	1(p2)
(1)   37/    90E9 : 01                  	xae
(1)   38/    90EA : C2 01               	ld 		1(p2) 												; get the divider back
(1)   39/    90EC : E4 0A               	xri 	10 													; is it 10 ?
(1)   40/    90EE : 98 06               	jz 		__PIDivideEnd 										; we have finished the division bit.
(1)   41/    90F0 : C6 01               	ld 		@1(p2) 												; push stack up one.
(1)   42/    90F2 : C4 0A               	ldi 	10 													; and divide by 10
 AS V1.42 Beta [Bld 102] - source file minol.asm(itoa.asm) - page 6 - 1/16/2016 12:24:34


(1)   43/    90F4 : 90 DD               	jmp 	__PIDivideOuter
(1)   44/    90F6 :                     ;
(1)   45/    90F6 :                     __PIDivideEnd:
(1)   46/    90F6 :                     
(1)   47/    90F6 : 40                  	lde 														; write out the last digit.
(1)   48/    90F7 : CA 01               	st 		1(p2)
(1)   49/    90F9 : (MACRO)             	lpi 	p3,Print-1 											; point P3 to the print routine.
(1)   49/    90F9 : C4 91                       ldi     (PRINT-1) / 256
(1)   49/    90FB : 37                          xpah    P3
(1)   49/    90FC : C4 50                       ldi     (PRINT-1) & 255
(1)   49/    90FE : 33                          xpal    P3
(1)   50/    90FF :                     ;
(1)   51/    90FF :                     ;	Remove leading spaces
(1)   52/    90FF :                     ;
(1)   53/    90FF : C6 FF               	ld 		@-1(p2) 											; look at first digit, if non-zero go to print
(1)   54/    9101 : 9C 08               	jnz 	__PIPrint 
(1)   55/    9103 : C6 01               	ld 		@1(p2) 												; skip it, eliminate trailing zeros.
(1)   56/    9105 : C2 00               	ld 		(p2) 												; now look at second digit
(1)   57/    9107 : 9C 02               	jnz 	__PIPrint 											; skip it, eliminate trailing zeros.
(1)   58/    9109 : C6 01               	ld 		@1(p2)
(1)   59/    910B :                     ;
(1)   60/    910B :                     __PIPrint:
(1)   61/    910B : C6 01               	ld 		@1(p2) 												; read digit
(1)   62/    910D : D4 80               	ani 	0x80												; if found -ve value then exit.
(1)   63/    910F : 9C 07               	jnz 	__PIExit
(1)   64/    9111 : C2 FF               	ld 		-1(p2) 												; re-read it.
(1)   65/    9113 : DC 30               	ori 	'0'													; make ASCII
(1)   66/    9115 : 3F                  	xppc 	p3 													; print it
(1)   67/    9116 : 90 F3               	jmp 	__PIPrint 											; and keep printing.
(1)   68/    9118 :                     ;
(1)   69/    9118 :                     __PIExit:
(1)   70/    9118 : (MACRO)             	pullp 	p3 													; restore P3
(1)   70/    9118 : C6 01                       ld              @1(p2)
(1)   70/    911A : 33                          xpal    P3
(1)   70/    911B : C6 01                       ld              @1(p2)
(1)   70/    911D : 37                          xpah    P3
(1)   71/    911E : 3F                  	xppc 	p3 													; and exit
(1)   72/    911F : 90 30               	jmp 	Print 												; and set up to execute print afterwards.
(1)   73/    9121 :                     
(1)   74/    9121 :                     
      86/    9121 :                     	include source\atoi.asm 									; decode integer routine.
(1)    1/    9121 :                     ; ****************************************************************************************************************
(1)    2/    9121 :                     ; ****************************************************************************************************************
(1)    3/    9121 :                     ;
(1)    4/    9121 :                     ;								Try to extract integer into E. CY/L = 0 Error, P1 data
(1)    5/    9121 :                     ;	
(1)    6/    9121 :                     ; ****************************************************************************************************************
(1)    7/    9121 :                     ; ****************************************************************************************************************
(1)    8/    9121 :                     
(1)    9/    9121 :                     GetConstant:
(1)   10/    9121 : C4 00               	ldi 	0 													; number of characters read, push on stack.
(1)   11/    9123 : CE FF               	st 		@-1(p2)
(1)   12/    9125 : 01                  	xae 														; reset initial value.
(1)   13/    9126 :                     GCO_Loop:
(1)   14/    9126 : C5 01               	ld 		@1(p1) 												; get and bump
(1)   15/    9128 : E4 20               	xri 	' '													; skipping over spaces
(1)   16/    912A : 98 FA               	jz 		GCO_Loop
(1)   17/    912C : C5 FF               	ld 		@-1(p1) 											; get character undoing bump.
(1)   18/    912E : 02                  	ccl
(1)   19/    912F : F4 C6               	adi 	255-'9'												; check range 0-9.
 AS V1.42 Beta [Bld 102] - source file minol.asm(atoi.asm) - page 7 - 1/16/2016 12:24:34


(1)   20/    9131 : 94 17               	jp 		GCO_Exit
(1)   21/    9133 : F4 8A               	adi 	128+10
(1)   22/    9135 : 94 13               	jp 		GCO_Exit
(1)   23/    9137 :                     
(1)   24/    9137 : 02                  	ccl
(1)   25/    9138 : 40                  	lde 														; A = E 														
(1)   26/    9139 : 70                  	ade 														; A = E * 2
(1)   27/    913A : 70                  	ade 														; A = E * 3
(1)   28/    913B : 70                  	ade 														; A = E * 4
(1)   29/    913C : 70                  	ade 														; A = E * 5
(1)   30/    913D : 01                  	xae 														; E = E * 5
(1)   31/    913E : C5 01               	ld 		@1(p1) 												; get character and bump over.
(1)   32/    9140 : D4 0F               	ani 	0x0F 												; make number
(1)   33/    9142 : 02                  	ccl
(1)   34/    9143 : 70                  	ade 														; add E * 5 twice.
(1)   35/    9144 : 70                  	ade
(1)   36/    9145 : 01                  	xae 														; back in E
(1)   37/    9146 : AA 00               	ild 	(p2)												; bump count.
(1)   38/    9148 : 90 DC               	jmp 	GCO_Loop											; try next.
(1)   39/    914A :                     ;
(1)   40/    914A :                     GCO_Exit:
(1)   41/    914A : C6 01               	ld 		@1(p2)												; get count.
(1)   42/    914C : 02                  	ccl
(1)   43/    914D : F4 FF               	adi 	255 												; CY/L will be set if one or more characters read in
(1)   44/    914F : 06                  	csa 														; A contains CY/L flag now
(1)   45/    9150 : 3F                  	xppc 	p3 													; return.
(1)   46/    9151 :                     	
      87/    9151 :                     	include source\screen.asm 									; screen I/O stuff.
(1)    1/    9151 :                     ; ****************************************************************************************************************
(1)    2/    9151 :                     ; ****************************************************************************************************************
(1)    3/    9151 :                     ;
(1)    4/    9151 :                     ;											Screen I/O, VTL-2 ROM
(1)    5/    9151 :                     ;											=====================
(1)    6/    9151 :                     ;
(1)    7/    9151 :                     ;	Provides Character and String Input/Output functionality.
(1)    8/    9151 :                     ;
(1)    9/    9151 :                     ; ****************************************************************************************************************
(1)   10/    9151 :                     ; ****************************************************************************************************************
(1)   11/    9151 :                     
(1)   12/    9151 :                     ; ****************************************************************************************************************
(1)   13/    9151 :                     ; ****************************************************************************************************************
(1)   14/    9151 :                     ;
(1)   15/    9151 :                     ;	Print routine. Prints either character in A, or ASCIIZ string at P1 (if A is zero). Preserves all registers
(1)   16/    9151 :                     ;	except if printing string, P1 points to the character after the NULL terminator.
(1)   17/    9151 :                     ;
(1)   18/    9151 :                     ;	Scrolls automatically. Understands character codes 32-255, 8 (Backspace) 12 (Clear Screen) 13 (Carriage
(1)   19/    9151 :                     ;	Return). Others are currently ignored (except 0, see above). Note L/C values (97....) display those characters
(1)   20/    9151 :                     ;	in the ROM font *not* lower case :)
(1)   21/    9151 :                     ;
(1)   22/    9151 :                     ; ****************************************************************************************************************
(1)   23/    9151 :                     ; ****************************************************************************************************************
(1)   24/    9151 :                     
(1)   25/    9151 :                     Print:
(1)   26/    9151 :                     	section 	Print
(1)   27/    9151 :                     
(1)   28/    9151 : (MACRO)             	pusha														; push registers on stack
(1)   28/    9151 : CE FF                       st              @-1(p2)
(1)   29/    9153 : (MACRO)             	pushp 	p1
(1)   29/    9153 : 35                          xpah    P1
(1)   29/    9154 : CE FF                       st              @-1(p2)
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 8 - 1/16/2016 12:24:34


(1)   29/    9156 : 31                          xpal    P1
(1)   29/    9157 : CE FF                       st              @-1(p2)
(1)   30/    9159 : (MACRO)             	pushe
(1)   30/    9159 : 40                          lde
(1)   30/    915A : CE FF                       st              @-1(p2)
(1)   31/    915C :                     
(1)   32/    915C : C2 03               	ld 		3(p2) 												; read character 
(1)   33/    915E : 9C 12               	jnz 	__PRPrintCharacterA 								; if non zero print it on its own.
(1)   34/    9160 :                     
(1)   35/    9160 :                     __PRPrintString:
(1)   36/    9160 : C2 01               	ld 		1(p2) 												; restore original P1
(1)   37/    9162 : 31                  	xpal 	p1
(1)   38/    9163 : C2 02               	ld 		2(p2)
(1)   39/    9165 : 35                  	xpah 	p1 													; read character at P1.
(1)   40/    9166 : C5 01               	ld 		@1(p1)
(1)   41/    9168 : 01                  	xae 														; save in E.
(1)   42/    9169 : 35                  	xpah 	p1 													; write P1 back.
(1)   43/    916A : CA 02               	st 		2(p2)
(1)   44/    916C : 31                  	xpal 	p1
(1)   45/    916D : CA 01               	st 		1(p2)
(1)   46/    916F : 40                  	lde 														; get character from E
(1)   47/    9170 : 98 46               	jz 		__PRExitNoCheck 									; exit without loop check.
(1)   48/    9172 :                     ;
(1)   49/    9172 :                     ;	Print character in A now ; throughout it is stored in E.
(1)   50/    9172 :                     ;
(1)   51/    9172 :                     __PRPrintCharacterA:
(1)   52/    9172 : 01                  	xae 														; save character in E.
(1)   53/    9173 :                     ;
(1)   54/    9173 :                     ;	Read cursor and set P1 to that address
(1)   55/    9173 :                     ;
(1)   56/    9173 : C4 0C               	ldi 	ScreenCursor/256 									; set P1 to point to screen cursor
(1)   57/    9175 : 35                  	xpah 	p1
(1)   58/    9176 : C4 80               	ldi 	ScreenCursor&255
(1)   59/    9178 : 31                  	xpal 	p1
(1)   60/    9179 : C1 00               	ld 		0(p1) 												; put cursor position in P1.L
(1)   61/    917B : 31                  	xpal 	p1
(1)   62/    917C :                     ;
(1)   63/    917C :                     ;	Check for control
(1)   64/    917C :                     ;
(1)   65/    917C : 40                  	lde 														; look at character
(1)   66/    917D : D4 E0               	ani 	0xE0 												; is it code 0-31
(1)   67/    917F : 98 45               	jz 		__PRIsControlChar
(1)   68/    9181 :                     ;
(1)   69/    9181 :                     ;	Print non-control
(1)   70/    9181 :                     ;
(1)   71/    9181 : 40                  	lde 														; read character
(1)   72/    9182 : 03                  	scl 														; CY/L clear if < 96
(1)   73/    9183 : FC 60               	cai 	96 
(1)   74/    9185 : 06                  	csa 	 	 												; skip if carry set
(1)   75/    9186 : E4 80               	xri 	0x80													
(1)   76/    9188 : 94 04               	jp 		__PRNotASCII
(1)   77/    918A : 40                  	lde 														; if ASCII make 6 bit.
(1)   78/    918B : D4 3F               	ani 	0x3F
(1)   79/    918D : 01                  	xae
(1)   80/    918E :                     __PRNotASCII:
(1)   81/    918E : 40                  	lde 														; get character.
(1)   82/    918F : C9 00               	st 		(p1) 												; save in shadow memory
(1)   83/    9191 : 35                  	xpah 	p1 													; switch to VRAM, preserving A.
(1)   84/    9192 : C4 00               	ldi 	0 													
(1)   85/    9194 : 35                  	xpah 	p1
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 9 - 1/16/2016 12:24:34


(1)   86/    9195 : CD 01               	st 		@1(p1) 												; save in screen memory, advance write position.
(1)   87/    9197 :                     ;
(1)   88/    9197 :                     ;	Write cursor position back from P1.L
(1)   89/    9197 :                     ;
(1)   90/    9197 :                     __PRUpdateCursor:
(1)   91/    9197 : C4 0C               	ldi		ScreenCursor / 256 									; set P1 to point to screen cursor, restore position to P1
(1)   92/    9199 : 35                  	xpah 	p1
(1)   93/    919A : C4 80               	ldi 	ScreenCursor & 255 
(1)   94/    919C : 31                  	xpal 	p1 													; after this, adjusted cursor position is in AC.
(1)   95/    919D : C9 00               	st 		(p1) 												; write back in cursor position
(1)   96/    919F : 94 13               	jp 		__PRExit 											; if position is off the bottom then scroll.
(1)   97/    91A1 :                     ;
(1)   98/    91A1 :                     ;	Scroll display
(1)   99/    91A1 :                     ;
(1)  100/    91A1 : C4 0C               	ldi 	(ScreenMirror+16) / 256 							; point P1 to 2nd line.
(1)  101/    91A3 : 35                  	xpah 	p1
(1)  102/    91A4 : C4 10               	ldi 	(ScreenMirror+16) & 255
(1)  103/    91A6 :                     __PRScrollLoop:
(1)  104/    91A6 : 31                  	xpal 	p1
(1)  105/    91A7 : C1 00               	ld 		0(p1) 												; copy char to previous line
(1)  106/    91A9 : C9 F0               	st 		-16(p1)
(1)  107/    91AB : C5 01               	ld 		@1(p1) 												; bump pointer.
(1)  108/    91AD : 31                  	xpal 	p1
(1)  109/    91AE : 94 F6               	jp 		__PRScrollLoop
(1)  110/    91B0 : C4 70               	ldi 	128-16 												; clear from and move to last line
(1)  111/    91B2 : 90 3D               	jmp 	__PRClearFromMoveTo
(1)  112/    91B4 :                     ;
(1)  113/    91B4 :                     ;	Exit screen drawing routine.
(1)  114/    91B4 :                     ;
(1)  115/    91B4 :                     __PRExit:
(1)  116/    91B4 : C2 03               	ld 		3(p2) 												; if character was zero, loop
(1)  117/    91B6 : 98 A8               	jz 		__PRPrintString 									; back as printing string at P1.
(1)  118/    91B8 :                     __PRExitNoCheck:
(1)  119/    91B8 : (MACRO)             	pulle 														; restore registers
(1)  119/    91B8 : C6 01                       ld              @1(p2)
(1)  119/    91BA : 01                          xae
(1)  120/    91BB : (MACRO)             	pullp 	p1
(1)  120/    91BB : C6 01                       ld              @1(p2)
(1)  120/    91BD : 31                          xpal    P1
(1)  120/    91BE : C6 01                       ld              @1(p2)
(1)  120/    91C0 : 35                          xpah    P1
(1)  121/    91C1 : (MACRO)             	pulla
(1)  121/    91C1 : C6 01                       ld              @1(p2)
(1)  122/    91C3 : 3F                  	xppc 	p3 													; return
(1)  123/    91C4 : 90 8B               	jmp 	Print 												; make re-entrant.
(1)  124/    91C6 :                     ;
(1)  125/    91C6 :                     ;	Check for supported control characters 8 (Backspace) 12 (Clear) 13 (Carriage Return)
(1)  126/    91C6 :                     ;
(1)  127/    91C6 :                     __PRIsControlChar:
(1)  128/    91C6 : 40                  	lde 														; restore character.
(1)  129/    91C7 : E4 0D               	xri 	13 													; carriage return ? (13)
(1)  130/    91C9 : 98 1B               	jz 		__PRIsReturn
(1)  131/    91CB : E4 01               	xri 	13!12 												; form feed ? (12)
(1)  132/    91CD : 98 20               	jz 		__PRClearScreen
(1)  133/    91CF : E4 04               	xri 	12!8 												; backspace ? (8)
(1)  134/    91D1 : 9C E1               	jnz 	__PRExit 
(1)  135/    91D3 :                     ;
(1)  136/    91D3 :                     ;	Handle backspace (8)
(1)  137/    91D3 :                     ;
(1)  138/    91D3 : 31                  	xpal 	p1 													; check cursor position is zero
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 10 - 1/16/2016 12:24:34


(1)  139/    91D4 : 98 DE               	jz 		__PRExit 											; if it is, cannot backspace so exit.
(1)  140/    91D6 : 31                  	xpal 	p1  												; put it back
(1)  141/    91D7 : C5 FF               	ld 		@-1(p1)												; move it back one
(1)  142/    91D9 : C4 20               	ldi 	' '	 												; erase in shadow
(1)  143/    91DB : C9 00               	st 		(p1)
(1)  144/    91DD : C4 00               	ldi 	0 													; point P1 to VRAM
(1)  145/    91DF : 35                  	xpah 	p1
(1)  146/    91E0 : C4 20               	ldi 	' '													; erase in VRAM
(1)  147/    91E2 : C9 00               	st 		(p1)
(1)  148/    91E4 : 90 B1               	jmp 	__PRUpdateCursor 									; and exit
(1)  149/    91E6 :                     ;
(1)  150/    91E6 :                     ;	Handle carriage return (13)
(1)  151/    91E6 :                     ;
(1)  152/    91E6 :                     __PRIsReturn:
(1)  153/    91E6 : 31                  	xpal 	p1 													; cursor position in A
(1)  154/    91E7 : D4 F0               	ani 	0xF0 												; start of current line
(1)  155/    91E9 : 02                  	ccl 														; down one line
(1)  156/    91EA : F4 10               	adi 	0x10 	
(1)  157/    91EC : 31                  	xpal 	p1 													; put it back in P1.
(1)  158/    91ED : 90 A8               	jmp 	__PRUpdateCursor
(1)  159/    91EF :                     ;
(1)  160/    91EF :                     ;	Handle clear screen (12)
(1)  161/    91EF :                     ;
(1)  162/    91EF :                     __PRClearScreen:
(1)  163/    91EF : C4 00               	ldi 	0 													; clear shadow memory from here.
(1)  164/    91F1 :                     ;
(1)  165/    91F1 :                     ;	From position A, clear the memory in the shadow screen to the end, copy the shadow screen to VRAM
(1)  166/    91F1 :                     ;	then use position A as the new cursor position.
(1)  167/    91F1 :                     ;
(1)  168/    91F1 :                     __PRClearFromMoveTo:
(1)  169/    91F1 : CE FF               	st 		@-1(p2) 											; save this position, the cursor goes here.
(1)  170/    91F3 :                     __PRClearLoop:
(1)  171/    91F3 : 31                  	xpal 	p1 													; save position in P1.
(1)  172/    91F4 : C4 20               	ldi 	' '													; write space there.
(1)  173/    91F6 : CD 01               	st 		@1(p1)
(1)  174/    91F8 : 31                  	xpal 	p1
(1)  175/    91F9 : 94 F8               	jp 		__PRClearLoop 										; until reached shadow memory start.
(1)  176/    91FB : C4 00               	ldi 	0 													; now copy shadow memory to screen memory.
(1)  177/    91FD :                     __PRCopy:
(1)  178/    91FD : 31                  	xpal 	p1 													; set up P1.L
(1)  179/    91FE : C4 0C               	ldi 	ScreenMirror/256 									; point to shadow memory.
(1)  180/    9200 : 35                  	xpah 	p1 													
(1)  181/    9201 : C1 00               	ld 		(p1) 												; read shadow memory
(1)  182/    9203 : 35                  	xpah 	p1 													; zero P1.H preserving A
(1)  183/    9204 : C4 00               	ldi 	0
(1)  184/    9206 : 35                  	xpah 	p1
(1)  185/    9207 : CD 01               	st 		@1(p1) 												; save and increment p1
(1)  186/    9209 : 31                  	xpal 	p1 
(1)  187/    920A : 94 F1               	jp 		__PRCopy 											; keep doing till all copied.
(1)  188/    920C : C6 01               	ld 		@1(p2) 												; read cursor position
(1)  189/    920E : 31                  	xpal 	p1 													; put in P1.L
(1)  190/    920F : 90 86               	jmp 	__PRUpdateCursor
(1)  191/    9211 :                     
(1)  192/    9211 :                     	endsection 	Print
(1)  193/    9211 :                     
(1)  194/    9211 :                     ; ****************************************************************************************************************
(1)  195/    9211 :                     ; ****************************************************************************************************************
(1)  196/    9211 :                     ;
(1)  197/    9211 :                     ;		Input a single character into A. Case is converted to Upper. All registers preserved except A
(1)  198/    9211 :                     ;
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 11 - 1/16/2016 12:24:34


(1)  199/    9211 :                     ; ****************************************************************************************************************
(1)  200/    9211 :                     ; ****************************************************************************************************************
(1)  201/    9211 :                     
(1)  202/    9211 :                     GetChar:
(1)  203/    9211 :                     	section 	GetChar
(1)  204/    9211 : C4 08               	ldi 	0x8 												; set P1 to $8xx, and save P1.H
(1)  205/    9213 : 35                  	xpah 	p1
(1)  206/    9214 : CE FF               	st 		@-1(p2)
(1)  207/    9216 :                     __GCWaitKey: 													; wait for key press
(1)  208/    9216 : C1 00               	ld 		0(p1)
(1)  209/    9218 : 94 FC               	jp 		__GCWaitKey
(1)  210/    921A : D4 7F               	ani	 	0x7F 												; throw away the upper bit.
(1)  211/    921C : CA FF               	st 		-1(p2) 												; save it below stack
(1)  212/    921E :                     __GCWaitRelease:
(1)  213/    921E : C1 00               	ld 		0(p1) 												; wait for release
(1)  214/    9220 : D4 80               	ani 	0x80
(1)  215/    9222 : 9C FA               	jnz 	__GCWaitRelease
(1)  216/    9224 : C6 01               	ld 		@1(p2) 												; restore P1.H
(1)  217/    9226 : 35                  	xpah 	p1
(1)  218/    9227 : C2 FE               	ld 		-2(p2) 												; restore saved value
(1)  219/    9229 : 02                  	ccl
(1)  220/    922A : F4 20               	adi 	0x20												; will make lower case -ve
(1)  221/    922C : 94 02               	jp 		__GCNotLower
(1)  222/    922E : FC 20               	cai 	0x20 												; capitalise
(1)  223/    9230 :                     __GCNotLower:
(1)  224/    9230 : F4 E0               	adi 	0xE0 												; fix up.
(1)  225/    9232 : 3F                  	xppc 	p3 													; return
(1)  226/    9233 : 90 DC               	jmp 	GetChar 											; make re-entrant
(1)  227/    9235 :                     	endsection 	GetChar
(1)  228/    9235 :                     
(1)  229/    9235 :                     ; ****************************************************************************************************************
(1)  230/    9235 :                     ; ****************************************************************************************************************
(1)  231/    9235 :                     ;
(1)  232/    9235 :                     ;			Read an ASCIIZ string from keyboard into P1 of length A maximum (excludes NULL terminator)
(1)  233/    9235 :                     ;
(1)  234/    9235 :                     ; ****************************************************************************************************************
(1)  235/    9235 :                     ; ****************************************************************************************************************
(1)  236/    9235 :                     
(1)  237/    9235 :                     GetString:
(1)  238/    9235 :                     	section GetString
(1)  239/    9235 : (MACRO)             	pusha 														; save A,P3,E
(1)  239/    9235 : CE FF                       st              @-1(p2)
(1)  240/    9237 : (MACRO)             	pushp 	p3
(1)  240/    9237 : 37                          xpah    P3
(1)  240/    9238 : CE FF                       st              @-1(p2)
(1)  240/    923A : 33                          xpal    P3
(1)  240/    923B : CE FF                       st              @-1(p2)
(1)  241/    923D : (MACRO)             	pushe 
(1)  241/    923D : 40                          lde
(1)  241/    923E : CE FF                       st              @-1(p2)
(1)  242/    9240 : C4 00               	ldi 	0 													; set E (current position) to A.
(1)  243/    9242 : 01                  	xae
(1)  244/    9243 :                     __GSLoop:
(1)  245/    9243 : (MACRO)             	lpi 	p3,Print-1 											; print the prompt (half coloured square)
(1)  245/    9243 : C4 91                       ldi     (PRINT-1) / 256
(1)  245/    9245 : 37                          xpah    P3
(1)  245/    9246 : C4 50                       ldi     (PRINT-1) & 255
(1)  245/    9248 : 33                          xpal    P3
(1)  246/    9249 : C4 9B               	ldi 	155
(1)  247/    924B : 3F                  	xppc 	p3
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 12 - 1/16/2016 12:24:34


(1)  248/    924C : (MACRO)             	lpi 	p3,GetChar-1 										; get a character
(1)  248/    924C : C4 92                       ldi     (GETCHAR-1) / 256
(1)  248/    924E : 37                          xpah    P3
(1)  248/    924F : C4 10                       ldi     (GETCHAR-1) & 255
(1)  248/    9251 : 33                          xpal    P3
(1)  249/    9252 : 3F                  	xppc 	p3
(1)  250/    9253 : C9 80               	st 		-0x80(p1) 											; save it in the current position.
(1)  251/    9255 : (MACRO)             	lpi 	p3,Print-1 											; erase the prompt with backspace.
(1)  251/    9255 : C4 91                       ldi     (PRINT-1) / 256
(1)  251/    9257 : 37                          xpah    P3
(1)  251/    9258 : C4 50                       ldi     (PRINT-1) & 255
(1)  251/    925A : 33                          xpal    P3
(1)  252/    925B : C4 08               	ldi 	8
(1)  253/    925D : 3F                  	xppc 	p3
(1)  254/    925E : C1 80               	ld 		-0x80(p1) 											; re-read character
(1)  255/    9260 : D4 E0               	ani 	0xE0 												; check if control key.
(1)  256/    9262 : 98 0F               	jz 		__GSControlKey 
(1)  257/    9264 : 40                  	lde 														; get current position.
(1)  258/    9265 : E2 03               	xor 	3(p2) 												; reached maximum length of buffer ?
(1)  259/    9267 : 98 DA               	jz 		__GSLoop 											; if so, ignore the key and go round again.
(1)  260/    9269 : C1 80               	ld 		-0x80(p1) 											; get character and print it
(1)  261/    926B : 3F                  	xppc 	p3
(1)  262/    926C : C4 01               	ldi 	1 													; increment E
(1)  263/    926E : 02                  	ccl
(1)  264/    926F : 70                  	ade
(1)  265/    9270 : 01                  	xae
(1)  266/    9271 : 90 D0               	jmp 	__GSLoop 											; and go round again.
(1)  267/    9273 :                     ;
(1)  268/    9273 :                     ;	Handle control keys (0x00-0x1F)
(1)  269/    9273 :                     ;
(1)  270/    9273 :                     __GSControlKey:
(1)  271/    9273 : C1 80               	ld 		-0x80(p1) 											; get typed in key
(1)  272/    9275 : E4 08               	xri 	8 													; check for backspace.
(1)  273/    9277 : 98 17               	jz 		__GSBackspace 			
(1)  274/    9279 : E4 05               	xri 	8!13 												; check for CR
(1)  275/    927B : 9C C6               	jnz 	__GSLoop 											; if not, ignore the key.
(1)  276/    927D :                     ;
(1)  277/    927D :                     ;	Carriage Return, ending input.
(1)  278/    927D :                     ;
(1)  279/    927D : C9 80               	st 		-0x80(p1) 											; replace the CR written with NULL terminator.
(1)  280/    927F : C4 0D               	ldi 	13 													; print CR
(1)  281/    9281 : 3F                  	xppc 	p3
(1)  282/    9282 : (MACRO)             	pulle 														; restore E,P3,A
(1)  282/    9282 : C6 01                       ld              @1(p2)
(1)  282/    9284 : 01                          xae
(1)  283/    9285 : (MACRO)             	pullp	p3
(1)  283/    9285 : C6 01                       ld              @1(p2)
(1)  283/    9287 : 33                          xpal    P3
(1)  283/    9288 : C6 01                       ld              @1(p2)
(1)  283/    928A : 37                          xpah    P3
(1)  284/    928B : (MACRO)             	pulla
(1)  284/    928B : C6 01                       ld              @1(p2)
(1)  285/    928D : 3F                  	xppc 	p3 													; return
(1)  286/    928E : 90 A5               	jmp 	GetString 											; make re-entrant (probably unneccessary !!)
(1)  287/    9290 :                     ;
(1)  288/    9290 :                     ;	Backspace entered
(1)  289/    9290 :                     ;
(1)  290/    9290 :                     __GSBackspace
(1)  291/    9290 : 40                  	lde 														; if E = 0 we can't backspace any further.
(1)  292/    9291 : 98 B0               	jz 		__GSLoop
 AS V1.42 Beta [Bld 102] - source file minol.asm(screen.asm) - page 13 - 1/16/2016 12:24:34


(1)  293/    9293 : C4 08               	ldi 	8 													; backspace on screen
(1)  294/    9295 : 3F                  	xppc 	p3
(1)  295/    9296 : C4 FF               	ldi 	0xFF 												; decrement E
(1)  296/    9298 : 02                  	ccl
(1)  297/    9299 : 70                  	ade
(1)  298/    929A : 01                  	xae
(1)  299/    929B : 90 A6               	jmp 	__GSLoop 											; and go round again.
(1)  300/    929D :                     
(1)  301/    929D :                     	endsection GetString
(1)  302/    929D :                     
      88/    929D :                     	include source\execute.asm 									; statement exec main loop
(1)    1/    929D :                     ; ****************************************************************************************************************
(1)    2/    929D :                     ; ****************************************************************************************************************
(1)    3/    929D :                     ;
(1)    4/    929D :                     ;										Instruction Execution
(1)    5/    929D :                     ;	
(1)    6/    929D :                     ; ****************************************************************************************************************
(1)    7/    929D :                     ; ****************************************************************************************************************
(1)    8/    929D :                     
(1)    9/    929D :                     ; ****************************************************************************************************************
(1)   10/    929D :                     ;							Source codes for execution, with skip-over go here
(1)   11/    929D :                     ; ****************************************************************************************************************
(1)   12/    929D :                     
(1)   13/    929D :                     	include source\commands\os.asm 								; OS
(2)    1/    929D :                     ; ****************************************************************************************************************
(2)    2/    929D :                     ; ****************************************************************************************************************
(2)    3/    929D :                     ;
(2)    4/    929D :                     ;												OS command
(2)    5/    929D :                     ;	
(2)    6/    929D :                     ; ****************************************************************************************************************
(2)    7/    929D :                     ; ****************************************************************************************************************
(2)    8/    929D :                     
(2)    9/    929D : 90 07               	jmp 	COS_Over
(2)   10/    929F :                     
(2)   11/    929F :                     CMD_OS:
(2)   12/    929F : (MACRO)             	lpi 	p3,BootMonitor-1 									; monitor re-entry point
(2)   12/    929F : C4 02                       ldi     (BOOTMONITOR-1) / 256
(2)   12/    92A1 : 37                          xpah    P3
(2)   12/    92A2 : C4 0F                       ldi     (BOOTMONITOR-1) & 255
(2)   12/    92A4 : 33                          xpal    P3
(2)   13/    92A5 : 3F                  	xppc 	p3													; go there.
(2)   14/    92A6 :                     
(2)   15/    92A6 :                     COS_Over:
(1)   14/    92A6 :                     	include source\commands\list.asm 							; LIST
(2)    1/    92A6 :                     ; ****************************************************************************************************************
(2)    2/    92A6 :                     ; ****************************************************************************************************************
(2)    3/    92A6 :                     ;
(2)    4/    92A6 :                     ;												LIST command
(2)    5/    92A6 :                     ;	
(2)    6/    92A6 :                     ; ****************************************************************************************************************
(2)    7/    92A6 :                     ; ****************************************************************************************************************
(2)    8/    92A6 :                     
(2)    9/    92A6 : 90 3E               	jmp		CLI_Over
(2)   10/    92A8 :                     
(2)   11/    92A8 :                     CMD_List:
(2)   12/    92A8 : (MACRO)             	lpi 	p1,ProgramBase 										; point P1 to first line.
(2)   12/    92A8 : C4 10                       ldi     (PROGRAMBASE) / 256
(2)   12/    92AA : 35                          xpah    P1
(2)   12/    92AB : C4 04                       ldi     (PROGRAMBASE) & 255
(2)   12/    92AD : 31                          xpal    P1
 AS V1.42 Beta [Bld 102] - source file minol.asm(list.asm) - page 14 - 1/16/2016 12:24:34


(2)   13/    92AE : C4 00               	ldi 	0 													; clear counter. used for Speccy style list.
(2)   14/    92B0 : CE FF               	st 		@-1(p2)
(2)   15/    92B2 :                     CLI_Loop:
(2)   16/    92B2 : C5 01               	ld 		@1(p1) 												; check if finished
(2)   17/    92B4 : D4 80               	ani 	0x80
(2)   18/    92B6 : 9C 28               	jnz 	CLI_End
(2)   19/    92B8 : C5 01               	ld 		@1(p1) 												; get line number into E
(2)   20/    92BA : 01                  	xae 
(2)   21/    92BB : (MACRO)             	lpi 	p3,PrintInteger-1 									; and print it.
(2)   21/    92BB : C4 90                       ldi     (PRINTINTEGER-1) / 256
(2)   21/    92BD : 37                          xpah    P3
(2)   21/    92BE : C4 C4                       ldi     (PRINTINTEGER-1) & 255
(2)   21/    92C0 : 33                          xpal    P3
(2)   22/    92C1 : 3F                  	xppc 	p3
(2)   23/    92C2 : C4 20               	ldi 	' '													; print space
(2)   24/    92C4 : 3F                  	xppc 	p3
(2)   25/    92C5 :                     ;
(2)   26/    92C5 :                     CLI_Line:
(2)   27/    92C5 : C5 01               	ld 		@1(p1) 												; get character
(2)   28/    92C7 : 98 03               	jz 		CLI_EndLine											; if zero, do next line.
(2)   29/    92C9 : 3F                  	xppc 	p3 													; print it
(2)   30/    92CA : 90 F9               	jmp 	CLI_Line
(2)   31/    92CC :                     ;
(2)   32/    92CC :                     CLI_EndLine:
(2)   33/    92CC : C4 0D               	ldi 	13													; new line
(2)   34/    92CE : 3F                  	xppc 	p3
(2)   35/    92CF : AA 00               	ild 	(p2) 												; bump counter
(2)   36/    92D1 : D4 03               	ani 	0x03 												; stop every 3 lines
(2)   37/    92D3 : 9C DD               	jnz 	CLI_Loop 											; keep going.
(2)   38/    92D5 : (MACRO)             	lpi 	p3,GetChar-1 										; get a keystroke
(2)   38/    92D5 : C4 92                       ldi     (GETCHAR-1) / 256
(2)   38/    92D7 : 37                          xpah    P3
(2)   38/    92D8 : C4 10                       ldi     (GETCHAR-1) & 255
(2)   38/    92DA : 33                          xpal    P3
(2)   39/    92DB : 3F                  	xppc 	p3
(2)   40/    92DC : E4 20               	xri 	' '													; if space pressed
(2)   41/    92DE : 98 D2               	jz 		CLI_Loop 											; and do next line.
(2)   42/    92E0 :                     
(2)   43/    92E0 :                     CLI_End:
(2)   44/    92E0 : C6 01               	ld 		@1(p2) 												; drop counter
(2)   45/    92E2 : C4 FF               	ldi 	ERRC_End											; fake error to end after LIST as destroys P1.
(2)   46/    92E4 : 01                  	xae
(2)   47/    92E5 : 02                  	ccl
(2)   48/    92E6 :                     
(2)   49/    92E6 :                     CLI_Over:
(2)   50/    92E6 :                     
(2)   51/    92E6 :                     
(1)   15/    92E6 :                     	include source\commands\new_end.asm 						; NEW and END
(2)    1/    92E6 :                     ; ****************************************************************************************************************
(2)    2/    92E6 :                     ; ****************************************************************************************************************
(2)    3/    92E6 :                     ;
(2)    4/    92E6 :                     ;												NEW and END
(2)    5/    92E6 :                     ;	
(2)    6/    92E6 :                     ; ****************************************************************************************************************
(2)    7/    92E6 :                     ; ****************************************************************************************************************
(2)    8/    92E6 :                     
(2)    9/    92E6 : 90 1E               	jmp 	CNE_Over
(2)   10/    92E8 :                     
(2)   11/    92E8 :                     ; ****************************************************************************************************************
(2)   12/    92E8 :                     ;						NEW (Erase program) also executes END in case in running program
 AS V1.42 Beta [Bld 102] - source file minol.asm(new_end.asm) - page 15 - 1/16/2016 12:24:34


(2)   13/    92E8 :                     ; ****************************************************************************************************************
(2)   14/    92E8 :                     
(2)   15/    92E8 :                     CMD_New:
(2)   16/    92E8 : (MACRO)             	lpi 	p3,ProgramBase 										; write $FF at program base
(2)   16/    92E8 : C4 10                       ldi     (PROGRAMBASE) / 256
(2)   16/    92EA : 37                          xpah    P3
(2)   16/    92EB : C4 04                       ldi     (PROGRAMBASE) & 255
(2)   16/    92ED : 33                          xpal    P3
(2)   17/    92EE : C4 FF               	ldi 	0xFF
(2)   18/    92F0 : CB 00               	st 		0(p3) 												; this erases the program
(2)   19/    92F2 : C4 FD               	ldi 	Marker1 											; write the program-code-marker out.
(2)   20/    92F4 : CB FC               	st 		-4(p3)
(2)   21/    92F6 : C4 B5               	ldi 	Marker2
(2)   22/    92F8 : CB FD               	st 		-3(p3)
(2)   23/    92FA : C4 AE               	ldi 	Marker3
(2)   24/    92FC : CB FE               	st 		-2(p3)
(2)   25/    92FE : C4 76               	ldi 	Marker4
(2)   26/    9300 : CB FF               	st 		-1(p3)
(2)   27/    9302 :                     
(2)   28/    9302 :                     ; ****************************************************************************************************************
(2)   29/    9302 :                     ;													END program
(2)   30/    9302 :                     ; ****************************************************************************************************************
(2)   31/    9302 :                     
(2)   32/    9302 :                     CMD_End:
(2)   33/    9302 : 02                  	ccl 														; we cause an error, but it is ERRC_End which is 
(2)   34/    9303 : C4 FF               	ldi 	ERRC_End 											; not an error and not reported as such.
(2)   35/    9305 : 01                  	xae
(2)   36/    9306 :                     
(2)   37/    9306 :                     CNE_Over:
(1)   16/    9306 :                     	include source\commands\input.asm 							; IN<put>
(2)    1/    9306 :                     ; ****************************************************************************************************************
(2)    2/    9306 :                     ; ****************************************************************************************************************
(2)    3/    9306 :                     ;
(2)    4/    9306 :                     ;												IN command
(2)    5/    9306 :                     ;	
(2)    6/    9306 :                     ; ****************************************************************************************************************
(2)    7/    9306 :                     ; ****************************************************************************************************************
(2)    8/    9306 :                     
(2)    9/    9306 : 90 30               	jmp		CIN_Over2
(2)   10/    9308 :                     
(2)   11/    9308 :                     CMD_In:
(2)   12/    9308 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; set P3 to call evaluate pair (H,L)
(2)   12/    9308 : C4 97                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   12/    930A : 37                          xpah    P3
(2)   12/    930B : C4 17                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   12/    930D : 33                          xpal    P3
(2)   13/    930E : 03                  	scl 														; indicates no error
(2)   14/    930F : C1 00               	ld	 	(p1) 												; look at first character
(2)   15/    9311 : 98 25               	jz 		CIN_Over2 											; if zero or ':' then end of IN
(2)   16/    9313 : E4 3A               	xri 	':'
(2)   17/    9315 : 98 21               	jz 		CIN_Over2
(2)   18/    9317 : C5 01               	ld 		@1(p1) 												; fetch and bump
(2)   19/    9319 : E4 2C               	xri 	','													; ignora commas
(2)   20/    931B : 98 EB               	jz 		CMD_In
(2)   21/    931D : E4 0C               	xri 	' '!','												; ignore spaces.
(2)   22/    931F : 98 E7               	jz 		CMD_In
(2)   23/    9321 : E4 08               	xri 	'('!' '												; open bracket is Input to (H,L)
(2)   24/    9323 : 98 22               	jz 		CIN_Memory 
(2)   25/    9325 : E4 0C               	xri 	'$'!'('												; $(H,L) is input to memory.
(2)   26/    9327 : 98 59               	jz 		CIN_String
 AS V1.42 Beta [Bld 102] - source file minol.asm(input.asm) - page 16 - 1/16/2016 12:24:34


(2)   27/    9329 :                     
(2)   28/    9329 :                     ; ****************************************************************************************************************
(2)   29/    9329 :                     ;											Check for A-Z input.
(2)   30/    9329 :                     ; ****************************************************************************************************************
(2)   31/    9329 :                     
(2)   32/    9329 : C1 FF               	ld 		-1(p1)												; get letter of variable
(2)   33/    932B : 02                  	ccl
(2)   34/    932C : F4 A5               	adi 	255-'Z'												; check if > 'Z'
(2)   35/    932E : 94 04               	jp 		CIN_Syntax 				
(2)   36/    9330 : F4 1A               	adi 	26 													; will be +ve if A..Z now
(2)   37/    9332 : 94 06               	jp 		CIN_Variable
(2)   38/    9334 :                     
(2)   39/    9334 :                     ; ****************************************************************************************************************
(2)   40/    9334 :                     ;									Syntax error - not (x,x) $(x,x) or A..Z
(2)   41/    9334 :                     ; ****************************************************************************************************************
(2)   42/    9334 :                     
(2)   43/    9334 :                     CIN_Syntax:
(2)   44/    9334 : C4 35               	ldi 	ERRC_Syntax
(2)   45/    9336 : 01                  	xae
(2)   46/    9337 : 02                  	ccl
(2)   47/    9338 :                     CIN_Over2:
(2)   48/    9338 : 90 6C               	jmp 	CIN_Over
(2)   49/    933A :                     
(2)   50/    933A :                     ; ****************************************************************************************************************
(2)   51/    933A :                     ;										Input to variable in A (0-25)
(2)   52/    933A :                     ; ****************************************************************************************************************
(2)   53/    933A :                     
(2)   54/    933A :                     CIN_Variable:
(2)   55/    933A : 02                  	ccl 														; add variable number 0-25 to Variables to get an address
(2)   56/    933B : F4 90               	adi 	Variables & 255
(2)   57/    933D : CA FE               	st 		-2(p2)
(2)   58/    933F : C4 0C               	ldi 	Variables / 256
(2)   59/    9341 : F4 00               	adi 	0
(2)   60/    9343 : CA FF               	st 		-1(p2)
(2)   61/    9345 : 90 05               	jmp 	CIN_InputVariableOrMemory
(2)   62/    9347 :                     
(2)   63/    9347 :                     ; ****************************************************************************************************************
(2)   64/    9347 :                     ;											Input to (<expr>,<expr>)
(2)   65/    9347 :                     ; ****************************************************************************************************************
(2)   66/    9347 :                     
(2)   67/    9347 :                     CIN_Memory:
(2)   68/    9347 : C5 FF               	ld 		@-1(p1)												; point to the bracket.
(2)   69/    9349 : 3F                  	xppc 	p3 													; push the H,L on the stack, without the stack being changed
(2)   70/    934A : 94 5A               	jp 		CIN_Over 											; exit on error.
(2)   71/    934C :                     
(2)   72/    934C :                     ; ****************************************************************************************************************
(2)   73/    934C :                     ;								Input to variable or memory address is hidden on TOS.
(2)   74/    934C :                     ; ****************************************************************************************************************
(2)   75/    934C :                     
(2)   76/    934C :                     CIN_InputVariableOrMemory:
(2)   77/    934C : C6 FE               	ld 		@-2(p2) 											; save the storage address as TOS "Make it visible"
(2)   78/    934E : (MACRO)             	pushp 	p1 													; save P1 on stack
(2)   78/    934E : 35                          xpah    P1
(2)   78/    934F : CE FF                       st              @-1(p2)
(2)   78/    9351 : 31                          xpal    P1
(2)   78/    9352 : CE FF                       st              @-1(p2)
(2)   79/    9354 : (MACRO)             	lpi 	p3,GetString-1 										; read keyboard
(2)   79/    9354 : C4 92                       ldi     (GETSTRING-1) / 256
(2)   79/    9356 : 37                          xpah    P3
(2)   79/    9357 : C4 34                       ldi     (GETSTRING-1) & 255
 AS V1.42 Beta [Bld 102] - source file minol.asm(input.asm) - page 17 - 1/16/2016 12:24:34


(2)   79/    9359 : 33                          xpal    P3
(2)   80/    935A : (MACRO)             	lpi 	p1,KeyboardBuffer 									; point P1 to keyboard buffer.
(2)   80/    935A : C4 0C                       ldi     (KEYBOARDBUFFER) / 256
(2)   80/    935C : 35                          xpah    P1
(2)   80/    935D : C4 B0                       ldi     (KEYBOARDBUFFER) & 255
(2)   80/    935F : 31                          xpal    P1
(2)   81/    9360 : C4 48               	ldi 	KeyboardBufferSize 									; buffer size
(2)   82/    9362 : 3F                  	xppc 	p3 													; read it in.
(2)   83/    9363 :                     
(2)   84/    9363 : (MACRO)             	lpi 	p3,GetConstant-1 									; extract constant to E if any
(2)   84/    9363 : C4 91                       ldi     (GETCONSTANT-1) / 256
(2)   84/    9365 : 37                          xpah    P3
(2)   84/    9366 : C4 20                       ldi     (GETCONSTANT-1) & 255
(2)   84/    9368 : 33                          xpal    P3
(2)   85/    9369 : 3F                  	xppc 	p3
(2)   86/    936A : D4 80               	ani 	0x80 												; if CY/L set, e.g. is it legal 
(2)   87/    936C : 9C 03               	jnz 	CIN_StoreValue										; if so, store E at the address.
(2)   88/    936E : C1 00               	ld 		(p1) 												; get the character code of the first letter
(2)   89/    9370 : 01                  	xae 														; into E
(2)   90/    9371 :                     CIN_StoreValue:
(2)   91/    9371 : (MACRO)             	pullp 	p1 													; restore P1
(2)   91/    9371 : C6 01                       ld              @1(p2)
(2)   91/    9373 : 31                          xpal    P1
(2)   91/    9374 : C6 01                       ld              @1(p2)
(2)   91/    9376 : 35                          xpah    P1
(2)   92/    9377 : C6 01               	ld 		@1(p2) 												; get low byte to P3.L
(2)   93/    9379 : 33                  	xpal 	p3 												
(2)   94/    937A : C6 01               	ld 		@1(p2)												; get high byte to P3.H
(2)   95/    937C : 37                  	xpah 	p3
(2)   96/    937D : 40                  	lde 														; get E, value to store
(2)   97/    937E : CB 00               	st 		(p3)												; and write it.
(2)   98/    9380 :                     CMD_In2:
(2)   99/    9380 : 90 86               	jmp 	CMD_In 												; and see if there is more to input
(2)  100/    9382 :                     
(2)  101/    9382 :                     ; ****************************************************************************************************************
(2)  102/    9382 :                     ;												Input String to Memory
(2)  103/    9382 :                     ; ****************************************************************************************************************
(2)  104/    9382 :                     
(2)  105/    9382 :                     CIN_String:
(2)  106/    9382 : 3F                  	xppc 	p3 													; evaluate (H,L)
(2)  107/    9383 : 94 21               	jp 		CIN_Over 											; exit on error.
(2)  108/    9385 : C2 FF               	ld 		-1(p2) 												; read High
(2)  109/    9387 : 35                  	xpah 	p1 													; put into P1.H
(2)  110/    9388 : CA FF               	st 		-1(p2)
(2)  111/    938A : C2 FE               	ld 		-2(p2)												; read Low
(2)  112/    938C : 31                  	xpal 	p1 													; put into P1.L
(2)  113/    938D : CE FE               	st 		@-2(p2) 											; save on stack
(2)  114/    938F : (MACRO)             	lpi 	p3,GetString-1 										; read keyboard
(2)  114/    938F : C4 92                       ldi     (GETSTRING-1) / 256
(2)  114/    9391 : 37                          xpah    P3
(2)  114/    9392 : C4 34                       ldi     (GETSTRING-1) & 255
(2)  114/    9394 : 33                          xpal    P3
(2)  115/    9395 : C4 48               	ldi 	KeyboardBufferSize 									; max size of input
(2)  116/    9397 : 3F                  	xppc 	p3 													; read keyboard into address
(2)  117/    9398 :                     
(2)  118/    9398 :                     CIN_FindEnd:													; look for EOS (NULL)
(2)  119/    9398 : C5 01               	ld 		@1(p1)
(2)  120/    939A : 9C FC               	jnz 	CIN_FindEnd
(2)  121/    939C : B9 FF               	dld 	-1(p1) 												; convert $00 to $FF
(2)  122/    939E :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(input.asm) - page 18 - 1/16/2016 12:24:34


(2)  123/    939E : C6 01               	ld 		@1(p2) 												; pop P1
(2)  124/    93A0 : 31                  	xpal 	p1
(2)  125/    93A1 : C6 01               	ld 		@1(p2)
(2)  126/    93A3 : 35                  	xpah 	p1
(2)  127/    93A4 : 90 DA               	jmp 	CMD_In2												; see if more input 
(2)  128/    93A6 :                     
(2)  129/    93A6 :                     CIN_Over:
(2)  130/    93A6 :                     
(2)  131/    93A6 :                     
(2)  132/    93A6 :                     
(1)   17/    93A6 :                     	include source\commands\clear.asm							; CLEAR
(2)    1/    93A6 :                     ; ****************************************************************************************************************
(2)    2/    93A6 :                     ; ****************************************************************************************************************
(2)    3/    93A6 :                     ;
(2)    4/    93A6 :                     ;													CLEAR
(2)    5/    93A6 :                     ;	
(2)    6/    93A6 :                     ; ****************************************************************************************************************
(2)    7/    93A6 :                     ; ****************************************************************************************************************
(2)    8/    93A6 :                     
(2)    9/    93A6 : 90 13               	jmp	CCL_Over
(2)   10/    93A8 :                     
(2)   11/    93A8 :                     ; ****************************************************************************************************************
(2)   12/    93A8 :                     ;												CLEAR command
(2)   13/    93A8 :                     ; ****************************************************************************************************************
(2)   14/    93A8 :                     
(2)   15/    93A8 :                     CMD_Clear:
(2)   16/    93A8 : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   16/    93A8 : C4 0C                       ldi     (VARIABLES) / 256
(2)   16/    93AA : 37                          xpah    P3
(2)   16/    93AB : C4 90                       ldi     (VARIABLES) & 255
(2)   16/    93AD : 33                          xpal    P3
(2)   17/    93AE : C4 1A               	ldi 	26 													; loop counter to 26
(2)   18/    93B0 : CA FF               	st 		-1(p2)
(2)   19/    93B2 :                     CCL_Loop:
(2)   20/    93B2 : C4 00               	ldi 	0x00												; clear a variable
(2)   21/    93B4 : CF 01               	st 		@1(p3)
(2)   22/    93B6 : BA FF               	dld 	-1(p2) 												; done all
(2)   23/    93B8 : 9C F8               	jnz 	CCL_Loop											; loop back
(2)   24/    93BA : 03                  	scl 														; no error
(2)   25/    93BB :                     
(2)   26/    93BB :                     CCL_Over:
(1)   18/    93BB :                     	include source\commands\print.asm 							; PR<int>
(2)    1/    93BB :                     ; ****************************************************************************************************************
(2)    2/    93BB :                     ; ****************************************************************************************************************
(2)    3/    93BB :                     ;
(2)    4/    93BB :                     ;												PR command
(2)    5/    93BB :                     ;	
(2)    6/    93BB :                     ; ****************************************************************************************************************
(2)    7/    93BB :                     ; ****************************************************************************************************************
(2)    8/    93BB :                     
(2)    9/    93BB : 90 4B               	jmp 	CPR_Over2
(2)   10/    93BD :                     
(2)   11/    93BD :                     ; ****************************************************************************************************************
(2)   12/    93BD :                     ;												Main printing loop
(2)   13/    93BD :                     ; ****************************************************************************************************************
(2)   14/    93BD :                     
(2)   15/    93BD :                     CMD_Print:
(2)   16/    93BD : C4 08               	ldi 	0x8 												; read keyboard
(2)   17/    93BF : 37                  	xpah 	p3
(2)   18/    93C0 : C3 00               	ld 		(p3) 
 AS V1.42 Beta [Bld 102] - source file minol.asm(print.asm) - page 19 - 1/16/2016 12:24:34


(2)   19/    93C2 : E4 83               	xri 	0x80+3
(2)   20/    93C4 : 98 3E               	jz		CPR_Break
(2)   21/    93C6 :                     
(2)   22/    93C6 : (MACRO)             	lpi 	p3,Print-1 											; set up P3 for printing.
(2)   22/    93C6 : C4 91                       ldi     (PRINT-1) / 256
(2)   22/    93C8 : 37                          xpah    P3
(2)   22/    93C9 : C4 50                       ldi     (PRINT-1) & 255
(2)   22/    93CB : 33                          xpal    P3
(2)   23/    93CC : C1 00               	ld 		(p1)												; reached end of command, print RETURN and exit.
(2)   24/    93CE : 98 79               	jz 		CPR_EndReturn
(2)   25/    93D0 : E4 3A               	xri 	':'
(2)   26/    93D2 : 98 75               	jz 		CPR_EndReturn
(2)   27/    93D4 : C5 01               	ld 		@1(p1)												; re-read with a bump
(2)   28/    93D6 : E4 20               	xri 	' '													; if space, skip it
(2)   29/    93D8 : 98 E3               	jz 		CMD_Print
(2)   30/    93DA : E4 0C               	xri 	','!' '												; if comma, skip it.
(2)   31/    93DC : 98 DF               	jz 		CMD_Print
(2)   32/    93DE : E4 17               	xri 	';'!','												; if semicolon exit without a return
(2)   33/    93E0 : 98 6A               	jz 		CPR_EndOk 
(2)   34/    93E2 : E4 19               	xri 	'"'!';'												; if quote mark print as quoted string
(2)   35/    93E4 : 98 24               	jz 		CPR_QuotedString
(2)   36/    93E6 : E4 06               	xri 	'$'!'"'												; if $ print string at address.
(2)   37/    93E8 : 98 2D               	jz 		CPR_StringAtAddress
(2)   38/    93EA :                     
(2)   39/    93EA :                     ; ****************************************************************************************************************
(2)   40/    93EA :                     ;												numerical expression
(2)   41/    93EA :                     ; ****************************************************************************************************************
(2)   42/    93EA :                     
(2)   43/    93EA : C4 20               	ldi 	' '													; preceding space
(2)   44/    93EC : 3F                  	xppc 	p3
(2)   45/    93ED : C5 FF               	ld 		@-1(p1)												; unpick the get, first character of expression.
(2)   46/    93EF : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; evaluate expression
(2)   46/    93EF : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)   46/    93F1 : 37                          xpah    P3
(2)   46/    93F2 : C4 C4                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)   46/    93F4 : 33                          xpal    P3
(2)   47/    93F5 : 3F                  	xppc 	p3
(2)   48/    93F6 : 94 55               	jp 		CPR_Over 											; exit on error.
(2)   49/    93F8 : (MACRO)             	lpi 	p3,PrintInteger-1 									; and print it
(2)   49/    93F8 : C4 90                       ldi     (PRINTINTEGER-1) / 256
(2)   49/    93FA : 37                          xpah    P3
(2)   49/    93FB : C4 C4                       ldi     (PRINTINTEGER-1) & 255
(2)   49/    93FD : 33                          xpal    P3
(2)   50/    93FE : 3F                  	xppc 	p3
(2)   51/    93FF : C4 20               	ldi 	' '													; trailing space
(2)   52/    9401 : 3F                  	xppc 	p3
(2)   53/    9402 :                     CMD_Print2:
(2)   54/    9402 : 90 B9               	jmp 	CMD_Print
(2)   55/    9404 :                     
(2)   56/    9404 :                     ; ****************************************************************************************************************
(2)   57/    9404 :                     ;													Break 
(2)   58/    9404 :                     ; ****************************************************************************************************************
(2)   59/    9404 :                     
(2)   60/    9404 :                     CPR_Break:
(2)   61/    9404 : C4 38               	ldi 	ERRC_BREAK
(2)   62/    9406 : 01                  	xae
(2)   63/    9407 : 02                  	ccl
(2)   64/    9408 :                     CPR_Over2:
(2)   65/    9408 : 90 43               	jmp 	CPR_Over
(2)   66/    940A :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(print.asm) - page 20 - 1/16/2016 12:24:34


(2)   67/    940A :                     ; ****************************************************************************************************************
(2)   68/    940A :                     ;												"<quoted string>"
(2)   69/    940A :                     ; ****************************************************************************************************************
(2)   70/    940A :                     
(2)   71/    940A :                     CPR_QuotedString:
(2)   72/    940A : C5 01               	ld 		@1(p1) 												; get character
(2)   73/    940C : 98 35               	jz 		CPR_Syntax 											; if NULL, syntax error.
(2)   74/    940E : E4 22               	xri 	'"'													; if closing quote
(2)   75/    9410 : 98 AB               	jz 		CMD_Print
(2)   76/    9412 : C1 FF               	ld 		-1(p1)												; re-get it
(2)   77/    9414 : 3F                  	xppc 	p3 													; print it
(2)   78/    9415 : 90 F3               	jmp 	CPR_QuotedString
(2)   79/    9417 :                     
(2)   80/    9417 :                     ; ****************************************************************************************************************
(2)   81/    9417 :                     ;									$(H,L) print string at address, ended by -ve or 0.
(2)   82/    9417 :                     ; ****************************************************************************************************************
(2)   83/    9417 :                     
(2)   84/    9417 :                     CPR_StringAtAddress:
(2)   85/    9417 : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate (H,L)
(2)   85/    9417 : C4 97                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   85/    9419 : 37                          xpah    P3
(2)   85/    941A : C4 17                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   85/    941C : 33                          xpal    P3
(2)   86/    941D : 3F                  	xppc 	p3	
(2)   87/    941E : 94 2D               	jp 		CPR_Over											; exit on error
(2)   88/    9420 :                     
(2)   89/    9420 : C6 FF               	ld 		@-1(p2) 											; retrieve H to P1.H
(2)   90/    9422 : 35                  	xpah 	p1
(2)   91/    9423 : CA 00               	st 		(p2)												; and save P1.H there
(2)   92/    9425 : C6 FF               	ld 		@-1(p2) 											; retrieve L to P1.L
(2)   93/    9427 : 31                  	xpal 	p1
(2)   94/    9428 : CA 00               	st 		(p2)
(2)   95/    942A : (MACRO)             	lpi 	p3,Print-1 											; set up P3 to print.
(2)   95/    942A : C4 91                       ldi     (PRINT-1) / 256
(2)   95/    942C : 37                          xpah    P3
(2)   95/    942D : C4 50                       ldi     (PRINT-1) & 255
(2)   95/    942F : 33                          xpal    P3
(2)   96/    9430 :                     CPR_StringLoop:
(2)   97/    9430 : C5 01               	ld 		@1(p1) 												; fetch and bump character
(2)   98/    9432 : 98 02               	jz 		CPR_StringExit 										; if zero end of string
(2)   99/    9434 : 94 08               	jp 		CPR_StringPrint 									; if +ve printable character
(2)  100/    9436 :                     ;
(2)  101/    9436 :                     CPR_StringExit:
(2)  102/    9436 : C6 01               	ld 		@1(p2)												; restore P1.
(2)  103/    9438 : 31                  	xpal 	p1
(2)  104/    9439 : C6 01               	ld 		@1(p2)
(2)  105/    943B : 35                  	xpah 	p1
(2)  106/    943C : 90 C4               	jmp 	CMD_Print2 											; and print the next thing.
(2)  107/    943E :                     ;
(2)  108/    943E :                     CPR_StringPrint:
(2)  109/    943E : C1 FF               	ld 		-1(p1) 												; retrieve, print and loop
(2)  110/    9440 : 3F                  	xppc 	p3
(2)  111/    9441 : 90 ED               	jmp 	CPR_StringLoop
(2)  112/    9443 :                     
(2)  113/    9443 :                     ; ****************************************************************************************************************
(2)  114/    9443 :                     ;												Syntax Error
(2)  115/    9443 :                     ; ****************************************************************************************************************
(2)  116/    9443 :                     
(2)  117/    9443 :                     CPR_Syntax:
(2)  118/    9443 : C4 35               	ldi 	ERRC_Syntax 										; set up for syntax error and exit
 AS V1.42 Beta [Bld 102] - source file minol.asm(print.asm) - page 21 - 1/16/2016 12:24:34


(2)  119/    9445 : 01                  	xae
(2)  120/    9446 : 02                  	ccl
(2)  121/    9447 : 90 04               	jmp 	CPR_Over
(2)  122/    9449 :                     
(2)  123/    9449 :                     ; ****************************************************************************************************************
(2)  124/    9449 :                     ;										Print return and end okay.
(2)  125/    9449 :                     ; ****************************************************************************************************************
(2)  126/    9449 :                     
(2)  127/    9449 :                     CPR_EndReturn:
(2)  128/    9449 : C4 0D               	ldi 	13													; print a carriage return.
(2)  129/    944B : 3F                  	xppc 	p3
(2)  130/    944C :                     CPR_EndOk:														; end successfully.
(2)  131/    944C : 03                  	scl 														; set carry flag (no error)
(2)  132/    944D :                     
(2)  133/    944D :                     CPR_Over:
(2)  134/    944D :                     	
(1)   19/    944D :                     	include source\commands\call.asm 							; CALL
(2)    1/    944D :                     ; ****************************************************************************************************************
(2)    2/    944D :                     ; ****************************************************************************************************************
(2)    3/    944D :                     ;
(2)    4/    944D :                     ;												CALL command
(2)    5/    944D :                     ;	
(2)    6/    944D :                     ; ****************************************************************************************************************
(2)    7/    944D :                     ; ****************************************************************************************************************
(2)    8/    944D :                     
(2)    9/    944D : 90 27               	jmp		CCA_Over
(2)   10/    944F :                     
(2)   11/    944F :                     CMD_Call:
(2)   12/    944F : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the address pair (e.g. (H,L))
(2)   12/    944F : C4 97                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   12/    9451 : 37                          xpah    P3
(2)   12/    9452 : C4 17                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   12/    9454 : 33                          xpal    P3
(2)   13/    9455 : 3F                  	xppc 	p3
(2)   14/    9456 : 94 1E               	jp 		CCA_Over 											; exit on error.
(2)   15/    9458 : C2 FE               	ld 		-2(p2) 												; retrieve the L value to E
(2)   16/    945A : 01                  	xae 	
(2)   17/    945B : C2 FF               	ld 		-1(p2)												; retrieve the H value to P3.H
(2)   18/    945D : 37                  	xpah 	p3
(2)   19/    945E : 40                  	lde	 														; copy L value to P3.L
(2)   20/    945F : 33                  	xpal 	p3
(2)   21/    9460 : C7 FF               	ld 		@-1(p3) 											; fix up for pre-increment
(2)   22/    9462 : (MACRO)             	pushp 	p1 													; save P1
(2)   22/    9462 : 35                          xpah    P1
(2)   22/    9463 : CE FF                       st              @-1(p2)
(2)   22/    9465 : 31                          xpal    P1
(2)   22/    9466 : CE FF                       st              @-1(p2)
(2)   23/    9468 : (MACRO)             	lpi 	p1,Variables 										; and point P1 to the variables
(2)   23/    9468 : C4 0C                       ldi     (VARIABLES) / 256
(2)   23/    946A : 35                          xpah    P1
(2)   23/    946B : C4 90                       ldi     (VARIABLES) & 255
(2)   23/    946D : 31                          xpal    P1
(2)   24/    946E : 03                  	scl 														; set CY/L flag, so the call can return an error.
(2)   25/    946F : 3F                  	xppc 	p3 													; call the routine
(2)   26/    9470 : (MACRO)             	pullp	p1 													; restore P1
(2)   26/    9470 : C6 01                       ld              @1(p2)
(2)   26/    9472 : 31                          xpal    P1
(2)   26/    9473 : C6 01                       ld              @1(p2)
(2)   26/    9475 : 35                          xpah    P1
(2)   27/    9476 :                     	
 AS V1.42 Beta [Bld 102] - source file minol.asm(call.asm) - page 22 - 1/16/2016 12:24:34


(2)   28/    9476 :                     CCA_Over:
(1)   20/    9476 :                     	include source\commands\let.asm 							; LET (optional, but slower if not present)
(2)    1/    9476 :                     ; ****************************************************************************************************************
(2)    2/    9476 :                     ; ****************************************************************************************************************
(2)    3/    9476 :                     ;
(2)    4/    9476 :                     ;												LET command
(2)    5/    9476 :                     ;	
(2)    6/    9476 :                     ; ****************************************************************************************************************
(2)    7/    9476 :                     ; ****************************************************************************************************************
(2)    8/    9476 :                     
(2)    9/    9476 : 90 51               	jmp 	CLE_Over
(2)   10/    9478 :                     
(2)   11/    9478 :                     CMD_Let:
(2)   12/    9478 : C1 00               	ld 		(p1) 												; look at character
(2)   13/    947A : E4 28               	xri 	'('													; is it let (h,l) ?
(2)   14/    947C : 98 20               	jz 		CLE_IsHL 											; if so, go to the (H,L) code
(2)   15/    947E : C1 00               	ld 		(p1) 												; re-read it.
(2)   16/    9480 : 02                  	ccl
(2)   17/    9481 : F4 A5               	adi 	255-'Z' 											; will be +ve on error
(2)   18/    9483 : 94 04               	jp 		CLE_Syntax 											; e.g. > Z
(2)   19/    9485 : F4 1A               	adi 	26 													; will be 0-25 if A..Z
(2)   20/    9487 : 94 06               	jp 		CLE_SingleVariable
(2)   21/    9489 :                     ;
(2)   22/    9489 :                     ;	Syntax Error
(2)   23/    9489 :                     ;
(2)   24/    9489 :                     CLE_Syntax:
(2)   25/    9489 : C4 35               	ldi 	ERRC_Syntax 										; set E to error code.
(2)   26/    948B : 01                  	xae
(2)   27/    948C : 02                  	ccl 														; CY/L = 0 = Error
(2)   28/    948D : 90 3A               	jmp 	CLE_Over 											; and exit
(2)   29/    948F :                     ;
(2)   30/    948F :                     ;	A-Z. AC contains 0-25
(2)   31/    948F :                     ;
(2)   32/    948F :                     CLE_SingleVariable:
(2)   33/    948F : 02                  	ccl  														; work out variable address, and put on stack.
(2)   34/    9490 : F4 90               	adi 	Variables & 255
(2)   35/    9492 : CE FE               	st 		@-2(p2) 
(2)   36/    9494 : C4 0C               	ldi 	Variables / 256
(2)   37/    9496 : F4 00               	adi 	0
(2)   38/    9498 : CA 01               	st 		1(p2)
(2)   39/    949A : C5 01               	ld 		@1(p1) 												; skip over the variable.
(2)   40/    949C : 90 0B               	jmp 	CLE_EvaluateAndWrite
(2)   41/    949E :                     ;
(2)   42/    949E :                     ;	LET is (H,L) = <expr>
(2)   43/    949E :                     ;
(2)   44/    949E :                     CLE_IsHL:
(2)   45/    949E : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; evaluate the (H,L)
(2)   45/    949E : C4 97                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)   45/    94A0 : 37                          xpah    P3
(2)   45/    94A1 : C4 17                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)   45/    94A3 : 33                          xpal    P3
(2)   46/    94A4 : 3F                  	xppc 	p3
(2)   47/    94A5 : 94 22               	jp 		CLE_Over 											; exit on error
(2)   48/    94A7 : C6 FE               	ld 		@-2(p2) 											; the address to write to is now on TOS.
(2)   49/    94A9 :                     ;
(2)   50/    94A9 :                     ;	Evaluate and write.
(2)   51/    94A9 :                     ;
(2)   52/    94A9 :                     CLE_EvaluateAndWrite:
(2)   53/    94A9 : C5 01               	ld 		@1(p1) 												; skip over spaces
(2)   54/    94AB : E4 20               	xri 	' '
 AS V1.42 Beta [Bld 102] - source file minol.asm(let.asm) - page 23 - 1/16/2016 12:24:34


(2)   55/    94AD : 98 FA               	jz 		CLE_EvaluateAndWrite
(2)   56/    94AF : E4 1D               	xri 	' '!'='												; check first non space character is =
(2)   57/    94B1 : 9C D6               	jnz 	CLE_Syntax 											; if not, a syntax error.
(2)   58/    94B3 :                     
(2)   59/    94B3 : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; set up to evaluate the RHS
(2)   59/    94B3 : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)   59/    94B5 : 37                          xpah    P3
(2)   59/    94B6 : C4 C4                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)   59/    94B8 : 33                          xpal    P3
(2)   60/    94B9 : 3F                  	xppc 	p3													; do it
(2)   61/    94BA : C6 02               	ld 		@2(p2) 												; remove target from TOS but leave data there
(2)   62/    94BC : 06                  	csa 														; did that evaluate cause an error ?
(2)   63/    94BD : 94 0A               	jp 		CLE_Over 											; if so, exit with that error.
(2)   64/    94BF :                     
(2)   65/    94BF : C2 FE               	ld 		-2(p2) 												; load address into P3
(2)   66/    94C1 : 33                  	xpal 	p3
(2)   67/    94C2 : C2 FF               	ld 		-1(p2)
(2)   68/    94C4 : 37                  	xpah 	p3
(2)   69/    94C5 : 40                  	lde 														; get value
(2)   70/    94C6 : CB 00               	st 		(p3) 												; store there
(2)   71/    94C8 : 03                  	scl 														; no error and exit.
(2)   72/    94C9 :                     
(2)   73/    94C9 :                     CLE_Over:
(1)   21/    94C9 :                     	include source\commands\if.asm								; IF
(2)    1/    94C9 :                     ; ****************************************************************************************************************
(2)    2/    94C9 :                     ; ****************************************************************************************************************
(2)    3/    94C9 :                     ;
(2)    4/    94C9 :                     ;												IF command
(2)    5/    94C9 :                     ;	
(2)    6/    94C9 :                     ; ****************************************************************************************************************
(2)    7/    94C9 :                     ; ****************************************************************************************************************
(2)    8/    94C9 :                     
(2)    9/    94C9 : 90 4D               	jmp		CIF_Over
(2)   10/    94CB :                     
(2)   11/    94CB :                     CMD_If:
(2)   12/    94CB : 3F                  	xppc 	p3 													; calculate LHS of expr.
(2)   13/    94CC : 94 4A               	jp 		CIF_Over											; exit on error.
(2)   14/    94CE : C1 00               	ld 		(p1)												; get the relative operator.
(2)   15/    94D0 : E4 3D               	xri 	'='													; check it is =, < or #
(2)   16/    94D2 : 98 0E               	jz 		CIF_Continue
(2)   17/    94D4 : E4 1E               	xri 	'='!'#'
(2)   18/    94D6 : 98 0A               	jz 		CIF_Continue
(2)   19/    94D8 : E4 1F               	xri 	'#'!'<'
(2)   20/    94DA : 98 06               	jz 		CIF_Continue
(2)   21/    94DC :                     ;
(2)   22/    94DC :                     ;	Syntax error - bad relative operation.
(2)   23/    94DC :                     ;
(2)   24/    94DC :                     CIF_Syntax:
(2)   25/    94DC : C4 35               	ldi	 	ERRC_Syntax											; report syntax error
(2)   26/    94DE : 01                  	xae
(2)   27/    94DF : 02                  	ccl
(2)   28/    94E0 : 90 36               	jmp 	CIF_Over
(2)   29/    94E2 :                     ;
(2)   30/    94E2 :                     ;	Continue IF - have LHS in E.
(2)   31/    94E2 :                     ;
(2)   32/    94E2 :                     CIF_Continue:
(2)   33/    94E2 : C5 01               	ld 		@1(p1) 												; reget operator, and save on stack
(2)   34/    94E4 : CE FF               	st 		@-1(p2)
(2)   35/    94E6 : 40                  	lde 														; save LHS on stack.
(2)   36/    94E7 : CE FF               	st 		@-1(p2)
 AS V1.42 Beta [Bld 102] - source file minol.asm(if.asm) - page 24 - 1/16/2016 12:24:34


(2)   37/    94E9 : 3F                  	xppc 	p3 													; evaluate the RHS of the expression
(2)   38/    94EA : C6 02               	ld 		@2(p2) 												; drop operator and LHS but the values still there.
(2)   39/    94EC : 06                  	csa 														; check for RHS error
(2)   40/    94ED : 94 29               	jp 		CIF_Over 											; and exit on error
(2)   41/    94EF : C2 FF               	ld 		-1(p2) 												; get operator
(2)   42/    94F1 : E4 3C               	xri 	'<'
(2)   43/    94F3 : 9C 09               	jnz 	CIF_Equality 										; if not less than it's an equality test e.g. # or =
(2)   44/    94F5 :                     
(2)   45/    94F5 :                     ; ****************************************************************************************************************
(2)   46/    94F5 :                     ;												Less than test.
(2)   47/    94F5 :                     ; ****************************************************************************************************************
(2)   48/    94F5 :                     
(2)   49/    94F5 : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   50/    94F7 : 03                  	scl
(2)   51/    94F8 : 78                  	cae 														; subtract RHS.
(2)   52/    94F9 : 06                  	csa 														; get CY/L flag
(2)   53/    94FA : D4 80               	ani 	0x80 												; now it is AC = 0 if < true.
(2)   54/    94FC : 90 0D               	jmp 	CIF_TestIfZero
(2)   55/    94FE :                     
(2)   56/    94FE :                     ; ****************************************************************************************************************
(2)   57/    94FE :                     ;											Equal/Not Equal Test.
(2)   58/    94FE :                     ; ****************************************************************************************************************
(2)   59/    94FE :                     	
(2)   60/    94FE :                     CIF_Equality:
(2)   61/    94FE : C2 FE               	ld 		-2(p2) 												; get LHS
(2)   62/    9500 : 60                  	xre 														; compare to RHS. AC = 0 if *equal*
(2)   63/    9501 : 98 02               	jz 		CIF_Equality2
(2)   64/    9503 : C4 02               	ldi 	2 													; AC = 0 if *equal* 2 if *different*
(2)   65/    9505 :                     CIF_Equality2:
(2)   66/    9505 : 01                  	xae 														; save in E
(2)   67/    9506 : C2 FF               	ld 		-1(p2) 												; get operator.
(2)   68/    9508 : D4 02               	ani 	2 													; is now 0 if '=' ($3D) 2 if '#' ($23)
(2)   69/    950A : 60                  	xre 														; XOR with the result. Now 0 if passes test.
(2)   70/    950B :                     
(2)   71/    950B :                     ; ****************************************************************************************************************
(2)   72/    950B :                     ;							Pass Test (e.g. execute statement following ;) if AC = 0
(2)   73/    950B :                     ; ****************************************************************************************************************
(2)   74/    950B :                     
(2)   75/    950B :                     CIF_TestIfZero:
(2)   76/    950B : 03                  	scl 														; set CY/L = No Error.
(2)   77/    950C : 9C 0A               	jnz 	CIF_Over 											; if non-zero then do next command as normal.
(2)   78/    950E :                     	
(2)   79/    950E : C1 00               	ld 		(p1) 												; get next character
(2)   80/    9510 : E4 3B               	xri 	';'													; should be a semicolon
(2)   81/    9512 : 9C C8               	jnz 	CIF_Syntax 											; if not error
(2)   82/    9514 : C5 01               	ld 		@1(p1) 												; step over it.
(2)   83/    9516 : 90 59               	jmp 	ExecuteFromAddressDirect 							; and run from here.
(2)   84/    9518 :                     
(2)   85/    9518 :                     CIF_Over:
(2)   86/    9518 :                     
(2)   87/    9518 :                     
(1)   22/    9518 :                     	include source\commands\goto_run.asm						; GOTO and RUN (has to be last, probably !)
(2)    1/    9518 :                     ; ****************************************************************************************************************
(2)    2/    9518 :                     ; ****************************************************************************************************************
(2)    3/    9518 :                     ;
(2)    4/    9518 :                     ;												GOTO and RUN
(2)    5/    9518 :                     ;	
(2)    6/    9518 :                     ; ****************************************************************************************************************
(2)    7/    9518 :                     ; ****************************************************************************************************************
(2)    8/    9518 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(goto_run.asm) - page 25 - 1/16/2016 12:24:34


(2)    9/    9518 : 90 29               	jmp 	CRG_Over											; Skip over this command.
(2)   10/    951A :                     
(2)   11/    951A :                     ; ****************************************************************************************************************
(2)   12/    951A :                     ;												GOTO command
(2)   13/    951A :                     ; ****************************************************************************************************************
(2)   14/    951A :                     
(2)   15/    951A :                     CMD_Goto:	
(2)   16/    951A : 3F                  	xppc 	p3 													; evaluate the line number to GOTO, in E
(2)   17/    951B : 94 26               	jp 		CRG_Over 											; exit if error occurred
(2)   18/    951D : 40                  	lde 														; get line number
(2)   19/    951E : CA FF               	st 		-1(p2) 												; save below TOS.
(2)   20/    9520 : (MACRO)             	lpi 	p1,ProgramBase 										; point P1 to program Base.
(2)   20/    9520 : C4 10                       ldi     (PROGRAMBASE) / 256
(2)   20/    9522 : 35                          xpah    P1
(2)   20/    9523 : C4 04                       ldi     (PROGRAMBASE) & 255
(2)   20/    9525 : 31                          xpal    P1
(2)   21/    9526 :                     CRG_Find:
(2)   22/    9526 : C1 00               	ld 		0(p1) 												; look at offset
(2)   23/    9528 : 94 06               	jp 		CRG_NotEnd											; if -ve then end of program.
(2)   24/    952A : C4 31               	ldi 	ERRC_Label 											; return label error
(2)   25/    952C : 01                  	xae
(2)   26/    952D : 02                  	ccl 														; set error flag
(2)   27/    952E : 90 13               	jmp 	CRG_Over
(2)   28/    9530 :                     ;
(2)   29/    9530 :                     CRG_NotEnd:
(2)   30/    9530 : 01                  	xae 														; offset in E
(2)   31/    9531 : C1 01               	ld 		1(p1) 												; get line number
(2)   32/    9533 : E2 FF               	xor 	-1(p2) 												; go back if not required one.
(2)   33/    9535 : 98 0A               	jz 		CRG_ExecuteFromP1									; if found, run from P1.
(2)   34/    9537 : C5 80               	ld 		@-0x80(p1) 											; go to next line
(2)   35/    9539 : 90 EB               	jmp 	CRG_Find 											; keep trying.
(2)   36/    953B :                     ;
(2)   37/    953B :                     ; ****************************************************************************************************************
(2)   38/    953B :                     ;												RUN command
(2)   39/    953B :                     ; ****************************************************************************************************************
(2)   40/    953B :                     
(2)   41/    953B :                     CMD_Run:	
(2)   42/    953B : (MACRO)             	lpi 	p1,ProgramBase 										; start from first line of program
(2)   42/    953B : C4 10                       ldi     (PROGRAMBASE) / 256
(2)   42/    953D : 35                          xpah    P1
(2)   42/    953E : C4 04                       ldi     (PROGRAMBASE) & 255
(2)   42/    9540 : 31                          xpal    P1
(2)   43/    9541 :                     CRG_ExecuteFromP1:
(2)   44/    9541 : 90 0D               	jmp 	CheckLastCommandThenExecute 						; check if the last command and if not execute.
(2)   45/    9543 :                     
(2)   46/    9543 :                     CRG_Over:
(2)   47/    9543 :                     
(1)   23/    9543 :                     
(1)   24/    9543 :                     ; ****************************************************************************************************************
(1)   25/    9543 :                     ;								Command execution complete, check for error
(1)   26/    9543 :                     ; ****************************************************************************************************************
(1)   27/    9543 :                     
(1)   28/    9543 :                     EndOfCommandExecution:
(1)   29/    9543 : 06                  	csa 														; check CY/L error flag
(1)   30/    9544 : 94 12               	jp 		GotoCommandLine 									; if CY/L = 0 error so go to command line.
(1)   31/    9546 :                     
(1)   32/    9546 :                     ; ****************************************************************************************************************
(1)   33/    9546 :                     ;	Come here to execute the instruction P1 points to, after having executed, e.g. skips forward to : or NULL
(1)   34/    9546 :                     ; ****************************************************************************************************************
(1)   35/    9546 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 26 - 1/16/2016 12:24:34


(1)   36/    9546 :                     ExecuteNextInstruction:
(1)   37/    9546 : C5 01               	ld 		@1(p1) 												; get next and skip
(1)   38/    9548 : 98 06               	jz 		CheckLastCommandThenExecute							; if NULL, check if running mode and continue if so.
(1)   39/    954A : E4 3A               	xri 	':'
(1)   40/    954C : 9C F8               	jnz 	ExecuteNextInstruction 								; keep going until colon read.
(1)   41/    954E : 90 21               	jmp 	ExecuteFromAddressDirect 							; run code from the address given.
(1)   42/    9550 :                     ;
(1)   43/    9550 :                     ;	Test to see if the line is not the last one (e.g. offset is +ve) and if so, execute its code.
(1)   44/    9550 :                     ;
(1)   45/    9550 :                     CheckLastCommandThenExecute:
(1)   46/    9550 : C1 00               	ld 		(p1) 												; look at the offset to next.
(1)   47/    9552 : 94 11               	jp 		ExecuteFromCommandStart 							; if +ve value, execute the line here.
(1)   48/    9554 :                     ;
(1)   49/    9554 :                     ;	Have reached the end of the program. The buffer with typed commands has $FF on the end to 'fake' this.
(1)   50/    9554 :                     ; 	e.g. when it reaches the end of that command it thinks it's dropped off the top of the program
(1)   51/    9554 :                     ;
(1)   52/    9554 : 03                  	scl 														; there is no error.
(1)   53/    9555 : C4 FF               	ldi 	ERRC_End 											; set the error code to "End"
(1)   54/    9557 : 01                  	xae
(1)   55/    9558 :                     GotoCommandLine: 												; return to Command Line with CY/L = error and E = code
(1)   56/    9558 : (MACRO)             	lpi 	p3,ConsoleStart-1
(1)   56/    9558 : C4 98                       ldi     (CONSOLESTART-1) / 256
(1)   56/    955A : 37                          xpah    P3
(1)   56/    955B : C4 53                       ldi     (CONSOLESTART-1) & 255
(1)   56/    955D : 33                          xpal    P3
(1)   57/    955E : 3F                  	xppc 	p3
(1)   58/    955F :                     ;
(1)   59/    955F :                     ;	Syntax error comes here.
(1)   60/    955F :                     ;
(1)   61/    955F :                     SyntaxError:
(1)   62/    955F : C4 35               	ldi 	ERRC_Syntax
(1)   63/    9561 : 01                  	xae
(1)   64/    9562 : 02                  	ccl
(1)   65/    9563 : 90 F3               	jmp 	GotoCommandLine
(1)   66/    9565 :                     
(1)   67/    9565 :                     ; ****************************************************************************************************************
(1)   68/    9565 :                     ;	  Execute from the instruction at P1 (preceded by offset, line number), which is known to be a valid line.
(1)   69/    9565 :                     ; ****************************************************************************************************************
(1)   70/    9565 :                     
(1)   71/    9565 :                     ExecuteFromCommandStart:
(1)   72/    9565 : (MACRO)             	lpi 	p3,CurrentLine 										; point P3 to the current line
(1)   72/    9565 : C4 0C                       ldi     (CURRENTLINE) / 256
(1)   72/    9567 : 37                          xpah    P3
(1)   72/    9568 : C4 8D                       ldi     (CURRENTLINE) & 255
(1)   72/    956A : 33                          xpal    P3
(1)   73/    956B : C1 01               	ld 		1(p1) 												; read the line number 
(1)   74/    956D : CB 00               	st 		(p3)												; and save it - current line # updated.
(1)   75/    956F : C5 02               	ld 		@2(p1) 												; skip over offset (+0) line number (+1)
(1)   76/    9571 :                     
(1)   77/    9571 :                     ; ****************************************************************************************************************
(1)   78/    9571 :                     ;				Run command where the instruction is at P1 (e.g. it is an ASCIIZ string)
(1)   79/    9571 :                     ; ****************************************************************************************************************
(1)   80/    9571 :                     
(1)   81/    9571 :                     ExecuteFromAddressDirect:
(1)   82/    9571 : C5 01               	ld 		@1(p1) 												; read next character
(1)   83/    9573 : 98 DB               	jz 		CheckLastCommandThenExecute 						; if \0 then check for the next line.
(1)   84/    9575 : E4 20               	xri	 	' '
(1)   85/    9577 : 98 F8               	jz 		ExecuteFromAddressDirect 							; skip over spaces.
(1)   86/    9579 : E4 1A               	xri 	' '!':'												
(1)   87/    957B : 98 F4               	jz 		ExecuteFromAddressDirect 							; skip over colons.
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 27 - 1/16/2016 12:24:34


(1)   88/    957D : E4 18               	xri 	':'!'"'					
(1)   89/    957F : 98 C5               	jz 		ExecuteNextInstruction 								; if double quote (comment) found go to next instruction.
(1)   90/    9581 :                     ;
(1)   91/    9581 :                     ;	Now look the command up in the command list.
(1)   92/    9581 :                     ;
(1)   93/    9581 : C1 FF               	ld 		-1(p1) 												; read first character of command again
(1)   94/    9583 : 01                  	xae 														; put in E.
(1)   95/    9584 : (MACRO)             	lpi 	p3,CommandList
(1)   95/    9584 : C4 97                       ldi     (COMMANDLIST) / 256
(1)   95/    9586 : 37                          xpah    P3
(1)   95/    9587 : C4 62                       ldi     (COMMANDLIST) & 255
(1)   95/    9589 : 33                          xpal    P3
(1)   96/    958A :                     EAFD_Search:
(1)   97/    958A : C7 05               	ld 		@5(p3) 												; read first character and bump to next.
(1)   98/    958C : 98 2C               	jz 		EAFD_LETCode 										; if zero then give up.
(1)   99/    958E : 60                  	xre 														; same as first character ?
(1)  100/    958F : 9C F9               	jnz		EAFD_Search 										; no, keep looking.
(1)  101/    9591 :                     
(1)  102/    9591 : C3 FC               	ld 		-4(p3) 												; read 2nd character
(1)  103/    9593 : E1 00               	xor 	(p1) 												; compare against actual second character
(1)  104/    9595 : 9C F3               	jnz 	EAFD_Search
(1)  105/    9597 :                     ;
(1)  106/    9597 :                     ;	Skip over characters in the command, checking for NULL and : which would be syntax errors.
(1)  107/    9597 :                     ;
(1)  108/    9597 : C3 FD               	ld 		-3(p3) 												; number of characters to skip (one less than total as one skipped)
(1)  109/    9599 : CA FF               	st 		-1(p2) 												; temporary count.
(1)  110/    959B :                     EAFD_Skip:
(1)  111/    959B : C5 01               	ld 		@1(p1) 												; read a character and skip
(1)  112/    959D : 98 C0               	jz 		SyntaxError 										; if zero, then syntax error
(1)  113/    959F : E4 3A               	xri 	':'
(1)  114/    95A1 : 98 BC               	jz 		SyntaxError 										; if colon, then syntax error.
(1)  115/    95A3 : BA FF               	dld 	-1(p2) 												; do it the requisite number of times.
(1)  116/    95A5 : 9C F4               	jnz 	EAFD_Skip
(1)  117/    95A7 :                     ;
(1)  118/    95A7 :                     ;	Skip over any subsequent spaces
(1)  119/    95A7 :                     ;
(1)  120/    95A7 :                     EAFD_SkipSpaces:
(1)  121/    95A7 : C5 01               	ld 		@1(p1) 												; check for spaces
(1)  122/    95A9 : E4 20               	xri 	' '													; space found
(1)  123/    95AB : 98 FA               	jz 		EAFD_SkipSpaces
(1)  124/    95AD : C5 FF               	ld 		@-1(p1) 											; undo last fetch so first character of next bit.
(1)  125/    95AF :                     ;
(1)  126/    95AF :                     ;	P1 is set up so execute the handler.
(1)  127/    95AF :                     ;
(1)  128/    95AF : C3 FE               	ld 		-2(p3)												; get execute LSB
(1)  129/    95B1 : 01                  	xae 														; save in E
(1)  130/    95B2 : C3 FF               	ld 		-1(p3) 												; get execute MSB
(1)  131/    95B4 : 37                  	xpah 	p3 													; put in P3.H
(1)  132/    95B5 : 40                  	lde 														; copy E to P3.L
(1)  133/    95B6 : 33                  	xpal 	p3
(1)  134/    95B7 : 3F                  	xppc 	p3
(1)  135/    95B8 : 90 0B               	jmp 	EvaluateExpression 									; is set up to have immediate evaluate call.
(1)  136/    95BA :                     ;
(1)  137/    95BA :                     ;	Couldn't find a command, so point P1 to first character, then call the LET code.
(1)  138/    95BA :                     ;
(1)  139/    95BA :                     EAFD_LETCode:
(1)  140/    95BA : C5 FF               	ld 		@-1(p1) 											; point P1 to first character of command.
(1)  141/    95BC : (MACRO)             	lpi 	p3,CMD_Let-1 										; go execute LET with evaluate re-entrancy
(1)  141/    95BC : C4 94                       ldi     (CMD_LET-1) / 256
(1)  141/    95BE : 37                          xpah    P3
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 28 - 1/16/2016 12:24:34


(1)  141/    95BF : C4 77                       ldi     (CMD_LET-1) & 255
(1)  141/    95C1 : 33                          xpal    P3
(1)  142/    95C2 : 3F                  	xppc 	p3
(1)  143/    95C3 : 90 00               	jmp 	EvaluateExpression
(1)  144/    95C5 :                     
(1)  145/    95C5 :                     	include source\expression.asm 								; expression evaluator.
(2)    1/    95C5 :                     ; ****************************************************************************************************************
(2)    2/    95C5 :                     ; ****************************************************************************************************************
(2)    3/    95C5 :                     ;
(2)    4/    95C5 :                     ;												Expression Evaluation
(2)    5/    95C5 :                     ;
(2)    6/    95C5 :                     ; ****************************************************************************************************************
(2)    7/    95C5 :                     ; ****************************************************************************************************************
(2)    8/    95C5 :                     
(2)    9/    95C5 :                     ; ****************************************************************************************************************
(2)   10/    95C5 :                     ; ****************************************************************************************************************
(2)   11/    95C5 :                     ;
(2)   12/    95C5 :                     ;		Evaluate expression at P1. Return 	CY/L = 0 : Error 	E = Error Code
(2)   13/    95C5 :                     ;											CY/L = 1 : Okay 	E = Result
(2)   14/    95C5 :                     ;
(2)   15/    95C5 :                     ;		Terms are : 	A-Z 			Variables
(2)   16/    95C5 :                     ;						[0-9]+			Constants
(2)   17/    95C5 :                     ;						! 				Random byte
(2)   18/    95C5 :                     ;						'?'				Character constant
(2)   19/    95C5 :                     ;						(<expr>,<expr>)	Read Memory location
(2)   20/    95C5 :                     ;
(2)   21/    95C5 :                     ; ****************************************************************************************************************
(2)   22/    95C5 :                     ; ****************************************************************************************************************
(2)   23/    95C5 :                     
(2)   24/    95C5 : =0x1                EEX_PendingOp = 1 												; offset to pending operation
(2)   25/    95C5 : =0x0                EEX_Value = 0 													; offset to value
(2)   26/    95C5 :                     
(2)   27/    95C5 :                     EvaluateExpression:
(2)   28/    95C5 : (MACRO)             	pushp 	p3 													; save P3 on stack
(2)   28/    95C5 : 37                          xpah    P3
(2)   28/    95C6 : CE FF                       st              @-1(p2)
(2)   28/    95C8 : 33                          xpal    P3
(2)   28/    95C9 : CE FF                       st              @-1(p2)
(2)   29/    95CB : C4 2B               	ldi 	'+'													; push pending operation on stack
(2)   30/    95CD : CE FF               	st 		@-1(p2)
(2)   31/    95CF : C4 00               	ldi 	0 													; push current value on stack
(2)   32/    95D1 : CE FF               	st 		@-1(p2)												; effectively this puts 0+ on the front of the expression.
(2)   33/    95D3 :                     
(2)   34/    95D3 :                     ; ****************************************************************************************************************
(2)   35/    95D3 :                     ;													Get Next Term
(2)   36/    95D3 :                     ; ****************************************************************************************************************
(2)   37/    95D3 :                     
(2)   38/    95D3 :                     EEX_Term:
(2)   39/    95D3 : (MACRO)             	lpi 	p3,Variables 										; point P3 to variables
(2)   39/    95D3 : C4 0C                       ldi     (VARIABLES) / 256
(2)   39/    95D5 : 37                          xpah    P3
(2)   39/    95D6 : C4 90                       ldi     (VARIABLES) & 255
(2)   39/    95D8 : 33                          xpal    P3
(2)   40/    95D9 :                     EEX_NextChar:
(2)   41/    95D9 : C1 00               	ld 		(p1) 												; look at character
(2)   42/    95DB : 98 4F               	jz 		EEX_TermError
(2)   43/    95DD : C5 01               	ld 		@1(p1) 												; fetch and skip over.
(2)   44/    95DF : E4 20               	xri 	' '													; is it space ?
(2)   45/    95E1 : 98 F6               	jz 		EEX_NextChar
(2)   46/    95E3 : E4 08               	xri 	' '!'('												; is it memory access ?
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 29 - 1/16/2016 12:24:34


(2)   47/    95E5 : 98 55               	jz 		EEX_MemoryAccess
(2)   48/    95E7 : E4 09               	xri 	'('!'!'												; is it a random value ?
(2)   49/    95E9 : 9C 1B               	jnz 	EEX_NotRandom
(2)   50/    95EB :                     
(2)   51/    95EB :                     ; ****************************************************************************************************************
(2)   52/    95EB :                     ;												Term is ! (random byte)
(2)   53/    95EB :                     ; ****************************************************************************************************************
(2)   54/    95EB :                     
(2)   55/    95EB :                     EEX_Random:
(2)   56/    95EB : 02                  	ccl 	
(2)   57/    95EC : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; shift the seed right
(2)   58/    95EE : 1F                  	rrl
(2)   59/    95EF : CB FF               	st 		RandomSeed+1-Variables(p3)
(2)   60/    95F1 : 01                  	xae 														; put MSB in E
(2)   61/    95F2 : C3 FE               	ld 		RandomSeed-Variables(p3)
(2)   62/    95F4 : 1F                  	rrl
(2)   63/    95F5 : CB FE               	st 		RandomSeed-Variables(p3)
(2)   64/    95F7 : 60                  	xre 														; XOR E into LSB
(2)   65/    95F8 : 01                  	xae
(2)   66/    95F9 : 06                  	csa 														; if CY/L is zero
(2)   67/    95FA : D4 80               	ani 	0x80
(2)   68/    95FC : 9C 06               	jnz 	EEX_NoTap 
(2)   69/    95FE : C3 FF               	ld 		RandomSeed+1-Variables(p3) 							; XOR MSB with $B4
(2)   70/    9600 : E4 B4               	xri 	0xB4
(2)   71/    9602 : CB FF               	st 		RandomSeed+1-Variables(p3)
(2)   72/    9604 :                     EEX_NoTap:
(2)   73/    9604 : 90 64               	jmp 	EEX_HaveTerm
(2)   74/    9606 :                     
(2)   75/    9606 :                     EEX_NotRandom:
(2)   76/    9606 : E4 06               	xri 	'!'!0x27											; is it a quote ?
(2)   77/    9608 : 9C 0F               	jnz 	EEX_NotQuote
(2)   78/    960A :                     
(2)   79/    960A :                     ; ****************************************************************************************************************
(2)   80/    960A :                     ;													Term is '<char>'
(2)   81/    960A :                     ; ****************************************************************************************************************
(2)   82/    960A :                     
(2)   83/    960A : C1 00               	ld 		(p1) 												; get character that is quoted
(2)   84/    960C : 98 1E               	jz 		EEX_TermError 										; if zero, error.
(2)   85/    960E : 01                  	xae 														; save in E if okay character.
(2)   86/    960F : C1 01               	ld 		1(p1) 												; get character after that
(2)   87/    9611 : E4 27               	xri 	0x27 												; is it a quote ?
(2)   88/    9613 : 9C 17               	jnz 	EEX_TermError
(2)   89/    9615 : C5 02               	ld 		@2(p1) 												; skip over character and quote
(2)   90/    9617 : 90 51               	jmp 	EEX_HaveTerm 										; and execute as if a legal term
(2)   91/    9619 :                     
(2)   92/    9619 :                     ; ****************************************************************************************************************
(2)   93/    9619 :                     ;									Not 'x' or !, so test for 0-9 and A-Z
(2)   94/    9619 :                     ; ****************************************************************************************************************
(2)   95/    9619 :                     
(2)   96/    9619 :                     EEX_NotQuote:
(2)   97/    9619 : C1 FF               	ld 		-1(p1)												; get old character.
(2)   98/    961B : 02                  	ccl
(2)   99/    961C : F4 A5               	adi 	255-'Z'												; if >= 'Z' then error.										
(2)  100/    961E : 94 0C               	jp 		EEX_TermError
(2)  101/    9620 : F4 1A               	adi 	26 													; will be 0..25 if A..Z
(2)  102/    9622 : 94 42               	jp 		EEX_Variable 										; so do as a variable.
(2)  103/    9624 : F4 07               	adi 	'A'-1-'9'											; check if > 9
(2)  104/    9626 : 94 04               	jp 		EEX_TermError
(2)  105/    9628 : F4 0A               	adi 	10 													; if 0-9
(2)  106/    962A : 94 1D               	jp 		EEX_Constant
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 30 - 1/16/2016 12:24:34


(2)  107/    962C :                     
(2)  108/    962C :                     ; ****************************************************************************************************************
(2)  109/    962C :                     ;													 Error Exit.
(2)  110/    962C :                     ; ****************************************************************************************************************
(2)  111/    962C :                     
(2)  112/    962C :                     EEX_TermError:
(2)  113/    962C : C4 34               	ldi 	ERRC_Term 											; put term error in A
(2)  114/    962E :                     EEX_Error:
(2)  115/    962E : 01                  	xae 														; put error code in E
(2)  116/    962F : 02                  	ccl 														; clear CY/L indicating error
(2)  117/    9630 :                     EEX_Exit:
(2)  118/    9630 : C6 02               	ld 		@2(p2) 												; throw the pending operation and value
(2)  119/    9632 : (MACRO)             	pullp 	p3 													; restore P3
(2)  119/    9632 : C6 01                       ld              @1(p2)
(2)  119/    9634 : 33                          xpal    P3
(2)  119/    9635 : C6 01                       ld              @1(p2)
(2)  119/    9637 : 37                          xpah    P3
(2)  120/    9638 : 06                  	csa 														; put CY/L in A bit 7
(2)  121/    9639 : 3F                  	xppc 	p3 													; and exit
(2)  122/    963A : 90 89               	jmp 	EvaluateExpression 									; make re-entrant
(2)  123/    963C :                     
(2)  124/    963C :                     ; ****************************************************************************************************************
(2)  125/    963C :                     ;										Handle (<expr>,<expr>)
(2)  126/    963C :                     ; ****************************************************************************************************************
(2)  127/    963C :                     
(2)  128/    963C :                     EEX_MemoryAccess:
(2)  129/    963C : C5 FF               	ld 		@-1(p1) 											; point to the (
(2)  130/    963E : (MACRO)             	lpi 	p3,EvaluateAddressPair-1 							; call the evaluate/read of (h,l)
(2)  130/    963E : C4 97                       ldi     (EVALUATEADDRESSPAIR-1) / 256
(2)  130/    9640 : 37                          xpah    P3
(2)  130/    9641 : C4 17                       ldi     (EVALUATEADDRESSPAIR-1) & 255
(2)  130/    9643 : 33                          xpal    P3
(2)  131/    9644 : 3F                  	xppc 	p3
(2)  132/    9645 : 94 E9               	jp 		EEX_Exit 											; error occurred, so exit with it.
(2)  133/    9647 : 90 21               	jmp 	EEX_HaveTerm
(2)  134/    9649 :                     
(2)  135/    9649 :                     ; ****************************************************************************************************************
(2)  136/    9649 :                     ;								Handle constant, first digit value is in A
(2)  137/    9649 :                     ; ****************************************************************************************************************
(2)  138/    9649 :                     
(2)  139/    9649 :                     EEX_Constant:
(2)  140/    9649 : 01                  	xae 														; put first digit value in E
(2)  141/    964A :                     EEX_ConstantLoop:
(2)  142/    964A : C1 00               	ld 		(p1) 												; get next character.
(2)  143/    964C : 02                  	ccl
(2)  144/    964D : F4 C6               	adi 	255-'9' 											; if >= 9 term is too large.
(2)  145/    964F : 94 19               	jp 		EEX_HaveTerm
(2)  146/    9651 : F4 8A               	adi 	10+128
(2)  147/    9653 : 94 15               	jp 		EEX_HaveTerm
(2)  148/    9655 : 02                  	ccl
(2)  149/    9656 : 40                  	lde 														; A = n
(2)  150/    9657 : 70                  	ade 														; A = n * 2
(2)  151/    9658 : 70                  	ade 														; A = n * 3
(2)  152/    9659 : 70                  	ade 														; A = n * 4
(2)  153/    965A : 70                  	ade 														; A = n * 5
(2)  154/    965B : 01                  	xae 														; E = n * 5
(2)  155/    965C : C5 01               	ld 		@1(p1) 												; read character convert to number
(2)  156/    965E : D4 0F               	ani 	0x0F
(2)  157/    9660 : 02                  	ccl
(2)  158/    9661 : 70                  	ade 														; Add n*5 twice
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 31 - 1/16/2016 12:24:34


(2)  159/    9662 : 70                  	ade 
(2)  160/    9663 : 01                  	xae
(2)  161/    9664 : 90 E4               	jmp 	EEX_ConstantLoop
(2)  162/    9666 :                     
(2)  163/    9666 :                     
(2)  164/    9666 :                     ; ****************************************************************************************************************
(2)  165/    9666 :                     ;									Access variable, variable id (0-25) in A
(2)  166/    9666 :                     ; ****************************************************************************************************************
(2)  167/    9666 :                     
(2)  168/    9666 :                     EEX_Variable:
(2)  169/    9666 : 01                  	xae 														; put value 0-25 in E
(2)  170/    9667 : C3 80               	ld 		-0x80(p3) 											; load using E as index
(2)  171/    9669 : 01                  	xae 														; put in E
(2)  172/    966A :                     
(2)  173/    966A :                     ; ****************************************************************************************************************
(2)  174/    966A :                     ;										Have the right term in E, process it
(2)  175/    966A :                     ; ****************************************************************************************************************
(2)  176/    966A :                     
(2)  177/    966A :                     EEX_HaveTerm:
(2)  178/    966A : C2 01               	ld 		EEX_PendingOp(p2) 									; get pending operation.
(2)  179/    966C : E4 2B               	xri 	'+'
(2)  180/    966E : 9C 06               	jnz 	EEX_NotAdd
(2)  181/    9670 :                     
(2)  182/    9670 :                     ; ****************************************************************************************************************
(2)  183/    9670 :                     ;												Add Right Term to Value
(2)  184/    9670 :                     ; ****************************************************************************************************************
(2)  185/    9670 : 02                  	ccl
(2)  186/    9671 : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  187/    9673 : 70                  	ade 														; add right
(2)  188/    9674 : 90 08               	jmp 	EEX_SaveAndExit 									; save and exit
(2)  189/    9676 :                     
(2)  190/    9676 :                     EEX_NotAdd:
(2)  191/    9676 : E4 06               	xri 	'+'!'-'
(2)  192/    9678 : 9C 12               	jnz		EEX_NotSubtract
(2)  193/    967A :                     
(2)  194/    967A :                     ; ****************************************************************************************************************
(2)  195/    967A :                     ;											 Subtract Right Term from Value
(2)  196/    967A :                     ; ****************************************************************************************************************
(2)  197/    967A : 03                  	scl
(2)  198/    967B : C2 00               	ld 		EEX_Value(p2)										; get value
(2)  199/    967D : 78                  	cae 														; subtract right
(2)  200/    967E :                     EEX_SaveAndExit:
(2)  201/    967E : CA 00               	st 		EEX_Value(p2) 										; save value back
(2)  202/    9680 : 90 30               	jmp 	EEX_CheckNextOperation 								; and exit, look for next operator.
(2)  203/    9682 :                     
(2)  204/    9682 :                     EEX_Divide_Zero:												; handle divide by zero error.
(2)  205/    9682 : C4 37               	ldi 	ERRC_DivZero
(2)  206/    9684 : 90 A8               	jmp 	EEX_Error
(2)  207/    9686 :                     
(2)  208/    9686 :                     EEX_EndExpression:
(2)  209/    9686 : C2 00               	ld 		EEX_Value(p2) 										; get current value
(2)  210/    9688 : 01                  	xae 														; put in E
(2)  211/    9689 : 03                  	scl 														; set CY/L indicating expression okay.
(2)  212/    968A : 90 A4               	jmp 	EEX_Exit 											; and exit.
(2)  213/    968C :                     
(2)  214/    968C :                     EEX_NotSubtract:
(2)  215/    968C : E4 07               	xri 	'-'!'*'
(2)  216/    968E : 9C 45               	jnz 	EEX_Divide
(2)  217/    9690 :                     
(2)  218/    9690 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 32 - 1/16/2016 12:24:34


(2)  219/    9690 :                     ;											 Multiply Right Term into Value
(2)  220/    9690 :                     ; ****************************************************************************************************************
(2)  221/    9690 :                     
(2)  222/    9690 : C2 00               	ld 		EEX_Value(p2) 										; a = left value
(2)  223/    9692 : CA 01               	st 		1(p2)
(2)  224/    9694 : C4 00               	ldi 	0													; res = 0(p2)
(2)  225/    9696 : CA 00               	st 		0(p2) 												; clear it.
(2)  226/    9698 :                     EEX_MultiplyLoop:
(2)  227/    9698 : 40                  	lde  														; if B == 0 then we are done.
(2)  228/    9699 : 98 17               	jz 		EEX_CheckNextOperation
(2)  229/    969B : D4 01               	ani 	1 													; if B LSB is non zero.
(2)  230/    969D : 98 07               	jz 		EEX_Multiply_B0IsZero
(2)  231/    969F : C2 00               	ld 		0(p2) 												; add A to Result
(2)  232/    96A1 : 02                  	ccl
(2)  233/    96A2 : F2 01               	add 	1(p2)
(2)  234/    96A4 : CA 00               	st 		0(p2)
(2)  235/    96A6 :                     EEX_Multiply_B0IsZero:
(2)  236/    96A6 : 40                  	lde 														; shift B right
(2)  237/    96A7 : 1C                  	sr
(2)  238/    96A8 : 01                  	xae
(2)  239/    96A9 : C2 01               	ld 		1(p2) 												; shift A left
(2)  240/    96AB : 02                  	ccl
(2)  241/    96AC : F2 01               	add 	1(p2)
(2)  242/    96AE : CA 01               	st 		1(p2)
(2)  243/    96B0 : 90 E6               	jmp 	EEX_MultiplyLoop
(2)  244/    96B2 :                     
(2)  245/    96B2 :                     ; ****************************************************************************************************************
(2)  246/    96B2 :                     ;											Check next operation
(2)  247/    96B2 :                     ; ****************************************************************************************************************
(2)  248/    96B2 :                     
(2)  249/    96B2 :                     EEX_CheckNextOperation:
(2)  250/    96B2 : C5 01               	ld 		@1(p1)												; skip over spaces
(2)  251/    96B4 : E4 20               	xri 	' '
(2)  252/    96B6 : 98 FA               	jz 		EEX_CheckNextOperation
(2)  253/    96B8 : C5 FF               	ld 		@-1(p1)												; get operator
(2)  254/    96BA : E4 2B               	xri 	'+'													; check if + - * /
(2)  255/    96BC : 98 0C               	jz 		EEX_FoundOperator
(2)  256/    96BE : E4 06               	xri 	'+'!'-'
(2)  257/    96C0 : 98 08               	jz 		EEX_FoundOperator
(2)  258/    96C2 : E4 07               	xri 	'-'!'*'
(2)  259/    96C4 : 98 04               	jz 		EEX_FoundOperator
(2)  260/    96C6 : E4 05               	xri 	'*'!'/'
(2)  261/    96C8 : 9C BC               	jnz 	EEX_EndExpression
(2)  262/    96CA :                     
(2)  263/    96CA :                     EEX_FoundOperator:
(2)  264/    96CA : C5 01               	ld  	@1(p1) 												; get and skip operator
(2)  265/    96CC : CA 01               	st 		EEX_PendingOp(p2)									; save then pending operator
(2)  266/    96CE : (MACRO)             	lpi 	p3,EEX_Term-1
(2)  266/    96CE : C4 95                       ldi     (EEX_TERM-1) / 256
(2)  266/    96D0 : 37                          xpah    P3
(2)  266/    96D1 : C4 D2                       ldi     (EEX_TERM-1) & 255
(2)  266/    96D3 : 33                          xpal    P3
(2)  267/    96D4 : 3F                  	xppc 	p3
(2)  268/    96D5 :                     
(2)  269/    96D5 :                     ; ****************************************************************************************************************
(2)  270/    96D5 :                     ;											 Divide Right Term into Value
(2)  271/    96D5 :                     ; ****************************************************************************************************************
(2)  272/    96D5 :                     
(2)  273/    96D5 :                     EEX_Divide:
(2)  274/    96D5 : 40                  	lde 														; if denominator zero, error 2.
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 33 - 1/16/2016 12:24:34


(2)  275/    96D6 : 98 AA               	jz 		EEX_Divide_Zero
(2)  276/    96D8 : C2 00               	ld 		0(p2) 												; numerator into 1(p2)
(2)  277/    96DA : CA 01               	st 		1(p2) 												; denominator is in E
(2)  278/    96DC : C4 00               	ldi 	0
(2)  279/    96DE : CA 00               	st 		0(p2)												; quotient in 0(p2)
(2)  280/    96E0 : CA FF               	st 		-1(p2) 												; remainder in -1(p2)
(2)  281/    96E2 : C4 80               	ldi 	0x80 									
(2)  282/    96E4 : CA FE               	st 		-2(p2) 												; bit in -2(p2)
(2)  283/    96E6 :                     
(2)  284/    96E6 :                     EEX_Divide_Loop:
(2)  285/    96E6 : C2 FE               	ld 		-2(p2) 												; exit if bit = 0,we've finished.
(2)  286/    96E8 : 98 C8               	jz 		EEX_CheckNextOperation
(2)  287/    96EA :                     
(2)  288/    96EA : 02                  	ccl 	 													; shift remainder left.
(2)  289/    96EB : C2 FF               	ld 		-1(p2)
(2)  290/    96ED : F2 FF               	add 	-1(p2)
(2)  291/    96EF : CA FF               	st 		-1(p2)
(2)  292/    96F1 :                     
(2)  293/    96F1 : C2 01               	ld 		1(p2)												; get numerator.
(2)  294/    96F3 : 94 02               	jp 		EEX_Divide_Numerator_Positive
(2)  295/    96F5 : AA FF               	ild 	-1(p2)  											; if numerator -ve, increment remainder.
(2)  296/    96F7 :                     EEX_Divide_Numerator_Positive:
(2)  297/    96F7 :                     
(2)  298/    96F7 : C2 FF               	ld 		-1(p2) 												; calculate remainder - denominator
(2)  299/    96F9 : 03                  	scl
(2)  300/    96FA : 78                  	cae 
(2)  301/    96FB : CA FD               	st 		-3(p2) 												; save in temp -3(p2)
(2)  302/    96FD : 06                  	csa 														; if temp >= 0, CY/L is set
(2)  303/    96FE : 94 0A               	jp 		EEX_Divide_Temp_Positive
(2)  304/    9700 :                     
(2)  305/    9700 : C2 FD               	ld 		-3(p2) 												; copy temp to remainder
(2)  306/    9702 : CA FF               	st 		-1(p2)
(2)  307/    9704 : C2 FE               	ld 		-2(p2) 												; or bit into quotient
(2)  308/    9706 : DA 00               	or 		0(p2)
(2)  309/    9708 : CA 00               	st 		0(p2)
(2)  310/    970A :                     EEX_Divide_Temp_Positive:
(2)  311/    970A : C2 FE               	ld 		-2(p2) 												; shift bit right
(2)  312/    970C : 1C                  	sr
(2)  313/    970D : CA FE               	st 		-2(p2)
(2)  314/    970F :                     
(2)  315/    970F : C2 01               	ld 		1(p2)												; shift numerator positive
(2)  316/    9711 : 02                  	ccl
(2)  317/    9712 : F2 01               	add 	1(p2)
(2)  318/    9714 : CA 01               	st 		1(p2)
(2)  319/    9716 : 90 CE               	jmp 	EEX_Divide_Loop
(2)  320/    9718 :                     
(2)  321/    9718 :                     ; ****************************************************************************************************************
(2)  322/    9718 :                     ; ****************************************************************************************************************
(2)  323/    9718 :                     ;
(2)  324/    9718 :                     ;	Evaluate an address pair at P1 e.g. (<expr>,<expr>).  Returns as for expression, but stack-2, stack-1 are
(2)  325/    9718 :                     ;	the address (the data at that address is in E if no error occurs). Used for reading and writing.
(2)  326/    9718 :                     ;
(2)  327/    9718 :                     ; ****************************************************************************************************************
(2)  328/    9718 :                     ; ****************************************************************************************************************
(2)  329/    9718 :                     
(2)  330/    9718 :                     EvaluateAddressPair:
(2)  331/    9718 : C6 FE               	ld 		@-2(p2)												; make space to store HL
(2)  332/    971A : (MACRO)             	pushp 	p3 													; save return address.
(2)  332/    971A : 37                          xpah    P3
(2)  332/    971B : CE FF                       st              @-1(p2)
 AS V1.42 Beta [Bld 102] - source file minol.asm(expression.asm) - page 34 - 1/16/2016 12:24:34


(2)  332/    971D : 33                          xpal    P3
(2)  332/    971E : CE FF                       st              @-1(p2)
(2)  333/    9720 : C1 00               	ld 		(p1) 												; check first is '(', exit with term error if not
(2)  334/    9722 : E4 28               	xri 	'('
(2)  335/    9724 : 9C 2E               	jnz 	EAP_Error
(2)  336/    9726 : C5 01               	ld 		@1(p1)												; skip over it.
(2)  337/    9728 : (MACRO)             	lpi 	p3,EvaluateExpression-1 							; evaluate H
(2)  337/    9728 : C4 95                       ldi     (EVALUATEEXPRESSION-1) / 256
(2)  337/    972A : 37                          xpah    P3
(2)  337/    972B : C4 C4                       ldi     (EVALUATEEXPRESSION-1) & 255
(2)  337/    972D : 33                          xpal    P3
(2)  338/    972E : 3F                  	xppc 	p3
(2)  339/    972F : 94 27               	jp 		EAP_Exit 											; exit if failed
(2)  340/    9731 : 40                  	lde 														; store H at 3(P2)
(2)  341/    9732 : CA 03               	st 		3(p2)
(2)  342/    9734 : C1 00               	ld 		(p1) 												; check for ','
(2)  343/    9736 : E4 2C               	xri 	','
(2)  344/    9738 : 9C 1A               	jnz 	EAP_Error											; fail if not present
(2)  345/    973A : C5 01               	ld 		@1(p1)												; skip over comma
(2)  346/    973C : 3F                  	xppc 	p3 													; evaluate L
(2)  347/    973D : 94 19               	jp 		EAP_Exit 											; exit on error
(2)  348/    973F : 40                  	lde 														; store L at 2(P2)
(2)  349/    9740 : CA 02               	st 		2(p2)
(2)  350/    9742 : 33                  	xpal 	p3 													; and put in P3.L for later
(2)  351/    9743 : C1 00               	ld 		(p1) 												; check for ')'
(2)  352/    9745 : E4 29               	xri 	')'
(2)  353/    9747 : 9C 0B               	jnz 	EAP_Error
(2)  354/    9749 : C5 01               	ld 		@1(p1) 												; skip over close bracket
(2)  355/    974B : C2 03               	ld 		3(p2) 												; put 3(P2) in P3.H
(2)  356/    974D : 37                  	xpah 	p3
(2)  357/    974E : C3 00               	ld 		(p3) 												; read address
(2)  358/    9750 : 01                  	xae 														; put in E
(2)  359/    9751 : 03                  	scl 														; set carry to indicate okay
(2)  360/    9752 : 90 04               	jmp 	EAP_Exit 											; and exit.
(2)  361/    9754 :                     ;
(2)  362/    9754 :                     EAP_Error:
(2)  363/    9754 : C4 34               	ldi 	ERRC_TERM 											; set error up
(2)  364/    9756 : 01                  	xae
(2)  365/    9757 : 02                  	ccl
(2)  366/    9758 :                     ;
(2)  367/    9758 :                     EAP_Exit:														; exit
(2)  368/    9758 : (MACRO)             	pullp 	p3 													; restore P3
(2)  368/    9758 : C6 01                       ld              @1(p2)
(2)  368/    975A : 33                          xpal    P3
(2)  368/    975B : C6 01                       ld              @1(p2)
(2)  368/    975D : 37                          xpah    P3
(2)  369/    975E : C6 02               	ld 		@2(p2) 												; drop the H L address store
(2)  370/    9760 : 06                  	csa 														; A bit 7 = CY/L
(2)  371/    9761 : 3F                  	xppc 	p3
(2)  372/    9762 :                     
(2)  373/    9762 :                     
(1)  146/    9762 :                     
(1)  147/    9762 :                     ; ****************************************************************************************************************
(1)  148/    9762 :                     ;		Command look up table - should be ordered by degree of usage, and OS things (e.g. LIST) at the end
(1)  149/    9762 :                     ; ****************************************************************************************************************
(1)  150/    9762 :                     
(1)  151/    9762 :                     CommandList:
(1)  152/    9762 : (MACRO)             	cmd 	'L','E',3,CMD_Let 									; LET var|(h,l) = <expr>
(1)  152/    9762 : 4C 45                       db              'L','E'                                                                                           ; first and second characters
(1)  152/    9764 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
 AS V1.42 Beta [Bld 102] - source file minol.asm(execute.asm) - page 35 - 1/16/2016 12:24:35


(1)  152/    9765 : 77 94                       dw              (CMD_LET)-1                                                                                        ; execution point for prefetch.
(1)  153/    9767 : (MACRO)             	cmd 	'I','F',2,CMD_If 									; If [expr][=|#|<][expr]; [statement]
(1)  153/    9767 : 49 46                       db              'I','F'                                                                                           ; first and second characters
(1)  153/    9769 : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  153/    976A : CA 94                       dw              (CMD_IF)-1                                                                                        ; execution point for prefetch.
(1)  154/    976C : (MACRO)             	cmd 	'G','O',4,CMD_Goto									; GOTO [line number]
(1)  154/    976C : 47 4F                       db              'G','O'                                                                                           ; first and second characters
(1)  154/    976E : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  154/    976F : 19 95                       dw              (CMD_GOTO)-1                                                                                        ; execution point for prefetch.
(1)  155/    9771 : (MACRO)             	cmd 	'C','A',4,CMD_Call									; CALL (high,low)
(1)  155/    9771 : 43 41                       db              'C','A'                                                                                           ; first and second characters
(1)  155/    9773 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  155/    9774 : 4E 94                       dw              (CMD_CALL)-1                                                                                        ; execution point for prefetch.
(1)  156/    9776 : (MACRO)             	cmd 	'P','R',2,CMD_Print 								; PRINT ["<text>"|<expr>|$(h,l)][,....][;]
(1)  156/    9776 : 50 52                       db              'P','R'                                                                                           ; first and second characters
(1)  156/    9778 : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  156/    9779 : BC 93                       dw              (CMD_PRINT)-1                                                                                        ; execution point for prefetch.
(1)  157/    977B : (MACRO)             	cmd 	'C','L',5,CMD_Clear									; CLEAR
(1)  157/    977B : 43 4C                       db              'C','L'                                                                                           ; first and second characters
(1)  157/    977D : 04                          db              (5)-1                                                                                      ; 5 -1 (first char already skipped)
(1)  157/    977E : A7 93                       dw              (CMD_CLEAR)-1                                                                                        ; execution point for prefetch.
(1)  158/    9780 : (MACRO)             	cmd 	'I','N',2,CMD_In 									; IN [l-expr],$(H,L)
(1)  158/    9780 : 49 4E                       db              'I','N'                                                                                           ; first and second characters
(1)  158/    9782 : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  158/    9783 : 07 93                       dw              (CMD_IN)-1                                                                                        ; execution point for prefetch.
(1)  159/    9785 : (MACRO)             	cmd 	'E','N',3,CMD_End 									; END
(1)  159/    9785 : 45 4E                       db              'E','N'                                                                                           ; first and second characters
(1)  159/    9787 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  159/    9788 : 01 93                       dw              (CMD_END)-1                                                                                        ; execution point for prefetch.
(1)  160/    978A : (MACRO)             	cmd 	'N','E',3,CMD_New 									; NEW
(1)  160/    978A : 4E 45                       db              'N','E'                                                                                           ; first and second characters
(1)  160/    978C : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  160/    978D : E7 92                       dw              (CMD_NEW)-1                                                                                        ; execution point for prefetch.
(1)  161/    978F : (MACRO)             	cmd 	'R','U',3,CMD_Run									; RUN
(1)  161/    978F : 52 55                       db              'R','U'                                                                                           ; first and second characters
(1)  161/    9791 : 02                          db              (3)-1                                                                                      ; 3 -1 (first char already skipped)
(1)  161/    9792 : 3A 95                       dw              (CMD_RUN)-1                                                                                        ; execution point for prefetch.
(1)  162/    9794 : (MACRO)             	cmd 	'L','I',4,CMD_List 									; LIST
(1)  162/    9794 : 4C 49                       db              'L','I'                                                                                           ; first and second characters
(1)  162/    9796 : 03                          db              (4)-1                                                                                      ; 4 -1 (first char already skipped)
(1)  162/    9797 : A7 92                       dw              (CMD_LIST)-1                                                                                        ; execution point for prefetch.
(1)  163/    9799 : (MACRO)             	cmd 	'O','S',2,CMD_OS 									; OS
(1)  163/    9799 : 4F 53                       db              'O','S'                                                                                           ; first and second characters
(1)  163/    979B : 01                          db              (2)-1                                                                                      ; 2 -1 (first char already skipped)
(1)  163/    979C : 9E 92                       dw              (CMD_OS)-1                                                                                        ; execution point for prefetch.
(1)  164/    979E : 00                  	db 		0
(1)  165/    979F :                     
(1)  166/    979F :                     ; Done:	GOTO, RUN, CLEAR, NEW, END, OS, CALL, LET (and optional version),IF, LIST., PR
(1)  167/    979F :                     ; Not Done: IN
      89/    979F :                     	include source\manager.asm 									; manage program lines.
(1)    1/    979F :                     ; ****************************************************************************************************************
(1)    2/    979F :                     ; ****************************************************************************************************************
(1)    3/    979F :                     ;
(1)    4/    979F :                     ;										Insert / Delete Program Lines
(1)    5/    979F :                     ;
(1)    6/    979F :                     ; ****************************************************************************************************************
(1)    7/    979F :                     ; ****************************************************************************************************************
(1)    8/    979F :                     
(1)    9/    979F :                     ; ****************************************************************************************************************
(1)   10/    979F :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(manager.asm) - page 36 - 1/16/2016 12:24:35


(1)   11/    979F :                     ;
(1)   12/    979F :                     ;						Delete program line 'E'. If program line does not exist, has no effect.
(1)   13/    979F :                     ;
(1)   14/    979F :                     ;	Sets up P3 to call insert program line next.
(1)   15/    979F :                     ; ****************************************************************************************************************
(1)   16/    979F :                     ; ****************************************************************************************************************
(1)   17/    979F :                     
(1)   18/    979F :                     DeleteLine:
(1)   19/    979F : (MACRO)             	pushp	p3 													; save P3
(1)   19/    979F : 37                          xpah    P3
(1)   19/    97A0 : CE FF                       st              @-1(p2)
(1)   19/    97A2 : 33                          xpal    P3
(1)   19/    97A3 : CE FF                       st              @-1(p2)
(1)   20/    97A5 : 40                  	lde 														; push E on stack
(1)   21/    97A6 : CE FF               	st 		@-1(p2)
(1)   22/    97A8 :                     ;
(1)   23/    97A8 :                     ;	First find the line in question.
(1)   24/    97A8 :                     ;
(1)   25/    97A8 : (MACRO)             	lpi 	p3,ProgramBase 										; first, look for the line.
(1)   25/    97A8 : C4 10                       ldi     (PROGRAMBASE) / 256
(1)   25/    97AA : 37                          xpah    P3
(1)   25/    97AB : C4 04                       ldi     (PROGRAMBASE) & 255
(1)   25/    97AD : 33                          xpal    P3
(1)   26/    97AE :                     DLN_Search:
(1)   27/    97AE : C3 00               	ld 		(p3)												; look at offset
(1)   28/    97B0 : D4 80               	ani 	0x80
(1)   29/    97B2 : 9C 15               	jnz 	DLN_Exit 											; if -ve then end of program so exit.
(1)   30/    97B4 :                     
(1)   31/    97B4 : C3 00               	ld 		(p3) 												; reload offset to next.
(1)   32/    97B6 : 01                  	xae 														; put offset in E
(1)   33/    97B7 : C3 01               	ld 		1(p3) 												; read line number
(1)   34/    97B9 : E2 00               	xor 	(p2)												; is it the required line number
(1)   35/    97BB : 98 04               	jz 		DLN_Delete  										; if so, delete line.
(1)   36/    97BD : C7 80               	ld 		@-0x80(p3) 											; use E as offset to next.
(1)   37/    97BF : 90 ED               	jmp 	DLN_Search 											; and try next one.
(1)   38/    97C1 :                     ;
(1)   39/    97C1 :                     DLN_Delete:
(1)   40/    97C1 : C3 80               	ld 		-0x80(p3) 											; read ahead
(1)   41/    97C3 : CF 01               	st 		@1(p3) 												; save here and bump
(1)   42/    97C5 : E4 FF               	xri 	0xFF 												; until 0xFF is copied, which is end of program.
(1)   43/    97C7 : 9C F8               	jnz 	DLN_Delete
(1)   44/    97C9 :                     ;
(1)   45/    97C9 :                     DLN_Exit:
(1)   46/    97C9 : C6 01               	ld 		@1(p2)												; pop E
(1)   47/    97CB : 01                  	xae
(1)   48/    97CC : (MACRO)             	pullp	p3													; pop P3
(1)   48/    97CC : C6 01                       ld              @1(p2)
(1)   48/    97CE : 33                          xpal    P3
(1)   48/    97CF : C6 01                       ld              @1(p2)
(1)   48/    97D1 : 37                          xpah    P3
(1)   49/    97D2 : 3F                  	xppc 	p3 													; and return.
(1)   50/    97D3 :                     
(1)   51/    97D3 :                     ; ****************************************************************************************************************
(1)   52/    97D3 :                     ; ****************************************************************************************************************
(1)   53/    97D3 :                     ;
(1)   54/    97D3 :                     ;									Insert line at line E, text at P1
(1)   55/    97D3 :                     ;
(1)   56/    97D3 :                     ;	Jams if line already present.
(1)   57/    97D3 :                     ; ****************************************************************************************************************
(1)   58/    97D3 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file minol.asm(manager.asm) - page 37 - 1/16/2016 12:24:35


(1)   59/    97D3 :                     
(1)   60/    97D3 :                     InsertLine:
(1)   61/    97D3 : (MACRO)             	pushp 	p3 													; save P3
(1)   61/    97D3 : 37                          xpah    P3
(1)   61/    97D4 : CE FF                       st              @-1(p2)
(1)   61/    97D6 : 33                          xpal    P3
(1)   61/    97D7 : CE FF                       st              @-1(p2)
(1)   62/    97D9 : (MACRO)             	pushe 														; save E , line number.
(1)   62/    97D9 : 40                          lde
(1)   62/    97DA : CE FF                       st              @-1(p2)
(1)   63/    97DC :                     
(1)   64/    97DC : 35                  	xpah 	p1													; save P1 on stack without changing it.
(1)   65/    97DD : CE FF               	st 		@-1(p2)
(1)   66/    97DF : 35                  	xpah 	p1
(1)   67/    97E0 : 31                  	xpal 	p1
(1)   68/    97E1 : CE FF               	st 		@-1(p2)
(1)   69/    97E3 : 31                  	xpal 	p1
(1)   70/    97E4 : C4 00               	ldi 	0 													; this is the length of the string
(1)   71/    97E6 : CE FF               	st 		@-1(p2) 											; including the terminating zero.
(1)   72/    97E8 :                     
(1)   73/    97E8 :                     ILI_FindLength:
(1)   74/    97E8 : AA 00               	ild 	(p2)												; increment length
(1)   75/    97EA : C5 01               	ld 		@1(p1) 												; fetch and bump
(1)   76/    97EC : 9C FA               	jnz 	ILI_FindLength
(1)   77/    97EE :                     
(1)   78/    97EE : (MACRO)             	lpi 	p3,ProgramBase 
(1)   78/    97EE : C4 10                       ldi     (PROGRAMBASE) / 256
(1)   78/    97F0 : 37                          xpah    P3
(1)   78/    97F1 : C4 04                       ldi     (PROGRAMBASE) & 255
(1)   78/    97F3 : 33                          xpal    P3
(1)   79/    97F4 :                     ILI_FindPosition:
(1)   80/    97F4 : C3 00               	ld 		(p3) 												; read offset
(1)   81/    97F6 : D4 80               	ani 	0x80 												; if negative, insert here.
(1)   82/    97F8 : 9C 11               	jnz 	ILI_InsertHere
(1)   83/    97FA : C3 00               	ld 		(p3)												; put offset to next in E.
(1)   84/    97FC : 01                  	xae
(1)   85/    97FD : C2 03               	ld 		3(p2) 												; calculate line# - this#
(1)   86/    97FF : 03                  	scl
(1)   87/    9800 : FB 01               	cad 	1(p3)
(1)   88/    9802 :                     ILI_Failed: 													; error here. If line# found, we haven't deleted it !
(1)   89/    9802 : 98 FE               	jz 		ILI_Failed
(1)   90/    9804 : 06                  	csa 														; if CY/L = 0 then insert here
(1)   91/    9805 : 94 04               	jp 		ILI_InsertHere
(1)   92/    9807 : C7 80               	ld 		@-0x80(p3)											; go to next line.
(1)   93/    9809 : 90 E9               	jmp 	ILI_FindPosition
(1)   94/    980B :                     
(1)   95/    980B :                     ILI_InsertHere:
(1)   96/    980B : C4 00               	ldi 	0 													; these are used to count how many bytes from here to the end.
(1)   97/    980D : CA FF               	st 		-1(p2)
(1)   98/    980F : CA FE               	st 		-2(p2)
(1)   99/    9811 :                     ILI_CountBytes:
(1)  100/    9811 : AA FE               	ild 	-2(p2)
(1)  101/    9813 : 9C 02               	jnz 	ILI_NoCarry
(1)  102/    9815 : AA FF               	ild 	-1(p2)
(1)  103/    9817 :                     ILI_NoCarry:
(1)  104/    9817 : C7 01               	ld 		@1(p3)												; fetch and bump
(1)  105/    9819 : E4 FF               	xri 	0xFF 												; until $FF found.
(1)  106/    981B : 9C F4               	jnz 	ILI_CountBytes
(1)  107/    981D : C2 00               	ld 		0(p2) 												; get length of string into E
(1)  108/    981F : 01                  	xae
 AS V1.42 Beta [Bld 102] - source file minol.asm(manager.asm) - page 38 - 1/16/2016 12:24:35


(1)  109/    9820 :                     
(1)  110/    9820 :                     ILI_Move:
(1)  111/    9820 : C3 00               	ld 		(p3)												; move byte
(1)  112/    9822 : CB 80               	st 		-0x80(p3)
(1)  113/    9824 : C7 FF               	ld 		@-1(p3) 											; point to previous byte
(1)  114/    9826 :                     
(1)  115/    9826 : C2 FE               	ld 		-2(p2) 												; decrement the counter
(1)  116/    9828 : 9C 06               	jnz 	ILI_NoBorrow
(1)  117/    982A : BA FF               	dld 	-1(p2) 
(1)  118/    982C : D4 80               	ani 	0x80
(1)  119/    982E : 9C 04               	jnz 	ILI_GotSpace 										; if counter out, then got the space.
(1)  120/    9830 :                     ILI_NoBorrow:
(1)  121/    9830 : BA FE               	dld 	-2(p2)
(1)  122/    9832 : 90 EC               	jmp 	ILI_Move
(1)  123/    9834 :                     
(1)  124/    9834 :                     ILI_GotSpace:
(1)  125/    9834 : C7 01               	ld 		@1(p3) 												; this is where the new data goes
(1)  126/    9836 : C2 01               	ld 		1(p2)												; restore the original P1.
(1)  127/    9838 : 31                  	xpal 	p1
(1)  128/    9839 : C2 02               	ld 		2(p2)
(1)  129/    983B : 35                  	xpah 	p1
(1)  130/    983C :                     
(1)  131/    983C :                     ILI_Copy:														; copy the new line in.
(1)  132/    983C : C5 01               	ld 		@1(p1)
(1)  133/    983E : CF 01               	st 		@1(p3)
(1)  134/    9840 : 9C FA               	jnz 	ILI_Copy
(1)  135/    9842 :                     
(1)  136/    9842 : C6 01               	ld 		@1(p2) 												; dump string length
(1)  137/    9844 : (MACRO)             	pullp 	p1													; restore registers
(1)  137/    9844 : C6 01                       ld              @1(p2)
(1)  137/    9846 : 31                          xpal    P1
(1)  137/    9847 : C6 01                       ld              @1(p2)
(1)  137/    9849 : 35                          xpah    P1
(1)  138/    984A : (MACRO)             	pulle
(1)  138/    984A : C6 01                       ld              @1(p2)
(1)  138/    984C : 01                          xae
(1)  139/    984D : (MACRO)             	pullp 	p3
(1)  139/    984D : C6 01                       ld              @1(p2)
(1)  139/    984F : 33                          xpal    P3
(1)  139/    9850 : C6 01                       ld              @1(p2)
(1)  139/    9852 : 37                          xpah    P3
(1)  140/    9853 : 3F                  	xppc 	p3
(1)  141/    9854 :                     
      90/    9854 :                     	include source\console.asm 									; console type in etc.
(1)    1/    9854 :                     ; ****************************************************************************************************************
(1)    2/    9854 :                     ; ****************************************************************************************************************
(1)    3/    9854 :                     ;
(1)    4/    9854 :                     ;												Console Handler
(1)    5/    9854 :                     ;
(1)    6/    9854 :                     ; ****************************************************************************************************************
(1)    7/    9854 :                     ; ****************************************************************************************************************
(1)    8/    9854 :                     
(1)    9/    9854 :                     ; ****************************************************************************************************************
(1)   10/    9854 :                     ;
(1)   11/    9854 :                     ;							Come here when a program stops running, or at the start.
(1)   12/    9854 :                     ;
(1)   13/    9854 :                     ; ****************************************************************************************************************
(1)   14/    9854 :                     
(1)   15/    9854 :                     ConsoleStart:
(1)   16/    9854 : (MACRO)             	lpi 	p3,Print-1 
 AS V1.42 Beta [Bld 102] - source file minol.asm(console.asm) - page 39 - 1/16/2016 12:24:35


(1)   16/    9854 : C4 91                       ldi     (PRINT-1) / 256
(1)   16/    9856 : 37                          xpah    P3
(1)   16/    9857 : C4 50                       ldi     (PRINT-1) & 255
(1)   16/    9859 : 33                          xpal    P3
(1)   17/    985A : 06                  	csa 														; see if CY/L is set
(1)   18/    985B : D4 80               	ani	 	0x80								
(1)   19/    985D : 98 24               	jz 		CONError 											; if so, there is an error.
(1)   20/    985F :                     
(1)   21/    985F :                     ; ****************************************************************************************************************
(1)   22/    985F :                     ;													Print OK
(1)   23/    985F :                     ; ****************************************************************************************************************
(1)   24/    985F :                     
(1)   25/    985F :                     CONOk:
(1)   26/    985F : (MACRO)             	lpi 	p1,CONMsgOk 										; print OK.
(1)   26/    985F : C4 98                       ldi     (CONMSGOK) / 256
(1)   26/    9861 : 35                          xpah    P1
(1)   26/    9862 : C4 6A                       ldi     (CONMSGOK) & 255
(1)   26/    9864 : 31                          xpal    P1
(1)   27/    9865 : C4 00               	ldi 	0
(1)   28/    9867 : 3F                  	xppc 	p3
(1)   29/    9868 : 90 4D               	jmp 	CONEnter
(1)   30/    986A :                     
(1)   31/    986A :                     CONMsgOk:														; OK prompt.
(1)   32/    986A : 4F 4B 0D 00         	db 		"OK",13,0
(1)   33/    986E :                     CONMsgErr1:														; Error Message
(1)   34/    986E : 21 45 52 52 20 00   	db 		"!ERR ",0 
(1)   35/    9874 : 20 41 54 20 00      	db 		" AT ",0
(1)   36/    9879 :                     CONMsgErr2:														; Error Message
(1)   37/    9879 : 42 52 45 41 4B 00   	db 		"BREAK",0 
(1)   38/    987F : 41 54 20 00         	db 		"AT ",0
(1)   39/    9883 :                     
(1)   40/    9883 :                     
(1)   41/    9883 :                     ; ****************************************************************************************************************
(1)   42/    9883 :                     ;											   Print Error Message
(1)   43/    9883 :                     ; ****************************************************************************************************************
(1)   44/    9883 :                     
(1)   45/    9883 :                     CONError:
(1)   46/    9883 : (MACRO)             	lpi 	p1,CONMsgErr1
(1)   46/    9883 : C4 98                       ldi     (CONMSGERR1) / 256
(1)   46/    9885 : 35                          xpah    P1
(1)   46/    9886 : C4 6E                       ldi     (CONMSGERR1) & 255
(1)   46/    9888 : 31                          xpal    P1
(1)   47/    9889 : 40                  	lde 														; check if faux error
(1)   48/    988A : E4 FF               	xri 	ERRC_End
(1)   49/    988C : 98 D1               	jz 		CONOk
(1)   50/    988E : 40                  	lde
(1)   51/    988F : E4 38               	xri 	ERRC_Break			 								; check if BREAK
(1)   52/    9891 : 9C 09               	jnz 	CONError2
(1)   53/    9893 : (MACRO)             	lpi 	p1,CONMsgErr2
(1)   53/    9893 : C4 98                       ldi     (CONMSGERR2) / 256
(1)   53/    9895 : 35                          xpah    P1
(1)   53/    9896 : C4 79                       ldi     (CONMSGERR2) & 255
(1)   53/    9898 : 31                          xpal    P1
(1)   54/    9899 : C4 20               	ldi 	' '													; makes it print space rather than code.
(1)   55/    989B : 01                  	xae
(1)   56/    989C :                     CONError2:
(1)   57/    989C : C4 00               	ldi 	0
(1)   58/    989E : 3F                  	xppc 	p3
(1)   59/    989F : 40                  	lde 														; get error code
(1)   60/    98A0 : 3F                  	xppc 	p3
 AS V1.42 Beta [Bld 102] - source file minol.asm(console.asm) - page 40 - 1/16/2016 12:24:35


(1)   61/    98A1 : C4 00               	ldi 	0 													; print _AT_
(1)   62/    98A3 : 3F                  	xppc 	p3
(1)   63/    98A4 : (MACRO)             	lpi 	p3,CurrentLine 										; get current line number into E.
(1)   63/    98A4 : C4 0C                       ldi     (CURRENTLINE) / 256
(1)   63/    98A6 : 37                          xpah    P3
(1)   63/    98A7 : C4 8D                       ldi     (CURRENTLINE) & 255
(1)   63/    98A9 : 33                          xpal    P3
(1)   64/    98AA : C3 00               	ld 		(p3)
(1)   65/    98AC : 01                  	xae
(1)   66/    98AD : (MACRO)             	lpi 	p3,PrintInteger-1 									; print it.
(1)   66/    98AD : C4 90                       ldi     (PRINTINTEGER-1) / 256
(1)   66/    98AF : 37                          xpah    P3
(1)   66/    98B0 : C4 C4                       ldi     (PRINTINTEGER-1) & 255
(1)   66/    98B2 : 33                          xpal    P3
(1)   67/    98B3 : 3F                  	xppc 	p3
(1)   68/    98B4 : C4 0D               	ldi 	13 													; print new line
(1)   69/    98B6 : 3F                  	xppc 	p3
(1)   70/    98B7 :                     
(1)   71/    98B7 :                     ; ****************************************************************************************************************
(1)   72/    98B7 :                     ;												Get next command.
(1)   73/    98B7 :                     ; ****************************************************************************************************************
(1)   74/    98B7 :                     
(1)   75/    98B7 :                     CONEnter:
(1)   76/    98B7 : (MACRO)             	lpi 	p3,GetString-1 										; get input from keyboard.
(1)   76/    98B7 : C4 92                       ldi     (GETSTRING-1) / 256
(1)   76/    98B9 : 37                          xpah    P3
(1)   76/    98BA : C4 34                       ldi     (GETSTRING-1) & 255
(1)   76/    98BC : 33                          xpal    P3
(1)   77/    98BD : (MACRO)             	lpi 	p1,KeyboardBuffer
(1)   77/    98BD : C4 0C                       ldi     (KEYBOARDBUFFER) / 256
(1)   77/    98BF : 35                          xpah    P1
(1)   77/    98C0 : C4 B0                       ldi     (KEYBOARDBUFFER) & 255
(1)   77/    98C2 : 31                          xpal    P1
(1)   78/    98C3 : C4 00               	ldi 	0 													; clear current line # using value.
(1)   79/    98C5 : C9 DD               	st 		CurrentLine-KeyboardBuffer(p1)
(1)   80/    98C7 : C4 48               	ldi 	KeyboardBufferSize									; input length
(1)   81/    98C9 : 3F                  	xppc 	p3
(1)   82/    98CA :                     
(1)   83/    98CA : (MACRO)             	lpi 	p3,GetConstant-1 									; extract a constant if there is one.
(1)   83/    98CA : C4 91                       ldi     (GETCONSTANT-1) / 256
(1)   83/    98CC : 37                          xpah    P3
(1)   83/    98CD : C4 20                       ldi     (GETCONSTANT-1) & 255
(1)   83/    98CF : 33                          xpal    P3
(1)   84/    98D0 : 3F                  	xppc 	p3
(1)   85/    98D1 : D4 80               	ani 	0x80
(1)   86/    98D3 : 9C 19               	jnz 	CONHasLineNumber 									; if okay, has line number.
(1)   87/    98D5 :                     
(1)   88/    98D5 : C1 00               	ld 		(p1)												; if no text, enter again.
(1)   89/    98D7 : 98 DE               	jz 		CONEnter
(1)   90/    98D9 :                     
(1)   91/    98D9 :                     ; ****************************************************************************************************************
(1)   92/    98D9 :                     ;									Execute a command from the keyboard.
(1)   93/    98D9 :                     ; ****************************************************************************************************************
(1)   94/    98D9 :                     
(1)   95/    98D9 :                     CONEndOfLine:
(1)   96/    98D9 : C5 01               	ld 		@1(p1) 												; find end of line
(1)   97/    98DB : 9C FC               	jnz 	CONEndOfLine
(1)   98/    98DD : C4 FF               	ldi 	0xFF												; put end of code marker at end of string.
(1)   99/    98DF : C9 00               	st 		(p1)
(1)  100/    98E1 : (MACRO)             	lpi 	p1,KeyboardBuffer 	
 AS V1.42 Beta [Bld 102] - source file minol.asm(console.asm) - page 41 - 1/16/2016 12:24:35


(1)  100/    98E1 : C4 0C                       ldi     (KEYBOARDBUFFER) / 256
(1)  100/    98E3 : 35                          xpah    P1
(1)  100/    98E4 : C4 B0                       ldi     (KEYBOARDBUFFER) & 255
(1)  100/    98E6 : 31                          xpal    P1
(1)  101/    98E7 : (MACRO)             	lpi 	p3,ExecuteFromAddressDirect-1
(1)  101/    98E7 : C4 95                       ldi     (EXECUTEFROMADDRESSDIRECT-1) / 256
(1)  101/    98E9 : 37                          xpah    P3
(1)  101/    98EA : C4 70                       ldi     (EXECUTEFROMADDRESSDIRECT-1) & 255
(1)  101/    98EC : 33                          xpal    P3
(1)  102/    98ED : 3F                  	xppc 	p3
(1)  103/    98EE :                     
(1)  104/    98EE :                     ; ****************************************************************************************************************
(1)  105/    98EE :                     ;						Command has a Line Number - text is at P1, line number in E.
(1)  106/    98EE :                     ; ****************************************************************************************************************
(1)  107/    98EE :                     
(1)  108/    98EE :                     CONHasLineNumber:
(1)  109/    98EE : (MACRO)             	lpi 	p3,DeleteLine-1 									; delete the line whose number is in E
(1)  109/    98EE : C4 97                       ldi     (DELETELINE-1) / 256
(1)  109/    98F0 : 37                          xpah    P3
(1)  109/    98F1 : C4 9E                       ldi     (DELETELINE-1) & 255
(1)  109/    98F3 : 33                          xpal    P3
(1)  110/    98F4 : 3F                  	xppc 	p3
(1)  111/    98F5 :                     
(1)  112/    98F5 : C1 00               	ld 		(p1) 												; any text in this line ?
(1)  113/    98F7 : 98 BE               	jz 		CONEnter											; if not, then just do the delete (possible)
(1)  114/    98F9 :                     
(1)  115/    98F9 : C4 00               	ldi 	0													; temporarily set the line number to zero.
(1)  116/    98FB : C9 FF               	st 		-1(p1)
(1)  117/    98FD : C4 02               	ldi 	2
(1)  118/    98FF : CA FF               	st 		-1(p2) 												; and reset the counter to 2 to get size right.
(1)  119/    9901 :                     CONGetLength:
(1)  120/    9901 : AA FF               	ild 	-1(p2) 												; bump count
(1)  121/    9903 : C5 01               	ld 		@1(p1) 												; keep going forward till 0 read.
(1)  122/    9905 : 9C FA               	jnz 	CONGetLength
(1)  123/    9907 : C5 FF               	ld 		@-1(p1) 											; undo the last bump over zero
(1)  124/    9909 :                     
(1)  125/    9909 :                     CONBackToStart:
(1)  126/    9909 : C5 FF               	ld 		@-1(p1) 											; keep going back until zero.
(1)  127/    990B : 9C FC               	jnz 	CONBackToStart										; this is the line number we set to zero
(1)  128/    990D :                     
(1)  129/    990D : 40                  	lde 														; copy line number
(1)  130/    990E : C9 00               	st 		(p1)
(1)  131/    9910 : C2 FF               	ld 		-1(p2) 												; get measured length
(1)  132/    9912 : CD FF               	st 		@-1(p1) 											; and store in the length slot.
(1)  133/    9914 :                     
(1)  134/    9914 : 3F                  	xppc 	p3 													; put line in using fall through insert routine.
(1)  135/    9915 : 90 A0               	jmp 	CONEnter 											; and get another line.
(1)  136/    9917 :                     
      91/    9917 :                     
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 42 - 1/16/2016 12:24:35


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
 BOOTMESSAGE :                 9063 C |  BOOTMONITOR :                  210 - |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CCA_OVER :                    9476 C |  CCL_LOOP :                    93B2 C |
 CCL_OVER :                    93BB C |  CHECKLASTCOMMANDTHENEXECUTE : 9550 C |
 CIF_CONTINUE :                94E2 C |  CIF_EQUALITY :                94FE C |
 CIF_EQUALITY2 :               9505 C |  CIF_OVER :                    9518 C |
 CIF_SYNTAX :                  94DC C |  CIF_TESTIFZERO :              950B C |
 CIN_FINDEND :                 9398 C |  CIN_INPUTVARIABLEORMEMORY :   934C C |
 CIN_MEMORY :                  9347 C |  CIN_OVER :                    93A6 C |
 CIN_OVER2 :                   9338 C |  CIN_STOREVALUE :              9371 C |
 CIN_STRING :                  9382 C |  CIN_SYNTAX :                  9334 C |
 CIN_VARIABLE :                933A C |  CLE_EVALUATEANDWRITE :        94A9 C |
 CLE_ISHL :                    949E C |  CLE_OVER :                    94C9 C |
 CLE_SINGLEVARIABLE :          948F C |  CLE_SYNTAX :                  9489 C |
 CLI_END :                     92E0 C |  CLI_ENDLINE :                 92CC C |
 CLI_LINE :                    92C5 C |  CLI_LOOP :                    92B2 C |
 CLI_OVER :                    92E6 C |  CMD_CALL :                    944F C |
 CMD_CLEAR :                   93A8 C |  CMD_END :                     9302 C |
 CMD_GOTO :                    951A C |  CMD_IF :                      94CB C |
 CMD_IN :                      9308 C |  CMD_IN2 :                     9380 C |
 CMD_LET :                     9478 C |  CMD_LIST :                    92A8 C |
 CMD_NEW :                     92E8 C |  CMD_OS :                      929F C |
 CMD_PRINT :                   93BD C |  CMD_PRINT2 :                  9402 C |
 CMD_RUN :                     953B C |  CNE_OVER :                    9306 C |
 COMMANDLIST :                 9762 C |  CONBACKTOSTART :              9909 C |
 CONENDOFLINE :                98D9 C |  CONENTER :                    98B7 C |
 CONERROR :                    9883 C |  CONERROR2 :                   989C C |
 CONGETLENGTH :                9901 C |  CONHASLINENUMBER :            98EE C |
 CONMSGERR1 :                  986E C |  CONMSGERR2 :                  9879 C |
 CONMSGOK :                    986A C |  CONOK :                       985F C |
 CONSOLESTART :                9854 C | *CONSTPI :        3.141592653589793 - |
 COPY1 :                       901F C |  COS_OVER :                    92A6 C |
 CPR_BREAK :                   9404 C |  CPR_ENDOK :                   944C C |
 CPR_ENDRETURN :               9449 C |  CPR_OVER :                    944D C |
 CPR_OVER2 :                   9408 C |  CPR_QUOTEDSTRING :            940A C |
 CPR_STRINGATADDRESS :         9417 C |  CPR_STRINGEXIT :              9436 C |
 CPR_STRINGLOOP :              9430 C |  CPR_STRINGPRINT :             943E C |
 CPR_SYNTAX :                  9443 C |  CRG_EXECUTEFROMP1 :           9541 C |
 CRG_FIND :                    9526 C |  CRG_NOTEND :                  9530 C |
 CRG_OVER :                    9543 C |  CURRENTLINE :                  C8D - |
*DATE :                   1/16/2016 - |  DELETELINE :                  979F C |
 DLN_DELETE :                  97C1 C |  DLN_EXIT :                    97C9 C |
 DLN_SEARCH :                  97AE C |  EAFD_LETCODE :                95BA C |
 EAFD_SEARCH :                 958A C |  EAFD_SKIP :                   959B C |
 EAFD_SKIPSPACES :             95A7 C |  EAP_ERROR :                   9754 C |
 EAP_EXIT :                    9758 C |  EEX_CHECKNEXTOPERATION :      96B2 C |
 EEX_CONSTANT :                9649 C |  EEX_CONSTANTLOOP :            964A C |
 EEX_DIVIDE :                  96D5 C |  EEX_DIVIDE_LOOP :             96E6 C |
 EEX_DIVIDE_NUMERATOR_POSITIVE :                                       96F7 C |
 EEX_DIVIDE_TEMP_POSITIVE :    970A C |  EEX_DIVIDE_ZERO :             9682 C |
 EEX_ENDEXPRESSION :           9686 C |  EEX_ERROR :                   962E C |
 EEX_EXIT :                    9630 C |  EEX_FOUNDOPERATOR :           96CA C |
 EEX_HAVETERM :                966A C |  EEX_MEMORYACCESS :            963C C |
 EEX_MULTIPLYLOOP :            9698 C |  EEX_MULTIPLY_B0ISZERO :       96A6 C |
 EEX_NEXTCHAR :                95D9 C |  EEX_NOTADD :                  9676 C |
 EEX_NOTAP :                   9604 C |  EEX_NOTQUOTE :                9619 C |
 AS V1.42 Beta [Bld 102] - source file minol.asm - page 43 - 1/16/2016 12:24:35


 EEX_NOTRANDOM :               9606 C |  EEX_NOTSUBTRACT :             968C C |
 EEX_PENDINGOP :                  1 - | *EEX_RANDOM :                  95EB C |
 EEX_SAVEANDEXIT :             967E C |  EEX_TERM :                    95D3 C |
 EEX_TERMERROR :               962C C |  EEX_VALUE :                      0 - |
 EEX_VARIABLE :                9666 C | *ENDOFCOMMANDEXECUTION :       9543 C |
 ERRC_BREAK :                    38 - |  ERRC_DIVZERO :                  37 - |
 ERRC_END :                      FF - |  ERRC_LABEL :                    31 - |
*ERRC_MEMORY :                   36 - |  ERRC_SYNTAX :                   35 - |
 ERRC_TERM :                     34 - | *ERRC_UNKNOWN :                  32 - |
 EVALUATEADDRESSPAIR :         9718 C |  EVALUATEEXPRESSION :          95C5 C |
 EXECUTEFROMADDRESSDIRECT :    9571 C |  EXECUTEFROMCOMMANDSTART :     9565 C |
 EXECUTENEXTINSTRUCTION :      9546 C | *FALSE :                          0 - |
 FINDTOS :                     9007 C | *FULLPMMU :                       1 - |
 GCO_EXIT :                    914A C |  GCO_LOOP :                    9126 C |
 GETCHAR :                     9211 C |  GETCONSTANT :                 9121 C |
 GETSTRING :                   9235 C |  GOTOCOMMANDLINE :             9558 C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
 ILI_COPY :                    983C C |  ILI_COUNTBYTES :              9811 C |
 ILI_FAILED :                  9802 C |  ILI_FINDLENGTH :              97E8 C |
 ILI_FINDPOSITION :            97F4 C |  ILI_GOTSPACE :                9834 C |
 ILI_INSERTHERE :              980B C |  ILI_MOVE :                    9820 C |
 ILI_NOBORROW :                9830 C |  ILI_NOCARRY :                 9817 C |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSERTLINE :                  97D3 C |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 KEYBOARDBUFFER :               CB0 - |  KEYBOARDBUFFERSIZE :            48 - |
*LISTON :                         1 - | *MACEXP :                         1 - |
 MARKER1 :                       FD - |  MARKER2 :                       B5 - |
 MARKER3 :                       AE - |  MARKER4 :                       76 - |
*MOMCPU :                         C - | *MOMCPUNAME :                 SC/MP - |
*NESTMAX :                      100 - | *OSMATHLIBRARY :                  3 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PRINT :                       9151 C |  PRINTINTEGER :                90C5 C |
 PROGRAMBASE :                 1004 - |  PROGRAMCODE :                 9080 C |
 RANDOMSEED :                   C8E - | *RELAXED :                        0 - |
 RUNNEW :                      905C C |  SCREENCURSOR :                 C80 - |
 SCREENMIRROR :                 C00 - |  STACKFOUND :                  9013 C |
 SYNTAXERROR :                 955F C |  SYSTEMMEMORY :                 C90 - |
*TIME :                    12:24:34 - | *TRUE :                           1 - |
 VARIABLES :                    C90 - | *VERSION :                     142F - |
 __GCNOTLOWER [GETCHAR] :      9230 C |  __GCWAITKEY [GETCHAR] :       9216 C |
 __GCWAITRELEASE [GETCHAR] :   921E C |  __GSBACKSPACE [GETSTRING] :   9290 C |
 __GSCONTROLKEY [GETSTRING] :  9273 C |  __GSLOOP [GETSTRING] :        9243 C |
 __PIDIVIDEEND :               90F6 C |  __PIDIVIDELOOP :              90D9 C |
 __PIDIVIDEOUTER :             90D3 C |  __PIEXIT :                    9118 C |
 __PIPRINT :                   910B C |  __PRCLEARFROMMOVETO [PRINT] : 91F1 C |
 __PRCLEARLOOP [PRINT] :       91F3 C |  __PRCLEARSCREEN [PRINT] :     91EF C |
 __PRCOPY [PRINT] :            91FD C |  __PREXIT [PRINT] :            91B4 C |
 __PREXITNOCHECK [PRINT] :     91B8 C |  __PRISCONTROLCHAR [PRINT] :   91C6 C |
 __PRISRETURN [PRINT] :        91E6 C |  __PRNOTASCII [PRINT] :        918E C |
 __PRPRINTCHARACTERA [PRINT] : 9172 C |  __PRPRINTSTRING [PRINT] :     9160 C |
 __PRSCROLLLOOP [PRINT] :      91A6 C |  __PRUPDATECURSOR [PRINT] :    9197 C |

    219 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 44 - 1/16/2016 12:24:35


  defined macros:
  ---------------

CMD                                   | CODE                                 
LPI                                   | PULLA                                
PULLE                                 | PULLP                                
PUSHA                                 | PUSHE                                
PUSHP                                 | SETV                                 

     10 macros

 AS V1.42 Beta [Bld 102] - source file minol.asm - page 45 - 1/16/2016 12:24:35


  codepages:
  ----------

STANDARD (0 changed characters)


0.03 seconds assembly time

   2069 lines source file
   2439 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
