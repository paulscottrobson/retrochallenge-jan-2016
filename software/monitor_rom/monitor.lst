 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 1 - 12/2/2015 13:45:23


       1/       0 :                     ; ******************************************************************************************************************
       2/       0 :                     ; ******************************************************************************************************************
       3/       0 :                     ; ******************************************************************************************************************
       4/       0 :                     ;
       5/       0 :                     ;												Machine Language Monitor
       6/       0 :                     ;
       7/       0 :                     ; ******************************************************************************************************************
       8/       0 :                     ; ******************************************************************************************************************
       9/       0 :                     ; ******************************************************************************************************************
      10/       0 :                     
      11/       0 :                     		cpu	sc/mp
      12/       0 :                     
      13/       0 : =0xC00              labels 		= 0xC00												; labels, 1 byte each
      14/       0 : =0x18               labelCount 	= 24 												; number of labels.
      15/       0 :                     
      16/       0 : =0xC18              varBase 	= labels+labelCount 								; variables after labels start here.
      17/       0 :                     
      18/       0 : =0xC18              cursor 		= varBase 											; cursor position ($00-$7F)
      19/       0 : =0xC19              current 	= varBase+1 										; current address (lo,hi)
      20/       0 : =0xC1B              isInit      = varBase+3 										; if already initialised, this is $A7.
      21/       0 : =0xC1C              parPosn		= varBase+4 										; current param offset in buffer (low addr)
      22/       0 : =0xC1D              modifier  	= varBase+5 										; instruction modifier (@,Pn) when assembling.
      23/       0 : =0xC1E              random  	= varBase+6 										; random number LFSR
      24/       0 : =0xC20              kbdBuffer 	= varBase+8 										; 16 character keyboard buffer
      25/       0 : =0x10               kbdBufferLn = 16 										
      26/       0 :                     
      27/       0 : =0xC30              codeStart 	= kbdBuffer+kbdBufferLn								; code starts here after the keyboard buffer.
      28/       0 :                     
      29/       0 : =0x4                tapeDelay 	= 4 												; DLY parameter for 1 tape bit width.
      30/       0 :                     																; (smaller = faster tape I/O - see file end.)
      31/       0 :                     
      32/       0 :                     		org 	0x0000
      33/       0 : 08                  		nop 													; mandatory pre-increment NOP
      34/       1 :                     
      35/       1 :                     		include maths.asm 										; import the maths routines.
(1)    1/       1 :                     ; ******************************************************************************************************************
(1)    2/       1 :                     ; ******************************************************************************************************************
(1)    3/       1 :                     ;
(1)    4/       1 :                     ;										16 bit Arithmetic routines
(1)    5/       1 :                     ;
(1)    6/       1 :                     ; ******************************************************************************************************************
(1)    7/       1 :                     ; ******************************************************************************************************************
(1)    8/       1 :                     
(1)    9/       1 : 90 02               	jmp	 	GoBoot 												; this will be at location 1.
(1)   10/       3 : 90 3E               	jmp 	Maths 												; maths routine, at location 3.
(1)   11/       5 :                     
(1)   12/       5 :                     	; any other routines you care to call.
(1)   13/       5 :                     
(1)   14/       5 :                     GoBoot:
(1)   15/       5 : C4 EC               	ldi 	(BootMonitor-1) & 255 								; jump to Boot Monitor
(1)   16/       7 : 33                  	xpal 	p3
(1)   17/       8 : C4 01               	ldi 	(BootMonitor-1) / 256
(1)   18/       A : 37                  	xpah 	p3
(1)   19/       B : 3F                  	xppc 	p3
(1)   20/       C :                     
(1)   21/       C :                     ; ******************************************************************************************************************
(1)   22/       C :                     ;											16 Bit shift left/right macros
(1)   23/       C :                     ; ******************************************************************************************************************
(1)   24/       C :                     
(1)   25/       C :                     shiftLeft macro val
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 2 - 12/2/2015 13:45:23


(1)   26/       C :                     	ccl 													
(1)   27/       C :                     	ld 		val(p2)
(1)   28/       C :                     	add 	val(p2)
(1)   29/       C :                     	st 		val(p2)
(1)   30/       C :                     	ld 		val+1(p2)
(1)   31/       C :                     	add 	val+1(p2)
(1)   32/       C :                     	st 		val+1(p2)		
(1)   33/       C :                     	endm
(1)   34/       C :                     
(1)   35/       C :                     shiftRight macro val
(1)   36/       C :                     	ccl
(1)   37/       C :                     	ld 		val+1(p2)
(1)   38/       C :                     	rrl 
(1)   39/       C :                     	st 		val+1(p2)
(1)   40/       C :                     	ld 		val(p2)
(1)   41/       C :                     	rrl 
(1)   42/       C :                     	st 		val(p2)
(1)   43/       C :                     	endm
(1)   44/       C :                     
(1)   45/       C :                     ; ******************************************************************************************************************
(1)   46/       C :                     ;										' Random Number generator
(1)   47/       C :                     ; ******************************************************************************************************************
(1)   48/       C :                     
(1)   49/       C :                     MATH_Random:
(1)   50/       C : C4 1E               	ldi 	Random & 255 										; set P1 to point to RNG, push P1 on stack.
(1)   51/       E : 31                  	xpal 	p1
(1)   52/       F : CE FD               	st 		@-3(p2)												; we allow 2 bytes for the final result here.
(1)   53/      11 : C4 0C               	ldi 	Random / 256 	
(1)   54/      13 : 35                  	xpah 	p1
(1)   55/      14 : CE FF               	st 		@-1(p2)
(1)   56/      16 : 02                  	ccl 														; shift random seed right.
(1)   57/      17 : C1 01               	ld 		1(p1)
(1)   58/      19 : 1F                  	rrl
(1)   59/      1A : C9 01               	st 		1(p1)
(1)   60/      1C : C1 00               	ld 		0(p1)
(1)   61/      1E : 1F                  	rrl 
(1)   62/      1F : C9 00               	st 		0(p1)
(1)   63/      21 : 06                  	csa 														; look at carry out, lost bit.
(1)   64/      22 : D4 80               	ani 	0x80 												; is it clear ?
(1)   65/      24 : 9C 0C               	jnz 	__MARandomNoXor
(1)   66/      26 : C1 00               	ld 		0(p1) 												; xor lfsr with $A1A1
(1)   67/      28 : E4 A1               	xri 	0xA1
(1)   68/      2A : C9 00               	st 		0(p1)
(1)   69/      2C : C1 01               	ld 		1(p1)
(1)   70/      2E : E4 A1               	xri 	0xA1
(1)   71/      30 : C9 01               	st 		1(p1)
(1)   72/      32 :                     __MARandomNoXor:
(1)   73/      32 : C1 00               	ld 		0(p1) 												; put the LFSR in the result space on the stack
(1)   74/      34 : CA 02               	st 		2(p2)
(1)   75/      36 : C1 01               	ld 		1(p1)
(1)   76/      38 : CA 03               	st 		3(p2)
(1)   77/      3A : C6 01               	ld 		@1(p2) 												; restore P1
(1)   78/      3C : 35                  	xpah 	p1
(1)   79/      3D : C6 01               	ld 		@1(p2)
(1)   80/      3F : 31                  	xpal 	p1
(1)   81/      40 : 02                  	ccl 														; no problems
(1)   82/      41 : 90 19               	jmp 	MATH_Exit
(1)   83/      43 :                     
(1)   84/      43 :                     ; ******************************************************************************************************************
(1)   85/      43 :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 3 - 12/2/2015 13:45:23


(1)   86/      43 :                     ;		Maths routines : the (P2) stack functions as a number stack.  So to push $1234 on the stack you do
(1)   87/      43 :                     ;
(1)   88/      43 :                     ;		ld 	#$12
(1)   89/      43 :                     ;		st 	@-1(p2) 					1(p2) is the MSB of TOS
(1)   90/      43 :                     ;		ld 	#$34
(1)   91/      43 :                     ;		st 	@-1(p2) 					0(p2) is the LSB of TOS
(1)   92/      43 :                     ;
(1)   93/      43 :                     ;		on entry, A is the function (+,-,*,/ etc.). P2 should be left in the 'correct' state afterwards,
(1)   94/      43 :                     ;		so if you add two numbers then p2 will be 2 higher than when the routine was entered.
(1)   95/      43 :                     ;
(1)   96/      43 :                     ;		Supported : + - * / ? (ASCII @ p1 -> integer, p1 updated) ' (random number)
(1)   97/      43 :                     ;
(1)   98/      43 :                     ;		Returns CS on error (division by zero, bad ASCII String) - in this case the parameters are not touched.
(1)   99/      43 :                     ;
(1)  100/      43 :                     ;		Note that division uses a fair chunk of the stack :)
(1)  101/      43 :                     ;
(1)  102/      43 :                     ; ******************************************************************************************************************
(1)  103/      43 :                     
(1)  104/      43 :                     Maths:															; maths support routine.
(1)  105/      43 :                     
(1)  106/      43 : E4 2B               	xri 	'+' 												; dispatch function in A to the executing code.
(1)  107/      45 : 98 18               	jz 		MATH_Add
(1)  108/      47 : E4 06               	xri 	'+'!'-'
(1)  109/      49 : 98 24               	jz 		MATH_Subtract
(1)  110/      4B : E4 07               	xri 	'-'!'*'
(1)  111/      4D : 98 32               	jz 		MATH_Multiply
(1)  112/      4F : E4 05               	xri 	'*'!'/'
(1)  113/      51 : 98 74               	jz 		MATH_Divide2
(1)  114/      53 : E4 10               	xri 	'/'!'?' 											; ASCII (P1) -> Integer (? operator)
(1)  115/      55 : 98 72               	jz 		MATH_ToInteger
(1)  116/      57 : E4 18               	xri 	'?'!0x27 											; Random number generator (' operator)
(1)  117/      59 : 98 B1               	jz 		MATH_Random 
(1)  118/      5B :                     MATH_Error:
(1)  119/      5B : 03                  	scl 														; error, unknown command.
(1)  120/      5C :                     MATH_Exit:
(1)  121/      5C : 3F                  	xppc 	p3 													; return
(1)  122/      5D : 90 E4               	jmp  	Maths 												; re-entrant
(1)  123/      5F :                     
(1)  124/      5F :                     ; ******************************************************************************************************************
(1)  125/      5F :                     ;													+ :	16 Bit Add
(1)  126/      5F :                     ; ******************************************************************************************************************
(1)  127/      5F :                     
(1)  128/      5F :                     MATH_Add:
(1)  129/      5F : 02                  	ccl 										
(1)  130/      60 : C6 01               	ld 		@1(p2) 												; read LSB of TOS and unstack
(1)  131/      62 : F2 01               	add 	1(p2)
(1)  132/      64 : CA 01               	st 		1(p2)
(1)  133/      66 : C6 01               	ld 		@1(p2) 												; read MSB of TOS and unstack
(1)  134/      68 : F2 01               	add 	1(p2)
(1)  135/      6A : CA 01               	st 		1(p2)
(1)  136/      6C : 02                  	ccl
(1)  137/      6D : 90 ED               	jmp 	MATH_Exit
(1)  138/      6F :                     
(1)  139/      6F :                     ; ******************************************************************************************************************
(1)  140/      6F :                     ;												 - : 16 Bit Subtract
(1)  141/      6F :                     ; ******************************************************************************************************************
(1)  142/      6F :                     
(1)  143/      6F :                     MATH_Subtract:
(1)  144/      6F : 03                  	scl 										
(1)  145/      70 : C2 02               	ld 		2(p2) 												; read LSB of TOS 
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 4 - 12/2/2015 13:45:23


(1)  146/      72 : FA 00               	cad 	0(p2)
(1)  147/      74 : CA 02               	st 		2(p2)
(1)  148/      76 : C2 03               	ld 		3(p2) 												; read MSB of TOS
(1)  149/      78 : FA 01               	cad 	1(p2)
(1)  150/      7A : CA 03               	st 		3(p2)
(1)  151/      7C : C6 02               	ld 		@2(p2)
(1)  152/      7E : 02                  	ccl
(1)  153/      7F : 90 DB               	jmp 	MATH_Exit
(1)  154/      81 :                     
(1)  155/      81 :                     ; ******************************************************************************************************************
(1)  156/      81 :                     ;												'*' : 16 bit signed multiply
(1)  157/      81 :                     ; ******************************************************************************************************************
(1)  158/      81 :                     
(1)  159/      81 :                     MATH_Multiply:
(1)  160/      81 :                     
(1)  161/      81 :                     	section SCMPMultiply
(1)  162/      81 :                     
(1)  163/      81 : =0x3                aHi = 3 														; allocated values for A,B and Result.
(1)  164/      81 : =0x2                aLo = 2 														; (see arithmetic.py)
(1)  165/      81 : =0x1                bHi = 1
(1)  166/      81 : =0x0                bLo = 0
(1)  167/      81 : =0xFFFFFFFFF..      resultHi = -1
(1)  168/      81 : =0xFFFFFFFFF..      resultLo = -2
(1)  169/      81 :                     
(1)  170/      81 : C4 00               	ldi 	0 													; clear result
(1)  171/      83 : CA FF               	st 		resultHi(p2)
(1)  172/      85 : CA FE               	st 		resultLo(p2)
(1)  173/      87 :                     __MultiplyLoop:
(1)  174/      87 : C2 01               	ld 		bHi(p2) 											; if b is zero then exit
(1)  175/      89 : DA 00               	or 		bLo(p2)
(1)  176/      8B : 98 2D               	jz 		__MultiplyExit
(1)  177/      8D : C2 00               	ld 		bLo(p2) 											; if b bit 0 is set.
(1)  178/      8F : D4 01               	ani 	1
(1)  179/      91 : 98 0D               	jz 		__MultiplyNoAdd
(1)  180/      93 : 02                  	ccl 														; add a to the result
(1)  181/      94 : C2 FE               	ld 		resultLo(p2)
(1)  182/      96 : F2 02               	add 	aLo(p2)
(1)  183/      98 : CA FE               	st 		resultLo(p2)
(1)  184/      9A : C2 FF               	ld 		resultHi(p2)
(1)  185/      9C : F2 03               	add 	aHi(p2)
(1)  186/      9E : CA FF               	st 		resultHi(p2)
(1)  187/      A0 :                     __MultiplyNoAdd:
(1)  188/      A0 : (MACRO)             	shiftleft aLo 												; shift A left once.
(1)  188/      A0 : 02                          ccl                                                                                                     
(1)  188/      A1 : C2 02                       ld              ALO(p2)
(1)  188/      A3 : F2 02                       add     ALO(p2)
(1)  188/      A5 : CA 02                       st              ALO(p2)
(1)  188/      A7 : C2 03                       ld              ALO+1(p2)
(1)  188/      A9 : F2 03                       add     ALO+1(p2)
(1)  188/      AB : CA 03                       st              ALO+1(p2)               
(1)  189/      AD : (MACRO)             	shiftright bLo 												; shift b right one.
(1)  189/      AD : 02                          ccl
(1)  189/      AE : C2 01                       ld              BLO+1(p2)
(1)  189/      B0 : 1F                          rrl 
(1)  189/      B1 : CA 01                       st              BLO+1(p2)
(1)  189/      B3 : C2 00                       ld              BLO(p2)
(1)  189/      B5 : 1F                          rrl 
(1)  189/      B6 : CA 00                       st              BLO(p2)
(1)  190/      B8 : 90 CD               	jmp 	__MultiplyLoop
(1)  191/      BA :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 5 - 12/2/2015 13:45:23


(1)  192/      BA :                     __MultiplyExit:
(1)  193/      BA : C2 FE               	ld 		resultLo(p2) 										; copy result lo to what will be new TOS
(1)  194/      BC : CA 02               	st 		2(p2)
(1)  195/      BE : C2 FF               	ld 		resultHi(p2)
(1)  196/      C0 : CA 03               	st 		3(p2)
(1)  197/      C2 : C6 02               	ld 		@2(p2) 												; fix up the number stack.
(1)  198/      C4 :                     	endsection SCMPMultiply
(1)  199/      C4 :                     
(1)  200/      C4 : 02                  	ccl
(1)  201/      C5 :                     MATH_Exit1:
(1)  202/      C5 : 90 95               	jmp 	MATH_Exit
(1)  203/      C7 :                     
(1)  204/      C7 :                     ; ******************************************************************************************************************
(1)  205/      C7 :                     ;								? Convert string at P1 to 16 bit integer base 10
(1)  206/      C7 :                     ; ******************************************************************************************************************
(1)  207/      C7 :                     
(1)  208/      C7 :                     MATH_Divide2:
(1)  209/      C7 : 90 63               	jmp 	MATH_Divide
(1)  210/      C9 :                     
(1)  211/      C9 :                     MATH_ToInteger:
(1)  212/      C9 :                     
(1)  213/      C9 :                     	section SCMPToInteger
(1)  214/      C9 :                     
(1)  215/      C9 : =0xFFFFFFFFF..      digitCount = -1													; digits converted.
(1)  216/      C9 : =0xFFFFFFFFF..      resultHi = -2  													; result is pushed at the end
(1)  217/      C9 : =0xFFFFFFFFF..      resultLo = -3 
(1)  218/      C9 : =0xFFFFFFFFF..      shiftCount = -4 												; counter used when multiplying by 10.
(1)  219/      C9 : =0xFFFFFFFFF..      tempHi = -5 													; temporary result for x 10.
(1)  220/      C9 : =0xFFFFFFFFF..      tempLo = -6
(1)  221/      C9 :                     
(1)  222/      C9 : C4 00               	ldi 	0 													; clear digitcount and result to zero
(1)  223/      CB : CA FF               	st 		digitCount(p2)
(1)  224/      CD : CA FE               	st 		resultHi(p2)
(1)  225/      CF : CA FD               	st 		resultLo(p2)
(1)  226/      D1 :                     ToInt_Loop:
(1)  227/      D1 : C1 00               	ld 		0(p1) 												; read next digit
(1)  228/      D3 : 03                  	scl 	
(1)  229/      D4 : FC 3A               	cai 	'9'+1
(1)  230/      D6 : 94 44               	jp 		ToInt_End 											; if > 9 then fail.
(1)  231/      D8 : F4 8A               	adi 	128+10 												; if < 0 then fail
(1)  232/      DA : 94 40               	jp 		ToInt_End
(1)  233/      DC : AA FF               	ild 	digitCount(p2) 										; increment count of digits converted.
(1)  234/      DE : C4 02               	ldi 	2 													; set shift counter to 2
(1)  235/      E0 : CA FC               	st 		shiftCount(p2)
(1)  236/      E2 : C2 FE               	ld 		resultHi(p2) 										; copy result current to temp
(1)  237/      E4 : CA FB               	st 		tempHi(p2)
(1)  238/      E6 : C2 FD               	ld 		resultLo(p2)
(1)  239/      E8 : CA FA               	st 		tempLo(p2)
(1)  240/      EA :                     ToInt_Shift:
(1)  241/      EA : (MACRO)             	shiftleft resultLo 											; shift result left
(1)  241/      EA : 02                          ccl                                                                                                     
(1)  241/      EB : C2 FD                       ld              RESULTLO(p2)
(1)  241/      ED : F2 FD                       add     RESULTLO(p2)
(1)  241/      EF : CA FD                       st              RESULTLO(p2)
(1)  241/      F1 : C2 FE                       ld              RESULTLO+1(p2)
(1)  241/      F3 : F2 FE                       add     RESULTLO+1(p2)
(1)  241/      F5 : CA FE                       st              RESULTLO+1(p2)               
(1)  242/      F7 : BA FC               	dld 	shiftCount(p2) 										; after 2nd time round (x 4) will be zero
(1)  243/      F9 : 9C 0D               	jnz 	ToInt_NoAdd
(1)  244/      FB : 02                  	ccl 														; add original value when x 4 - e.g. x 5
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 6 - 12/2/2015 13:45:23


(1)  245/      FC : C2 FD               	ld 		resultLo(p2)
(1)  246/      FE : F2 FA               	add 	tempLo(p2)
(1)  247/     100 : CA FD               	st 		resultLo(p2)
(1)  248/     102 : C2 FE               	ld 		resultHi(p2)
(1)  249/     104 : F2 FB               	add 	tempHi(p2)
(1)  250/     106 : CA FE               	st 		resultHi(p2)
(1)  251/     108 :                     ToInt_NoAdd:
(1)  252/     108 : C2 FC               	ld 		shiftCount(p2) 										; go round until -ve, e.g. 3 in total.
(1)  253/     10A : 94 DE               	jp 		ToInt_Shift
(1)  254/     10C :                     
(1)  255/     10C : C5 01               	ld 		@1(p1) 												; read the digit already tested.
(1)  256/     10E : D4 0F               	ani 	0x0F 												; to a number
(1)  257/     110 : 02                  	ccl 
(1)  258/     111 : F2 FD               	add 	resultLo(p2) 										; add to result
(1)  259/     113 : CA FD               	st 		resultLo(p2)
(1)  260/     115 : 06                  	csa 														; if carry clear
(1)  261/     116 : 94 B9               	jp 		ToInt_Loop 											; go round again.
(1)  262/     118 : AA FE               	ild 	resultHi(p2) 										; adds the carry to high
(1)  263/     11A : 90 B5               	jmp 	ToInt_Loop
(1)  264/     11C :                     
(1)  265/     11C :                     ToInt_End:
(1)  266/     11C : C2 FF               	ld 		digitCount(p2) 										; if digit count = 0, e.g. nothing converted
(1)  267/     11E : 03                  	scl
(1)  268/     11F : 98 A4               	jz 		MATH_Exit1 											; exit with carry set
(1)  269/     121 :                     
(1)  270/     121 : C2 FE               	ld 		resultHi(p2) 										; save result on stack
(1)  271/     123 : CA FF               	st 		-1(p2)
(1)  272/     125 : C2 FD               	ld 		resultLo(p2)
(1)  273/     127 : CE FE               	st 		@-2(p2)
(1)  274/     129 : 02                  	ccl 														; clear carry as okay, and exit.
(1)  275/     12A :                     	endsection SCMPToInteger
(1)  276/     12A :                     
(1)  277/     12A :                     MATH_Exit3:
(1)  278/     12A : 90 99               	jmp 	MATH_Exit1
(1)  279/     12C :                     
(1)  280/     12C :                     
(1)  281/     12C :                     
(1)  282/     12C :                     ; ******************************************************************************************************************
(1)  283/     12C :                     ;											'/' : 16 bit signed divide
(1)  284/     12C :                     ; ******************************************************************************************************************
(1)  285/     12C :                     
(1)  286/     12C :                     MATH_Divide:
(1)  287/     12C :                     
(1)  288/     12C :                     	section 	SCMPDivide
(1)  289/     12C :                     
(1)  290/     12C : =0x1                denominatorHi = 1 												; input values to division
(1)  291/     12C : =0x0                denominatorLo = 0 												; (see arithmetic.py)
(1)  292/     12C : =0x3                numeratorHi = 3
(1)  293/     12C : =0x2                numeratorLo = 2
(1)  294/     12C : =0xFFFFFFFFF..      bitHi = -1 														; bit shifted for division test.
(1)  295/     12C : =0xFFFFFFFFF..      bitLo = -2
(1)  296/     12C : =0xFFFFFFFFF..      quotientHi = -3 												; quotient
(1)  297/     12C : =0xFFFFFFFFF..      quotientLo = -4
(1)  298/     12C : =0xFFFFFFFFF..      remainderHi = -5 												; remainder
(1)  299/     12C : =0xFFFFFFFFF..      remainderLo = -6
(1)  300/     12C : =0xFFFFFFFFF..      signCount = -7 													; sign of result (bit 0)
(1)  301/     12C : =0xFFFFFFFFF..      eTemp = -8 														; temporary value of sign.
(1)  302/     12C :                     
(1)  303/     12C : C2 00               	ld 		denominatorLo(p2) 									; check denominator 
(1)  304/     12E : DA 01               	or 		denominatorHi(p2) 
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 7 - 12/2/2015 13:45:23


(1)  305/     130 : 03                  	scl 														; if zero return CY/L Set
(1)  306/     131 : 98 F7               	jz 		MATH_Exit3
(1)  307/     133 :                     
(1)  308/     133 : C4 00               	ldi 	0 													; clear quotient and remainder
(1)  309/     135 : CA FD               	st 		quotientHi(p2)
(1)  310/     137 : CA FC               	st 		quotientLo(p2)
(1)  311/     139 : CA FB               	st 		remainderHi(p2)
(1)  312/     13B : CA FA               	st 		remainderLo(p2)
(1)  313/     13D : CA F9               	st 		signCount(p2)
(1)  314/     13F : CA FE               	st 		bitLo(p2) 											; set bit to 0x8000
(1)  315/     141 : C4 80               	ldi 	0x80 
(1)  316/     143 : CA FF               	st 		bitHi(p2)
(1)  317/     145 :                     
(1)  318/     145 : 40                  	lde 														; save E
(1)  319/     146 : CA F8               	st 		eTemp(p2)
(1)  320/     148 :                     
(1)  321/     148 : C4 03               	ldi 	3
(1)  322/     14A :                     __DivideUnsignLoop:
(1)  323/     14A : 01                  	xae 														; store in E
(1)  324/     14B : C2 80               	ld 		-0x80(p2) 											; read high byte
(1)  325/     14D : 94 13               	jp 		__DivideNotSigned 									; if +ve then skip
(1)  326/     14F : AA F9               	ild 	signCount(p2) 										; bump sign count
(1)  327/     151 : C6 FF               	ld 		@-1(p2) 											; dec P2 to access the LSB
(1)  328/     153 : C4 00               	ldi 	0
(1)  329/     155 : 03                  	scl 
(1)  330/     156 : FA 80               	cad 	-0x80(p2)
(1)  331/     158 : CA 80               	st 		-0x80(p2)
(1)  332/     15A : C6 01               	ld 		@1(p2) 												; inc P2 to access the MSB
(1)  333/     15C : C4 00               	ldi 	0
(1)  334/     15E : FA 80               	cad 	-0x80(p2)
(1)  335/     160 : CA 80               	st 		-0x80(p2)
(1)  336/     162 :                     __DivideNotSigned:
(1)  337/     162 : 01                  	xae 														; retrieve E
(1)  338/     163 : 03                  	scl 														; subtract 2
(1)  339/     164 : FC 02               	cai 	2
(1)  340/     166 : 94 E2               	jp 		__DivideUnsignLoop 									; not finished yet.
(1)  341/     168 : 90 02               	jmp 	__DivideLoop
(1)  342/     16A :                     
(1)  343/     16A :                     __MATH_Exit2
(1)  344/     16A : 90 BE               	jmp 	MATH_Exit3
(1)  345/     16C :                     
(1)  346/     16C :                     __DivideLoop:
(1)  347/     16C : C2 FE               	ld 		bitLo(p2) 											; keep going until all bits done.
(1)  348/     16E : DA FF               	or 		bitHi(p2)
(1)  349/     170 : 98 3D               	jz 		__DivideExit
(1)  350/     172 :                     
(1)  351/     172 : (MACRO)             	shiftleft remainderLo 										; shift remainder left.
(1)  351/     172 : 02                          ccl                                                                                                     
(1)  351/     173 : C2 FA                       ld              REMAINDERLO(p2)
(1)  351/     175 : F2 FA                       add     REMAINDERLO(p2)
(1)  351/     177 : CA FA                       st              REMAINDERLO(p2)
(1)  351/     179 : C2 FB                       ld              REMAINDERLO+1(p2)
(1)  351/     17B : F2 FB                       add     REMAINDERLO+1(p2)
(1)  351/     17D : CA FB                       st              REMAINDERLO+1(p2)               
(1)  352/     17F :                     
(1)  353/     17F : C2 03               	ld 		numeratorHi(p2)										; if numerator MSB is set
(1)  354/     181 : 94 06               	jp 		__DivideNoIncRemainder
(1)  355/     183 :                     
(1)  356/     183 : AA FA               	ild 	remainderLo(p2) 									; then increment remainder
(1)  357/     185 : 9C 02               	jnz 	__DivideNoIncRemainder
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 8 - 12/2/2015 13:45:23


(1)  358/     187 : AA FB               	ild 	remainderHi(p2)
(1)  359/     189 :                     __DivideNoIncRemainder:
(1)  360/     189 :                     
(1)  361/     189 : 03                  	scl 														; calculate remainder-denominator (temp)
(1)  362/     18A : C2 FA               	ld 		remainderLo(p2)
(1)  363/     18C : FA 00               	cad 	denominatorLo(p2)
(1)  364/     18E : 01                  	xae 														; save in E.
(1)  365/     18F : C2 FB               	ld 		remainderHi(p2)
(1)  366/     191 : FA 01               	cad 	denominatorHi(p2) 									; temp.high is now in A
(1)  367/     193 : 94 45               	jp 		__DivideRemainderGreater 							; if >= 0 then remainder >= denominator
(1)  368/     195 :                     
(1)  369/     195 :                     __DivideContinue:
(1)  370/     195 : (MACRO)             	shiftright 	bitLo 											; shift bit right
(1)  370/     195 : 02                          ccl
(1)  370/     196 : C2 FF                       ld              BITLO+1(p2)
(1)  370/     198 : 1F                          rrl 
(1)  370/     199 : CA FF                       st              BITLO+1(p2)
(1)  370/     19B : C2 FE                       ld              BITLO(p2)
(1)  370/     19D : 1F                          rrl 
(1)  370/     19E : CA FE                       st              BITLO(p2)
(1)  371/     1A0 : (MACRO)             	shiftleft   numeratorLo 									; shift numerator left
(1)  371/     1A0 : 02                          ccl                                                                                                     
(1)  371/     1A1 : C2 02                       ld              NUMERATORLO(p2)
(1)  371/     1A3 : F2 02                       add     NUMERATORLO(p2)
(1)  371/     1A5 : CA 02                       st              NUMERATORLO(p2)
(1)  371/     1A7 : C2 03                       ld              NUMERATORLO+1(p2)
(1)  371/     1A9 : F2 03                       add     NUMERATORLO+1(p2)
(1)  371/     1AB : CA 03                       st              NUMERATORLO+1(p2)               
(1)  372/     1AD : 90 BD               	jmp 		__DivideLoop
(1)  373/     1AF :                     
(1)  374/     1AF :                     __DivideExit:
(1)  375/     1AF : C2 F9               	ld 		signCount(p2) 										; is the result signed
(1)  376/     1B1 : D4 01               	ani 	0x01
(1)  377/     1B3 : 98 0D               	jz 		__DivideComplete
(1)  378/     1B5 : 03                  	scl 														; if so, reapply the sign.
(1)  379/     1B6 : C4 00               	ldi 	0
(1)  380/     1B8 : FA FC               	cad 	quotientLo(p2)
(1)  381/     1BA : CA FC               	st 		quotientLo(p2)
(1)  382/     1BC : C4 00               	ldi 	0
(1)  383/     1BE : FA FD               	cad 	quotientHi(p2)
(1)  384/     1C0 : CA FD               	st 		quotientHi(p2)
(1)  385/     1C2 :                     
(1)  386/     1C2 :                     __DivideComplete:
(1)  387/     1C2 : C2 FD               	ld 		quotientHi(p2) 										; copy quotient to what will be TOS
(1)  388/     1C4 : CA 03               	st 		3(p2)
(1)  389/     1C6 : C2 FC               	ld 		quotientLo(p2)
(1)  390/     1C8 : CA 02               	st 		2(p2)
(1)  391/     1CA : C2 FB               	ld 		remainderHi(p2) 									; put remainder immediately after it if we want it
(1)  392/     1CC : CA 01               	st 		1(p2)
(1)  393/     1CE : C2 FA               	ld 		remainderLo(p2) 
(1)  394/     1D0 : CA 00               	st 		0(p2)
(1)  395/     1D2 :                     
(1)  396/     1D2 : C2 F8               	ld 		eTemp(p2) 											; restore E
(1)  397/     1D4 : 01                  	xae 
(1)  398/     1D5 : C6 02               	ld 		@2(p2) 												; fix stack back up leaving quotient and hidden remainder
(1)  399/     1D7 : 02                  	ccl 														; return no error.
(1)  400/     1D8 : 90 90               	jmp 	__MATH_Exit2
(1)  401/     1DA :                     
(1)  402/     1DA :                     __DivideRemainderGreater: 										; this is the "if temp >= 0 bit"
(1)  403/     1DA : CA FB               	st 		remainderHi(p2) 									; save temp.high value into remainder.high
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 9 - 12/2/2015 13:45:23


(1)  404/     1DC : 40                  	lde 														; copy temp.low to remainder.low
(1)  405/     1DD : CA FA               	st 		remainderLo(p2) 
(1)  406/     1DF :                     
(1)  407/     1DF : C2 FC               	ld 		quotientLo(p2) 										; or bit into quotient
(1)  408/     1E1 : DA FE               	or 		bitLo(p2)
(1)  409/     1E3 : CA FC               	st 		quotientLo(p2)
(1)  410/     1E5 : C2 FD               	ld 		quotientHi(p2)
(1)  411/     1E7 : DA FF               	or 		bitHi(p2)
(1)  412/     1E9 : CA FD               	st 		quotientHi(p2)
(1)  413/     1EB : 90 A8               	jmp 	__DivideContinue
(1)  414/     1ED :                     
(1)  415/     1ED :                     
(1)  416/     1ED :                     	endsection	SCMPDivide
(1)  417/     1ED :                     
      36/     1ED :                     
      37/     1ED :                     ; ******************************************************************************************************************
      38/     1ED :                     ;
      39/     1ED :                     ;				Boot Up. First we check for a ROM @ $9000 and if it is 0x68 we boot there instead
      40/     1ED :                     ;
      41/     1ED :                     ; ******************************************************************************************************************
      42/     1ED :                     
      43/     1ED :                     BootMonitor:
      44/     1ED : C4 90               		ldi 	0x90 											; point P1 to $9000 which is the first ROM.
      45/     1EF : 35                  		xpah 	p1
      46/     1F0 : C1 00               		ld 		0(p1) 											; if that byte is $68, go straight there.
      47/     1F2 : E4 68               		xri 	0x68
      48/     1F4 : 9C 01               		jnz 	__BootMonitor
      49/     1F6 : 3D                  		xppc 	p1 												; e.g. JMP $9001
      50/     1F7 :                     __BootMonitor:
      51/     1F7 :                     
      52/     1F7 :                     ; ******************************************************************************************************************
      53/     1F7 :                     ;
      54/     1F7 :                     ;									Find Top of Memory to initialise the stack.
      55/     1F7 :                     ;
      56/     1F7 :                     ;			(slightly tweaked to work round 4+12 emulator limitations - will work on real chip)
      57/     1F7 :                     ; ******************************************************************************************************************
      58/     1F7 :                     
      59/     1F7 : C4 0F               		ldi 	0x0F 											; point P2 to theoretical top of RAM on basic m/c
      60/     1F9 : 36                  		xpah 	p2 												; e.g. 0xFFF
      61/     1FA : C4 FF               		ldi 	0xFF 											; ideally you'd make this 0x003F and remove the ld
      62/     1FC : 32                  		xpal 	p2 												; but the emulators don't do 4+12 math. Only matters here.
      63/     1FD : C6 40               		ld 		@64(p2) 										; fix the predecrement (wrap around not emulated)
      64/     1FF :                     FindTopMemory:
      65/     1FF : C4 A5               		ldi 	0xA5 											; try to write this to memory
      66/     201 : CE C0               		st 		@-64(p2) 										; predecrementing by 64.
      67/     203 : E2 00               		xor 	(p2) 											; did it write correctly.
      68/     205 : 9C F8               		jnz 	FindTopMemory 									; now P2 points to top of memory.
      69/     207 :                     
      70/     207 :                     ; ******************************************************************************************************************
      71/     207 :                     ;
      72/     207 :                     ;												Clear the screen
      73/     207 :                     ;
      74/     207 :                     ; ******************************************************************************************************************
      75/     207 :                     
      76/     207 :                     ClearScreen_Command:
      77/     207 : C4 00               		ldi 	0 												; set P1 to zero to access VRAM via write.
      78/     209 : 35                  		xpah 	p1
      79/     20A : C4 00               		ldi 	0
      80/     20C :                     ClearScreenLoop:
      81/     20C : 31                  		xpal 	p1												; clear screen
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 10 - 12/2/2015 13:45:23


      82/     20D : C4 20               		ldi 	' '
      83/     20F : CD 01               		st 		@1(p1)
      84/     211 : 31                  		xpal 	p1
      85/     212 : 94 F8               		jp 		ClearScreenLoop
      86/     214 : C4 0C               		ldi 	Cursor/256 										; reset the cursor position to TOS
      87/     216 : 35                  		xpah 	p1
      88/     217 : C4 18               		ldi 	Cursor&255
      89/     219 : 31                  		xpal 	p1 
      90/     21A : C4 00               		ldi 	0 												; Note: could save 2 bytes here, P1.H is 0.
      91/     21C : C9 00               		st 		0(p1)											
      92/     21E :                     
      93/     21E :                     ; ****************************************************************************************************************
      94/     21E :                     ;
      95/     21E :                     ;												Check if initialised.
      96/     21E :                     ;
      97/     21E :                     ; ****************************************************************************************************************
      98/     21E :                     
      99/     21E : C1 03               		ld 		isInit-Cursor(p1) 								; have we initialised ?
     100/     220 : E4 A7               		xri 	0xA7 											; if so this byte should be $A7
     101/     222 : 98 46               		jz 		CommandMainLoop
     102/     224 : C4 A7               		ldi 	0xA7 											; set the initialised byte
     103/     226 : C9 03               		st 		isInit-Cursor(p1)
     104/     228 :                     
     105/     228 : C4 0C               		ldi 	codeStart/256 									; set the initial work address
     106/     22A : C9 02               		st 		Current-Cursor+1(p1)
     107/     22C : C4 30               		ldi 	codeStart&255
     108/     22E : C9 01               		st 		Current-Cursor(p1)
     109/     230 : C4 AC               		ldi 	0xAC
     110/     232 : C9 07               		st 		random-Cursor+1(p1)								; initialise the LFSR with $ACE1
     111/     234 : C4 E1               		ldi 	0xE1
     112/     236 : C9 06               		st 		random-Cursor(p1)
     113/     238 :                     
     114/     238 :                     																; print boot message - can lose this if required.
     115/     238 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     116/     23A : 37                  		xpah 	p3 
     117/     23B : C4 BD               		ldi 	(PrintCharacter-1)&255
     118/     23D : 33                  		xpal 	p3
     119/     23E : C4 02               		ldi 	Message / 256 									; set P1 = boot message
     120/     240 : 35                  		xpah 	p1
     121/     241 : C4 4B               		ldi 	Message & 255
     122/     243 : 31                  		xpal 	p1
     123/     244 :                     MessageLoop:
     124/     244 : C5 01               		ld 		@1(p1) 											; read character
     125/     246 : 98 22               		jz 		CommandMainLoop 								; end of message
     126/     248 : 3F                  		xppc 	p3 												; print it
     127/     249 : 90 F9               		jmp 	MessageLoop
     128/     24B :                     
     129/     24B :                     Message:
     130/     24B : 2A 2A 20 53 43 2F   		db 		"** SC/MP OS **",13
                    4D 50 20 4F 53 20 
                    2A 2A 0D 
     131/     25A : 56 30 2E 39 30 20   		db 		"V0.90 PSR 2016",13
                    50 53 52 20 32 30 
                    31 36 0D 
     132/     269 : 00                  		db 		0
     133/     26A :                     
     134/     26A :                     ; ****************************************************************************************************************
     135/     26A :                     ;
     136/     26A :                     ;													Main Loop
     137/     26A :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 11 - 12/2/2015 13:45:23


     138/     26A :                     ; ****************************************************************************************************************
     139/     26A :                     
     140/     26A :                     CommandMainLoop:
     141/     26A : C4 06               		ldi 	(PrintAddressData-1)/256						; print Address only
     142/     26C : 37                  		xpah 	p3
     143/     26D : C4 2A               		ldi 	(PrintAddressData-1)&255
     144/     26F : 33                  		xpal 	p3
     145/     270 : C4 00               		ldi 	0 												; no data elements
     146/     272 : 3F                  		xppc 	p3
     147/     273 :                     
     148/     273 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     149/     275 : 37                  		xpah 	p3
     150/     276 : C4 BD               		ldi 	(PrintCharacter-1)&255
     151/     278 : 33                  		xpal 	p3
     152/     279 : C4 5D               		ldi 	']'												; print the prompt.
     153/     27B : 3F                  		xppc 	p3
     154/     27C :                     
     155/     27C :                     ; ****************************************************************************************************************
     156/     27C :                     ;
     157/     27C :                     ;											Keyboard Line Input
     158/     27C :                     ;
     159/     27C :                     ; ****************************************************************************************************************
     160/     27C :                     
     161/     27C : C4 00               		ldi 	0 												; set E = character position.
     162/     27E : 01                  		xae 
     163/     27F :                     KeyboardLoop:
     164/     27F : C4 08               		ldi 	0x8 											; set P1 to point to keyboard latch
     165/     281 : 35                  		xpah 	p1
     166/     282 :                     _KBDWaitRelease:
     167/     282 : C1 00               		ld 		0(p1) 											; wait for strobe to clear
     168/     284 : 94 02               		jp 		_KBDWaitKey
     169/     286 : 90 FA               		jmp 	_KBDWaitRelease
     170/     288 :                     _KBDWaitKey:
     171/     288 : C1 00               		ld 		0(p1) 											; wait for strobe, i.e. new key
     172/     28A : 94 FC               		jp 		_KBDWaitKey
     173/     28C : D4 7F               		ani 	0x7F 											; throw away bit 7
     174/     28E : CA FF               		st 		-1(p2) 											; save key.
     175/     290 :                     
     176/     290 : C4 0C               		ldi 	kbdBuffer/256 									; set P1 = keyboard buffer
     177/     292 : 35                  		xpah 	p1
     178/     293 : C4 20               		ldi 	kbdBuffer&255
     179/     295 : 31                  		xpal 	p1		
     180/     296 :                     
     181/     296 : C2 FF               		ld 		-1(p2) 											; read key
     182/     298 : E4 08               		xri 	8 												; is it backspace
     183/     29A : 98 1E               		jz 		__KBDBackSpace
     184/     29C : E4 05               		xri 	8!13 											; is it CR, then exit
     185/     29E : 98 28               		jz 		__KBDExit
     186/     2A0 :                     
     187/     2A0 : 40                  		lde 													; have we a full buffer.
     188/     2A1 : E4 10               		xri 	kbdBufferLn 									; if so, ignore the key.
     189/     2A3 : 98 DA               		jz 		KeyboardLoop
     190/     2A5 :                     
     191/     2A5 : C2 FF               		ld 		-1(p2) 											; restore the key.
     192/     2A7 : 02                  		ccl
     193/     2A8 : F4 20               		adi 	0x20											; will make lower case -ve
     194/     2AA : 94 02               		jp 		__KBDNotLower
     195/     2AC : FC 20               		cai 	0x20 											; capitalise
     196/     2AE :                     __KBDNotLower:
     197/     2AE : F4 E0               		adi 	0xE0 											; fix up.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 12 - 12/2/2015 13:45:23


     198/     2B0 : C9 80               		st 		-0x80(p1) 										; save in the buffer using E as index.
     199/     2B2 : 3F                  		xppc 	p3 												; print the character
     200/     2B3 : 01                  		xae 													; increment E
     201/     2B4 : 02                  		ccl
     202/     2B5 : F4 01               		adi 	1
     203/     2B7 : 01                  		xae
     204/     2B8 : 90 C5               		jmp 	KeyboardLoop 									; and get the next key.
     205/     2BA :                     
     206/     2BA :                     __KBDBackSpace:
     207/     2BA : 40                  		lde 													; get position
     208/     2BB : 98 C2               		jz 		KeyboardLoop 									; can't go back if at beginning
     209/     2BD : 03                  		scl 													; go back 1 from E
     210/     2BE : FC 01               		cai 	1
     211/     2C0 : 01                  		xae 
     212/     2C1 : C4 08               		ldi 	8 												; print a backspace
     213/     2C3 : 3F                  		xppc 	p3
     214/     2C4 : 90 B9               		jmp 	KeyboardLoop 									; and go round again.
     215/     2C6 :                     
     216/     2C6 :                     __CmdMainLoop1:
     217/     2C6 : 90 A2               		jmp 	CommandMainLoop
     218/     2C8 :                     
     219/     2C8 :                     __KBDExit:
     220/     2C8 : C9 80               		st 		-0x80(p1) 										; add the ASCIIZ terminator.
     221/     2CA : C4 0D               		ldi 	13												; print a new line.
     222/     2CC : 3F                  		xppc 	p3
     223/     2CD :                     
     224/     2CD :                     ; ****************************************************************************************************************
     225/     2CD :                     ;
     226/     2CD :                     ;						Extract the 5 bit 3 letter (max command value). P1 points to buffer
     227/     2CD :                     ;
     228/     2CD :                     ; ****************************************************************************************************************
     229/     2CD :                     
     230/     2CD : C4 00               		ldi 	0
     231/     2CF : 01                  		xae 													; E contains the LSB of the 5 bit shift
     232/     2D0 : 40                  		lde 	
     233/     2D1 : CA FF               		st 		-1(p2) 											; -1(P2) contains the MSB
     234/     2D3 : C9 FD               		st 		modifier-kbdBuffer(p1)							; clear the modifier.
     235/     2D5 :                     Extract5Bit:
     236/     2D5 : C1 00               		ld 		(p1) 											; look at character
     237/     2D7 : 02                  		ccl 													; add 128-65, will be +ve if < 64
     238/     2D8 : F4 3F               		adi 	128-65
     239/     2DA : 94 1A               		jp 		__ExtractEnd
     240/     2DC : C4 05               		ldi 	5 												; shift current value left 5 times using -2(p2)
     241/     2DE : CA FE               		st 		-2(p2)
     242/     2E0 :                     __Ex5Shift:
     243/     2E0 : 40                  		lde 													; shift E left into CY/L
     244/     2E1 : 02                  		ccl
     245/     2E2 : 70                  		ade 
     246/     2E3 : 01                  		xae
     247/     2E4 : C2 FF               		ld 		-1(p2) 											; shift CY/L into -1(p2) and carry/link
     248/     2E6 : F2 FF               		add 	-1(p2)
     249/     2E8 : CA FF               		st 		-1(p2)
     250/     2EA : BA FE               		dld 	-2(p2) 											; done it 5 times ?
     251/     2EC : 9C F2               		jnz 	__Ex5Shift
     252/     2EE : C5 01               		ld 		@1(p1) 											; re-read character.
     253/     2F0 : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     254/     2F2 : 58                  		ore 													; OR into E
     255/     2F3 : 01                  		xae
     256/     2F4 : 90 DF               		jmp 	Extract5Bit 									; go and get the next one.
     257/     2F6 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 13 - 12/2/2015 13:45:23


     258/     2F6 :                     __ExtractEnd:
     259/     2F6 : C4 1C               		ldi 	parPosn & 255 									; P1.L = Parameter Position, A = first non cmd char
     260/     2F8 : 31                  		xpal	p1
     261/     2F9 : C9 00               		st 		(p1) 											; write to parameter position.
     262/     2FB :                     
     263/     2FB :                     ; ****************************************************************************************************************
     264/     2FB :                     ;
     265/     2FB :                     ;						Find command in -1 (P2) (High) E (Low) in Command table
     266/     2FB :                     ;	
     267/     2FB :                     ; ****************************************************************************************************************
     268/     2FB :                     
     269/     2FB : C4 47               		ldi 	__commandList & 255 							; point P1 to the command list
     270/     2FD : 31                  		xpal 	p1
     271/     2FE : C4 07               		ldi 	__commandList / 256 		
     272/     300 : 35                  		xpah 	p1	
     273/     301 :                     __FindCommandLoop:
     274/     301 : C1 00               		ld 		0(p1) 											; reached the end of the table ?
     275/     303 : D9 01               		or 		1(p1)											; which is marked by word 0000
     276/     305 : 98 31               		jz 		__CommandError
     277/     307 : C5 03               		ld 		@3(p1) 											; read low byte, and point to next
     278/     309 : 60                  		xre
     279/     30A : 9C F5               		jnz 	__FindCommandLoop 								; if different to LSB loop back.
     280/     30C : C1 FE               		ld 		-2(p1) 											; read the high byte
     281/     30E : E2 FF               		xor 	-1(p2) 											; if different to the MSB loop back.
     282/     310 : 9C EF               		jnz 	__FindCommandLoop
     283/     312 :                     
     284/     312 :                     ; ****************************************************************************************************************
     285/     312 :                     ;
     286/     312 :                     ;				Found command, figure out if ASM or Command, if Command go to that routine
     287/     312 :                     ;
     288/     312 :                     ; ****************************************************************************************************************
     289/     312 :                     
     290/     312 : C4 5D               		ldi 	(GetParameter-1) & 255 							; point P3 to the get parameter code.
     291/     314 : 33                  		xpal 	p3
     292/     315 : C4 06               		ldi 	(GetParameter-1) / 256
     293/     317 : 37                  		xpah 	p3
     294/     318 :                     
     295/     318 : C1 FF               		ld 		-1(p1) 											; read the operation code.
     296/     31A : D4 F0               		ani 	0xF0 											; look at the m-s-nibble - commands are 0x20.
     297/     31C : E4 20               		xri 	0x20
     298/     31E : 9C 22               		jnz 	__Assembler
     299/     320 :                     
     300/     320 : C1 FF               		ld 		-1(p1) 											; re-read it
     301/     322 : 02                  		ccl
     302/     323 : F1 FF               		add 	-1(p1) 											; double it
     303/     325 : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     304/     327 : F4 EE               		adi 	__CommandTable & 255 							; make P1 point to the command table entry
     305/     329 : 31                  		xpal 	p1
     306/     32A : C4 07               		ldi 	__CommandTable / 256 					
     307/     32C : 35                  		xpah 	p1
     308/     32D : C1 00               		ld 		0(p1) 											; read low address
     309/     32F : 01                  		xae
     310/     330 : C1 01               		ld 		1(p1) 											; read high address
     311/     332 : 35                  		xpah 	p1 												; put in P1.H
     312/     333 : 40                  		lde 													; get low address
     313/     334 : 31                  		xpal 	p1 												; put in P1.L
     314/     335 : C5 FF               		ld 		@-1(p1) 										; fix up for the pre-increment
     315/     337 : 3D                  		xppc 	p1 												; and go there.
     316/     338 :                     
     317/     338 :                     __CommandError: 												; unknown command.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 14 - 12/2/2015 13:45:23


     318/     338 : C4 03               		ldi 	3 												; set the beeper on
     319/     33A : 07                  		cas
     320/     33B : 8F FF               		dly 	0xFF 											; short delay
     321/     33D : C4 00               		ldi 	0 												; set the beeper off
     322/     33F : 07                  		cas
     323/     340 : 90 84               		jmp 	__CmdMainLoop1
     324/     342 :                     
     325/     342 :                     ; ****************************************************************************************************************
     326/     342 :                     ;												In line Assembler
     327/     342 :                     ; ****************************************************************************************************************
     328/     342 :                     
     329/     342 :                     __Assembler:
     330/     342 : C1 FF               		ld 		-1(p1) 											; this is the operation code to use.
     331/     344 : CE FF               		st 		@-1(p2) 										; push on the stack.
     332/     346 :                     
     333/     346 : 3F                  		xppc 	p3 												; evaluate (any) parameter if present
     334/     347 : 06                  		csa 													; check carry flag set
     335/     348 : 94 27               		jp 		__ASMNoParameter  								; if clear, no parameter was provided.
     336/     34A :                     
     337/     34A : C4 1C               		ldi 	parPosn & 255
     338/     34C : 31                  		xpal 	p1 												; get the parameter LSB
     339/     34D : CE FF               		st 		@-1(p2) 										; push that on the stack, set P1 to parPosn
     340/     34F : C4 0C               		ldi 	parPosn / 256
     341/     351 : 35                  		xpah 	p1
     342/     352 : C1 00               		ld 		(p1) 											; read current position
     343/     354 : 31                  		xpal 	p1 												; P1 now points to character.
     344/     355 : C1 00               		ld 		(p1) 											; read character
     345/     357 : E4 21               		xri 	'!'												; is it the label pling ?
     346/     359 : 9C 1E               		jnz 	__ASMContinue 									; we don't need to change this pointer , we should technically.
     347/     35B : C2 00               		ld 		(p2) 											; read the value, which is the label number
     348/     35D : 03                  		scl
     349/     35E : FC 18               		cai 	labelCount 										; is it a valid label number
     350/     360 : 94 D6               		jp 		__CommandError 									; no, beep.
     351/     362 : C2 00               		ld 		(p2) 											; re-read the label number
     352/     364 : 01                  		xae 													; put in E
     353/     365 : C4 0C               		ldi 	Labels/256 										; point p1 to labels
     354/     367 : 35                  		xpah 	p1
     355/     368 : C4 00               		ldi 	Labels&255 
     356/     36A : 31                  		xpal 	p1
     357/     36B : C1 80               		ld 		-0x80(p1) 										; read label indexed using E.
     358/     36D : CA 00               		st 		(p2) 											; save as the operand
     359/     36F : 90 08               		jmp 	__ASMContinue 									; and continue
     360/     371 :                     
     361/     371 :                     __ASMNoParameter:
     362/     371 : C2 00               		ld 		(p2) 											; read the pushed operation code
     363/     373 : D4 80               		ani 	0x80 											; is bit 7 set ?
     364/     375 : 9C C1               		jnz 	__CommandError 									; if it is, we need a parameter
     365/     377 : CE FF               		st 		@-1(p2) 										; push zero on the stack as a dummy parameter.
     366/     379 :                     
     367/     379 :                     __ASMContinue:
     368/     379 : C4 0C               		ldi 	Current/256 									; p3 = &Current Address
     369/     37B : 37                  		xpah 	p3
     370/     37C : C4 19               		ldi 	Current&255
     371/     37E : 33                  		xpal 	p3
     372/     37F :                     
     373/     37F : C3 04               		ld 		modifier-Current(p3) 							; get the modifier (e.g. @,Pn etc.)
     374/     381 : 02                  		ccl
     375/     382 : F2 01               		add 	1(p2) 											; add to the opcode and write it back
     376/     384 : CA 01               		st 		1(p2)
     377/     386 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 15 - 12/2/2015 13:45:23


     378/     386 : C3 00               		ld 		(p3) 											; read current address into P1
     379/     388 : 31                  		xpal 	p1
     380/     389 : C3 01               		ld 		1(p3)
     381/     38B : 35                  		xpah 	p1
     382/     38C :                     
     383/     38C : C2 01               		ld 		1(p2) 											; read opcode.
     384/     38E : CD 01               		st 		@1(p1) 											; write out to current address and bump it.
     385/     390 : 94 1F               		jp 		__ASMExit 										; if +ve then no operand byte, exit.
     386/     392 :                     
     387/     392 : C2 00               		ld 		(p2) 											; read the operand byte
     388/     394 : CD 01               		st 		@1(p1) 											; write that out as well.
     389/     396 :                     
     390/     396 : C3 04               		ld 		modifier-Current(p3) 							; look at the modifier 
     391/     398 : 9C 17               		jnz 	__ASMExit 										; if non zero we don't need to do anything P0 = 00
     392/     39A : C2 01               		ld 		1(p2) 											; DLY is a special case
     393/     39C : E4 8F               		xri 	0x8F 											; where the modifier is zero but not PC relative.
     394/     39E : 98 11               		jz 		__ASMExit 												
     395/     3A0 :                     
     396/     3A0 : C1 FF               		ld 		-1(p1) 											; read operand
     397/     3A2 : 02                  		ccl 													; one fewer because we want the current addr+1 low
     398/     3A3 : FB 00               		cad 	(p3) 											; subtract the current address low.
     399/     3A5 : C9 FF               		st 		-1(p1) 											; write it back
     400/     3A7 :                     
     401/     3A7 : C2 01               		ld 		1(p2) 											; read opcode again
     402/     3A9 : D4 F0               		ani 	0xF0 											; is it 9x (a JMP command)
     403/     3AB : E4 90               		xri 	0x90
     404/     3AD : 9C 02               		jnz 	__ASMExit 										; if not, we are done
     405/     3AF : B9 FF               		dld 	-1(p1) 											; one fewer because of the pre-increment
     406/     3B1 :                     __ASMExit:
     407/     3B1 : 31                  		xpal 	p1 												; write current address back out
     408/     3B2 : CB 00               		st 		(p3)
     409/     3B4 : 35                  		xpah 	p1
     410/     3B5 : CB 01               		st 		1(p3)
     411/     3B7 : C6 02               		ld 		@2(p2) 											; drop stack values.
     412/     3B9 :                     
     413/     3B9 : 90 0C               		jmp 	__CmdMainLoop2 									; back to command loop
     414/     3BB :                     
     415/     3BB :                     ; ****************************************************************************************************************
     416/     3BB :                     ; ****************************************************************************************************************
     417/     3BB :                     ;
     418/     3BB :                     ;												Commands Section
     419/     3BB :                     ;
     420/     3BB :                     ; ****************************************************************************************************************
     421/     3BB :                     ; ****************************************************************************************************************
     422/     3BB :                     
     423/     3BB :                     ; ****************************************************************************************************************
     424/     3BB :                     ;											A : Set Current address
     425/     3BB :                     ; ****************************************************************************************************************
     426/     3BB :                     
     427/     3BB :                     Address_Command:
     428/     3BB : 3F                  		xppc 	p3 												; get parameter if exists
     429/     3BC : 3F                  		xppc 	p3 												; update current if exists.
     430/     3BD : 90 08               		jmp 	__CmdMainLoop2
     431/     3BF :                     
     432/     3BF :                     __CmdParameterFail:
     433/     3BF : C4 02               		ldi 	2 												; set the beeper on
     434/     3C1 : 07                  		cas
     435/     3C2 : 8F FF               		dly 	0xFF 											; short delay
     436/     3C4 : C4 00               		ldi 	0 												; set the beeper off
     437/     3C6 : 07                  		cas
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 16 - 12/2/2015 13:45:23


     438/     3C7 :                     __CmdMainLoop2:													; and go back to the start.
     439/     3C7 : C4 69               		ldi 	(CommandMainLoop-1) & 255
     440/     3C9 : 33                  		xpal 	p3
     441/     3CA : C4 02               		ldi 	(CommandMainLoop-1) / 256
     442/     3CC : 37                  		xpah 	p3
     443/     3CD : 3F                  		xppc 	p3
     444/     3CE :                     
     445/     3CE :                     ; ****************************************************************************************************************
     446/     3CE :                     ;										G : Go (Address must be specified.)
     447/     3CE :                     ; ****************************************************************************************************************
     448/     3CE :                     
     449/     3CE :                     Go_Command:
     450/     3CE : 3F                  		xppc 	p3 												; get parameter, which should exist.
     451/     3CF : 06                  		csa 													; look at CY/L which is set if it was.
     452/     3D0 : 94 ED               		jp 		__CmdParameterFail 								; if it is clear, beep an error.
     453/     3D2 : 31                  		xpal 	p1 												; copy P1 to P3
     454/     3D3 : 33                  		xpal 	p3
     455/     3D4 : 35                  		xpah 	p1
     456/     3D5 : 37                  		xpah 	p3
     457/     3D6 : C7 FF               		ld 		@-1(p3) 										; fix up for pre increment
     458/     3D8 : 3F                  		xppc 	p3 												; call the routine.		
     459/     3D9 :                     __CmdMainLoop3:
     460/     3D9 : 90 EC               		jmp 	__CmdMainLoop2 									; re-enter monitor.
     461/     3DB :                     
     462/     3DB :                     ; ****************************************************************************************************************
     463/     3DB :                     ;			PUT Write to tape : data mandatory, it is the byte count from the current address.
     464/     3DB :                     ; ****************************************************************************************************************
     465/     3DB :                     
     466/     3DB :                     PutTape_Command:
     467/     3DB : 3F                  		xppc 	p3 												; get the bytes to write.
     468/     3DC : 06                  		csa 													; if CC, no value was provided
     469/     3DD : 94 E0               		jp 		__CmdParameterFail 								; which is an error.
     470/     3DF : 31                  		xpal 	p1 												; store low byte count in -1(P2)
     471/     3E0 : CA FF               		st 		-1(p2)
     472/     3E2 : 35                  		xpah 	p1 												; store high byte count in -2(P2)
     473/     3E3 : CA FE               		st 		-2(p2)
     474/     3E5 : 02                  		ccl 													; skip over the update current address
     475/     3E6 : 3F                  		xppc 	p3 												; this won't update current address as CY/L = 0
     476/     3E7 : 3F                  		xppc 	p3 												; and load the current address into P1.
     477/     3E8 : C4 00               		ldi 	0 												; set the output tape bit low
     478/     3EA : 01                  		xae
     479/     3EB : 19                  		sio
     480/     3EC : C4 20               		ldi 	32 												; tape leader
     481/     3EE : CA FD               		st 		-3(p2)
     482/     3F0 :                     _PutTapeLeader:
     483/     3F0 : 8F FF               		dly 	0xFF
     484/     3F2 : BA FD               		dld 	-3(p2)
     485/     3F4 : 9C FA               		jnz 	_PutTapeLeader
     486/     3F6 :                     _PutTapeByte:													; output byte at P1
     487/     3F6 : C4 00               		ldi 	0 												; set output bit to 0
     488/     3F8 : 01                  		xae 	
     489/     3F9 : 19                  		sio
     490/     3FA : 8F 10               		dly 	tapeDelay * 4 									; 0 continuation bit + gap between tapes with no signal 
     491/     3FC : C4 01               		ldi 	0x1 											; set bit high
     492/     3FE : 01                  		xae
     493/     3FF : 19                  		sio 
     494/     400 : C4 00               		ldi 	0
     495/     402 : 8F 04               		dly 	tapeDelay 										; output the start bit.
     496/     404 : C5 01               		ld 		@1(p1) 											; read the byte and put it in E.
     497/     406 : 01                  		xae
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 17 - 12/2/2015 13:45:23


     498/     407 : C4 08               		ldi 	8 												; output 8 bits
     499/     409 : CA FD               		st 		-3(p2)
     500/     40B :                     _PutTapeBit:
     501/     40B : 19                  		sio 													; output MSB and shift
     502/     40C : C4 00               		ldi 	0
     503/     40E : 8F 04               		dly 	tapeDelay 								
     504/     410 : BA FD               		dld 	-3(p2) 											; do all 8 bits.
     505/     412 : 9C F7               		jnz 	_PutTapeBit
     506/     414 : BA FF               		dld 	-1(p2) 											; decrement counter
     507/     416 : 9C DE               		jnz 	_PutTapeByte
     508/     418 : BA FE               		dld 	-2(p2) 											; note MSB goes 0 to -1 when finished.
     509/     41A : 94 DA               		jp 		_PutTapeByte
     510/     41C : C4 01               		ldi 	0x01 											; add the termination bit.
     511/     41E : 01                  		xae
     512/     41F : 19                  		sio
     513/     420 : C4 00               		ldi 	0 												; put that out.
     514/     422 : 8F 04               		dly 	TapeDelay
     515/     424 : C4 00               		ldi 	0 												; and set the leve back to 0
     516/     426 : 01                  		xae 
     517/     427 : 19                  		sio
     518/     428 :                     __CmdMainLoop4:
     519/     428 : 90 AF               		jmp 	__CmdMainLoop3
     520/     42A :                     
     521/     42A :                     __CmdParameterFail1:
     522/     42A : 90 93               		jmp 	__CmdParameterFail
     523/     42C :                     
     524/     42C :                     ; ****************************************************************************************************************
     525/     42C :                     ;						GET [addr] load tape to current position or given address.
     526/     42C :                     ; ****************************************************************************************************************
     527/     42C :                     
     528/     42C :                     LoadTape_Command:
     529/     42C : 3F                  		xppc	p3 												; get parameter
     530/     42D : 3F                  		xppc 	p3												; update current address
     531/     42E : 3F                  		xppc 	p3 												; current address to P1.
     532/     42F : C4 08               		ldi 	0x8 											; point P3 to the keyboard.
     533/     431 : 37                  		xpah 	p3
     534/     432 :                     __GetTapeWait:
     535/     432 : C3 00               		ld 		0(p3) 											; check keyboard break
     536/     434 : D4 80               		ani 	0x80
     537/     436 : 9C F2               		jnz 	__CmdParameterFail1
     538/     438 : 19                  		sio 													; wait for the start bit, examine tape in.
     539/     439 : 40                  		lde 
     540/     43A : 94 F6               		jp 		__GetTapeWait
     541/     43C : 8F 06               		dly 	tapeDelay * 3 / 2 								; half way into the first bit.
     542/     43E : C4 08               		ldi 	8 												; read in 8 bits.
     543/     440 : CA FF               		st 		-1(p2)
     544/     442 :                     __GetTapeBits:
     545/     442 : 19                  		sio 													; read in one bit
     546/     443 : C4 00               		ldi 	0
     547/     445 : 8F 04               		dly 	tapeDelay 										; delay to next bit
     548/     447 : BA FF               		dld 	-1(p2) 											; read 8 bits.
     549/     449 : 9C F7               		jnz 	__GetTapeBits 
     550/     44B : 40                  		lde 													; store byte at current address
     551/     44C : CD 01               		st 		@1(p1)
     552/     44E : 19                  		sio 													; read in the byte, which is zero if continuing.
     553/     44F : 40                  		lde  													; examine bit 7 shifted in.
     554/     450 : 94 E0               		jp 		__GetTapeWait 									; if zero, wait for the next start bit.
     555/     452 :                     __CmdMainLoop5:
     556/     452 : 90 D4               		jmp 	__CmdMainLoop4
     557/     454 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 18 - 12/2/2015 13:45:23


     558/     454 :                     ; ****************************************************************************************************************
     559/     454 :                     ;										L : nn Set Label to current address
     560/     454 :                     ; ****************************************************************************************************************
     561/     454 :                     
     562/     454 :                     Label_Command:
     563/     454 : 3F                  		xppc 	p3 												; get parameter
     564/     455 : 06                  		csa 													; check it exists, CY/L must be set
     565/     456 : 94 D2               		jp 		__CmdParameterFail1
     566/     458 : 31                  		xpal 	p1 												; get into A
     567/     459 : 01                  		xae 													; put into E
     568/     45A : 40                  		lde 													; get back
     569/     45B : 03                  		scl
     570/     45C : FC 18               		cai 	labelCount 										; check is < number of labels
     571/     45E : 94 CA               		jp 		__CmdParameterFail1
     572/     460 :                     
     573/     460 : C4 0C               		ldi 	Current/256 									; point P1 to current address
     574/     462 : 35                  		xpah 	p1
     575/     463 : C4 19               		ldi 	Current&255
     576/     465 : 31                  		xpal 	p1
     577/     466 : C1 00               		ld 		(p1) 											; read current address
     578/     468 : 31                  		xpal 	p1 												; save in P1.Low
     579/     469 : C4 00               		ldi 	Labels&255 										; get labels low byte in same page as current address
     580/     46B : 02                  		ccl
     581/     46C : 70                  		ade 													; add label # to it
     582/     46D : 31                  		xpal 	p1 												; put in P1.L and restore current address low
     583/     46E : C9 00               		st 		(p1) 											; store current address low in label space.
     584/     470 : 90 E0               		jmp 	__CmdMainLoop5 									; and exit.
     585/     472 :                     
     586/     472 :                     ; ****************************************************************************************************************
     587/     472 :                     ;											M :	Dump Memory
     588/     472 :                     ; ****************************************************************************************************************
     589/     472 :                     
     590/     472 :                     MemoryDump_Command:
     591/     472 : 3F                  		xppc 	p3 												; get parameter if exists
     592/     473 : 3F                  		xppc 	p3 												; update current if exists.
     593/     474 : C4 07               		ldi 	7 												; print seven rows
     594/     476 : CE FF               		st 		@-1(p2)
     595/     478 :                     __DCLoop:
     596/     478 : C4 06               		ldi 	(PrintAddressData-1)/256						; print one row of address and data.
     597/     47A : 37                  		xpah 	p3
     598/     47B : C4 2A               		ldi 	(PrintAddressData-1)&255
     599/     47D : 33                  		xpal 	p3
     600/     47E : C4 04               		ldi 	4
     601/     480 : 3F                  		xppc 	p3
     602/     481 : C4 0C               		ldi 	Current/256 									; point P1 to current
     603/     483 : 35                  		xpah 	p1
     604/     484 : C4 19               		ldi 	Current&255 
     605/     486 : 31                  		xpal 	p1
     606/     487 : C1 00               		ld 		0(p1) 											; add 4 to current address
     607/     489 : 02                  		ccl
     608/     48A : F4 04               		adi 	4
     609/     48C : C9 00               		st 		0(p1)
     610/     48E : C1 01               		ld 		1(p1)
     611/     490 : F4 00               		adi 	0
     612/     492 : C9 01               		st 		1(p1)
     613/     494 : BA 00               		dld 	(p2) 											; do it 7 times
     614/     496 : 9C E0               		jnz 	__DCLoop
     615/     498 : C6 01               		ld 		@1(p2) 											; fix up stack.
     616/     49A :                     __CmdMainLoop6:
     617/     49A : 90 B6               		jmp 	__CmdMainLoop5
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 19 - 12/2/2015 13:45:23


     618/     49C :                     
     619/     49C :                     
     620/     49C :                     ; ****************************************************************************************************************
     621/     49C :                     ;								B: Enter Bytes (no address, sequence of byte data)
     622/     49C :                     ; ****************************************************************************************************************
     623/     49C :                     
     624/     49C :                     EnterBytes_Command:
     625/     49C : C4 5D               		ldi 	(GetParameter-1) & 255 							; P3 = Get Parameter routine
     626/     49E : 33                  		xpal 	p3
     627/     49F : C4 06               		ldi 	(GetParameter-1) / 256 	
     628/     4A1 : 37                  		xpah 	p3
     629/     4A2 : 3F                  		xppc 	p3 												; get the parameter.
     630/     4A3 : 06                  		csa 													; look at carry
     631/     4A4 : 94 AC               		jp 		__CmdMainLoop5 									; carry clear, no value.
     632/     4A6 : C4 0C               		ldi 	Current/256 									; make P1 point to current
     633/     4A8 : 35                  		xpah 	p1
     634/     4A9 : C4 19               		ldi 	Current&255 										
     635/     4AB : 31                  		xpal 	p1 												; this pulls the byte value into A
     636/     4AC : 01                  		xae 													; save it in E
     637/     4AD : C1 00               		ld 		0(p1) 											; copy address to save to into P3
     638/     4AF : 33                  		xpal 	p3
     639/     4B0 : C1 01               		ld 		1(p1) 
     640/     4B2 : 37                  		xpah 	p3 
     641/     4B3 : 40                  		lde 													; get byte back
     642/     4B4 : CB 00               		st 		(p3) 											; save it in that location
     643/     4B6 : A9 00               		ild 	0(p1) 											; bump current address and go back and try again.
     644/     4B8 : 9C E2               		jnz 	EnterBytes_Command
     645/     4BA : A9 01               		ild 	1(p1)
     646/     4BC : 90 DE               		jmp 	EnterBytes_Command
     647/     4BE :                     
     648/     4BE :                     ; ****************************************************************************************************************
     649/     4BE :                     ;											D [aaaa] Disassembler
     650/     4BE :                     ; ****************************************************************************************************************
     651/     4BE :                     
     652/     4BE :                     Disassemble_Command:	
     653/     4BE : 3F                  		xppc 	p3 												; evaluate
     654/     4BF : 3F                  		xppc 	p3 												; update current if new value
     655/     4C0 : C4 07               		ldi 	7												; instructions to disassemble counter
     656/     4C2 : CE FC               		st 		@-4(p2)											; p2 + 0 = counter p2 + 1 = opcode p2 + 2 = operand
     657/     4C4 :                     __DAssLoop:														; p2 + 3 = opcode - base opcode.
     658/     4C4 : C4 06               		ldi 	(PrintAddressData-1)/256						; print Address only
     659/     4C6 : 37                  		xpah 	p3
     660/     4C7 : C4 2A               		ldi 	(PrintAddressData-1)&255
     661/     4C9 : 33                  		xpal 	p3
     662/     4CA : C4 00               		ldi 	0
     663/     4CC : 3F                  		xppc 	p3
     664/     4CD : C4 0C               		ldi 	Current / 256 									; point P1 to current address
     665/     4CF : 35                  		xpah 	p1
     666/     4D0 : C4 19               		ldi 	Current & 255
     667/     4D2 : 31                  		xpal 	p1
     668/     4D3 : C1 00               		ld 		0(p1) 											; load current address into P3
     669/     4D5 : 33                  		xpal 	p3
     670/     4D6 : C1 01               		ld 		1(p1)
     671/     4D8 : 37                  		xpah 	p3
     672/     4D9 : C7 01               		ld 		@1(p3) 											; read opcode
     673/     4DB : CA 01               		st 		1(p2) 											; save it
     674/     4DD : 94 04               		jp 		__DAssNoOperand 								; if +ve no operand
     675/     4DF : C7 01               		ld 		@1(p3) 											; read operand
     676/     4E1 : CA 02               		st 		2(p2) 											; save it
     677/     4E3 :                     __DAssNoOperand:
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 20 - 12/2/2015 13:45:23


     678/     4E3 : C4 E9               		ldi 	(__CommandListEnd-3) & 255
     679/     4E5 : 33                  		xpal 	p3 												; update current position, setting P3 to last entry
     680/     4E6 : C9 00               		st 		0(p1)											; in command table.
     681/     4E8 : C4 07               		ldi 	(__CommandListEnd-3) / 256
     682/     4EA : 37                  		xpah 	p3
     683/     4EB : C9 01               		st 		1(p1)
     684/     4ED :                     
     685/     4ED :                     __DAssFindOpcode: 												; the table is : text (word) opcode (byte)
     686/     4ED : C2 01               		ld 		1(p2) 											; get opcode
     687/     4EF : E3 02               		xor 	2(p3) 											; check in the same 8 byte page.
     688/     4F1 : D4 F0               		ani 	0xF0
     689/     4F3 : 9C 0B               		jnz 	__DAssNextOpcode
     690/     4F5 : C2 01               		ld 		1(p2) 											; get opcode
     691/     4F7 : 03                  		scl
     692/     4F8 : FB 02               		cad 	2(p3) 											; subtract the base opcode.
     693/     4FA : CA 03               		st 		3(p2) 											; save a the offset (possible)
     694/     4FC : D4 E0               		ani 	0xE0 											; it needs to be 0x20 or less
     695/     4FE : 98 08               		jz 		__DAssFoundOpcode 								; if >= 0 then found the correct opcode.
     696/     500 :                     __DAssNextOpcode:
     697/     500 : C7 FD               		ld 		@-3(p3) 										; go to previous entry in table
     698/     502 : 90 E9               		jmp 	__DAssFindOpcode
     699/     504 :                     
     700/     504 :                     __DAssLoop2:
     701/     504 : 90 BE               		jmp 	__DAssLoop
     702/     506 :                     __CmdMainLoop7:
     703/     506 : 90 92               		jmp 	__CmdMainLoop6
     704/     508 :                     
     705/     508 :                     __DAssFoundOpcode:
     706/     508 : C3 02               		ld 		2(p3) 											; look at opcode that matched.
     707/     50A : D4 87               		ani 	0x87 											; match with 1xxx x100
     708/     50C : E4 84               		xri 	0x84 											; which is all the immediate instructions.		
     709/     50E : 9C 04               		jnz 	__DAssNotImmediate
     710/     510 : C2 03               		ld 		3(p2) 											; only do immediate if base offset is zero
     711/     512 : 9C EC               		jnz 	__DAssNextOpcode 								; fixes C0-C7 being LD, but C4 being LDI.
     712/     514 :                     __DAssNotImmediate:
     713/     514 : C3 00               		ld 		0(p3) 											; save LSB of text on stack
     714/     516 : CE FF               		st 		@-1(p2)
     715/     518 : C3 01               		ld 		1(p3) 											; and the MSB of text on stack
     716/     51A : CE FF               		st 		@-1(p2)
     717/     51C :                     
     718/     51C : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     719/     51E : 37                  		xpah 	p3
     720/     51F : C4 BD               		ldi 	(PrintCharacter-1) & 255 
     721/     521 : 33                  		xpal 	p3
     722/     522 : C4 20               		ldi 	' '												; print a space.
     723/     524 : 3F                  		xppc 	p3
     724/     525 :                     
     725/     525 : C4 03               		ldi 	3 												; print 3 characters
     726/     527 : CE FF               		st 		@-1(p2) 										; so +0 is count, +1 = text MSB, +2 = text LSB
     727/     529 :                     __DAssPrintMnemonic:
     728/     529 : C2 01               		ld 		1(p2) 											; get text MSB which is in bits .xxxxx..
     729/     52B : 1C                  		sr 														; shift right twice.
     730/     52C : 1C                  		sr
     731/     52D : D4 1F               		ani 	0x1F 											; lower 5 bits only
     732/     52F : 98 04               		jz 		__DAssSkipSpace 								; don't print spaces (00000)
     733/     531 : 02                  		ccl 													; make it 7 bit ASCII code.
     734/     532 : F4 40               		adi 	64 							
     735/     534 : 3F                  		xppc 	p3 												; display the character
     736/     535 :                     __DAssSkipSpace:
     737/     535 : C4 05               		ldi 	5 												; now shift the encoded data left 5 times
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 21 - 12/2/2015 13:45:23


     738/     537 : CA FF               		st 		-1(p2)
     739/     539 :                     __DAssShiftEncode:
     740/     539 : 02                  		ccl
     741/     53A : C2 02               		ld 		2(p2)
     742/     53C : F2 02               		add 	2(p2)
     743/     53E : CA 02               		st 		2(p2)
     744/     540 : C2 01               		ld 		1(p2)
     745/     542 : F2 01               		add 	1(p2)
     746/     544 : CA 01               		st 		1(p2)
     747/     546 : BA FF               		dld 	-1(p2)
     748/     548 : 9C EF               		jnz 	__DAssShiftEncode
     749/     54A : BA 00               		dld 	0(p2) 											; done all three characters
     750/     54C : 9C DB               		jnz 	__DAssPrintMnemonic 							; if not keep going.
     751/     54E :                     
     752/     54E : C6 03               		ld 		@3(p2) 											; remove mnemonic stuff off the stack.
     753/     550 :                     
     754/     550 : C2 03               		ld 		3(p2) 											; print instruction modifier if required.
     755/     552 : 9C 1F               		jnz 	__DAssPrintModifier
     756/     554 :                     
     757/     554 :                     __DAssPrintOperand:
     758/     554 : C2 01               		ld 		1(p2) 											; get original opcode
     759/     556 : 94 0A               		jp 		__DAssNext 										; if no operand go to next line of disassembly.
     760/     558 : C4 05               		ldi 	(PrintHexByte-1) / 256 							; set P3 to point to the hex printer
     761/     55A : 37                  		xpah 	p3
     762/     55B : C4 8A               		ldi 	(PrintHexByte-1) & 255
     763/     55D : 33                  		xpal 	p3
     764/     55E : C2 02               		ld 		2(p2) 											; get operand
     765/     560 : 03                  		scl 
     766/     561 : 3F                  		xppc 	p3 												; print it out with a leading space.
     767/     562 :                     
     768/     562 :                     __DAssNext:
     769/     562 : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     770/     564 : 37                  		xpah 	p3
     771/     565 : C4 BD               		ldi 	(PrintCharacter-1) & 255 
     772/     567 : 33                  		xpal 	p3
     773/     568 : C4 0D               		ldi 	13												; print a newline.
     774/     56A : 3F                  		xppc 	p3
     775/     56B :                     
     776/     56B : BA 00               		dld 	0(p2) 											; done all 6 lines
     777/     56D : 9C 95               		jnz 	__DAssLoop2 									; no, go round again.
     778/     56F : C6 04               		ld 		@4(p2) 											; fix up the stack.
     779/     571 : 90 93               		jmp 	__CmdMainLoop7 									; and time to exit.
     780/     573 :                     
     781/     573 :                     
     782/     573 :                     __DAssPrintModifier:
     783/     573 : C4 20               		ldi 	' '												; print leading space
     784/     575 : 3F                  		xppc 	p3
     785/     576 : C2 03               		ld 		3(p2) 											; read modifier
     786/     578 : D4 04               		ani 	0x04 											; is @ bit set
     787/     57A : 98 03               		jz 		__DAssNotAutoIndexed
     788/     57C : C4 40               		ldi 	'@'												; print '@'
     789/     57E : 3F                  		xppc 	p3
     790/     57F :                     __DAssNotAutoIndexed:
     791/     57F : C4 50               		ldi 	'P'												; print 'P'
     792/     581 : 3F                  		xppc 	p3
     793/     582 : C2 03               		ld 		3(p2) 											; print pointer register
     794/     584 : D4 03               		ani 	3
     795/     586 : DC 30               		ori 	'0'
     796/     588 : 3F                  		xppc 	p3
     797/     589 : 90 C9               		jmp 	__DAssPrintOperand 								; and print operand.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 22 - 12/2/2015 13:45:23


     798/     58B :                     
     799/     58B :                     
     800/     58B :                     ; ****************************************************************************************************************
     801/     58B :                     ; ****************************************************************************************************************
     802/     58B :                     ;
     803/     58B :                     ;						Print A as a hexadecimal 2 digit value. If CY/L set precede with space
     804/     58B :                     ;
     805/     58B :                     ; ****************************************************************************************************************
     806/     58B :                     ; ****************************************************************************************************************
     807/     58B :                     
     808/     58B :                     PrintHexByte:
     809/     58B : CE FF               		st 		@-1(p2) 										; push A and P3, set P3 up to print character
     810/     58D : C4 05               		ldi 	(PrintCharacter-1)/256
     811/     58F : 37                  		xpah 	p3
     812/     590 : CE FF               		st 		@-1(p2)
     813/     592 : C4 BD               		ldi 	(PrintCharacter-1)&255
     814/     594 : 33                  		xpal 	p3
     815/     595 : CE FF               		st 		@-1(p2)
     816/     597 : 06                  		csa 													; check carry
     817/     598 : 94 03               		jp 		__PHBNoSpace									; if clear, no space.
     818/     59A : C4 20               		ldi 	' '												; print leading space
     819/     59C : 3F                  		xppc 	p3 
     820/     59D :                     __PHBNoSpace:
     821/     59D : C2 02               		ld 		2(p2) 											; read digit
     822/     59F : 1C                  		sr 														; convert MSB
     823/     5A0 : 1C                  		sr
     824/     5A1 : 1C                  		sr
     825/     5A2 : 1C                  		sr
     826/     5A3 : 02                  		ccl
     827/     5A4 : EC 90               		dai 	0x90
     828/     5A6 : EC 40               		dai 	0x40
     829/     5A8 : 3F                  		xppc 	p3 												; print
     830/     5A9 : C2 02               		ld 		2(p2) 											; read digit
     831/     5AB : D4 0F               		ani 	0x0F 											; convert LSB
     832/     5AD : 02                  		ccl
     833/     5AE : EC 90               		dai 	0x90
     834/     5B0 : EC 40               		dai 	0x40
     835/     5B2 : 3F                  		xppc 	p3 												; print
     836/     5B3 :                     
     837/     5B3 : C6 01               		ld 		@1(p2) 											; restore P3 & A and Return
     838/     5B5 : 33                  		xpal 	p3
     839/     5B6 : C6 01               		ld 		@1(p2)
     840/     5B8 : 37                  		xpah 	p3
     841/     5B9 : C6 01               		ld 		@1(p2)
     842/     5BB : 3F                  		xppc 	p3
     843/     5BC : 90 CD               		jmp 	PrintHexByte
     844/     5BE :                     
     845/     5BE :                     ; ****************************************************************************************************************
     846/     5BE :                     ; ****************************************************************************************************************
     847/     5BE :                     ;
     848/     5BE :                     ;		Print Character in A, preserves all registers, re-entrant. Handles 13 (New Line), 8 (Backspace)
     849/     5BE :                     ;		Characters 32 - 95 only.
     850/     5BE :                     ;	
     851/     5BE :                     ;		Rolls to screen top rather than scrolling.
     852/     5BE :                     ;
     853/     5BE :                     ; ****************************************************************************************************************
     854/     5BE :                     ; ****************************************************************************************************************
     855/     5BE :                     
     856/     5BE :                     PrintCharacter:
     857/     5BE : CE FF               		st 		@-1(p2) 										; save A
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 23 - 12/2/2015 13:45:23


     858/     5C0 : C4 0C               		ldi 	Cursor/256 										; save P1, setting up P1 -> Cursor at same time.
     859/     5C2 : 35                  		xpah 	p1
     860/     5C3 : CE FF               		st 		@-1(p2)
     861/     5C5 : C4 18               		ldi 	Cursor&255
     862/     5C7 : 31                  		xpal 	p1
     863/     5C8 : CE FF               		st 		@-1(p2)
     864/     5CA : C4 00               		ldi 	0 												; save P3, setting up P3 -> Page 0 (Video RAM Write)
     865/     5CC : 37                  		xpah 	p3
     866/     5CD : CE FF               		st 		@-1(p2)
     867/     5CF : 33                  		xpal 	p3
     868/     5D0 : CE FF               		st 		@-1(p2)
     869/     5D2 :                     
     870/     5D2 : C1 00               		ld 		(p1) 											; read cursor position
     871/     5D4 : 33                  		xpal 	p3 												; put in P3.Low
     872/     5D5 :                     
     873/     5D5 : C4 20               		ldi 	' ' 											; erase the cursor.
     874/     5D7 : CB 00               		st 		0(p3)
     875/     5D9 :                     
     876/     5D9 : C2 04               		ld 		4(p2) 											; read character to print.
     877/     5DB : E4 0D               		xri 	13 												; is it CR ?
     878/     5DD : 98 40               		jz 		__PCNewLine 									; if so, go to new line.
     879/     5DF : E4 05               		xri 	13!8 											; is it Backspace ?
     880/     5E1 : 98 30               		jz 		__PCBackSpace
     881/     5E3 :                     
     882/     5E3 : C2 04               		ld 		4(p2) 											; get character to print
     883/     5E5 : D4 3F               		ani 	0x3F 											; make 6 bit ASCII
     884/     5E7 : CF 01               		st 		@1(p3) 											; write into P3, e.g. the screen and bump it.
     885/     5E9 : A9 00               		ild 	(p1) 											; increment cursor position and load
     886/     5EB : D4 0F               		ani 	15 												; are we at line start ?
     887/     5ED : 9C 0C               		jnz 	__PCExit 										; if so, erase the current line.
     888/     5EF :                     
     889/     5EF :                     __PCBlankNewLine:
     890/     5EF : C4 10               		ldi 	16 												; count to 16, the number of spaces to write out.
     891/     5F1 : CA FF               		st 		-1(p2) 
     892/     5F3 :                     __PCBlankNewLineLoop:
     893/     5F3 : C4 20               		ldi 	' '
     894/     5F5 : CF 01               		st 		@1(p3)
     895/     5F7 : BA FF               		dld 	-1(p2)
     896/     5F9 : 9C F8               		jnz 	__PCBlankNewLineLoop
     897/     5FB :                     
     898/     5FB :                     __PCExit:
     899/     5FB : C1 00               		ld 		(p1) 											; read cursor
     900/     5FD : 33                  		xpal 	p3 												; put in P3.L
     901/     5FE : C4 9B               		ldi 	0x9B 											; shaded block cursor on screen
     902/     600 : CB 00               		st 		(p3)
     903/     602 : C6 01               		ld 		@1(p2)											; restore P3
     904/     604 : 33                  		xpal 	p3
     905/     605 : C6 01               		ld 		@1(p2)
     906/     607 : 37                  		xpah 	p3
     907/     608 : C6 01               		ld 		@1(p2)											; restore P1
     908/     60A : 31                  		xpal 	p1
     909/     60B : C6 01               		ld 		@1(p2)
     910/     60D : 35                  		xpah 	p1
     911/     60E : C6 01               		ld 		@1(p2) 											; restore A and Return.	
     912/     610 : 3F                  		xppc 	p3
     913/     611 : 90 AB               		jmp 	PrintCharacter 									; and it is re-entrant.
     914/     613 :                     
     915/     613 :                     __PCBackSpace:
     916/     613 : 33                  		xpal 	p3 												; get current cursor position
     917/     614 : 98 E5               		jz 		__PCExit 										; if top of screen then exit.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 24 - 12/2/2015 13:45:23


     918/     616 : B9 00               		dld 	(p1) 											; backspace and load cursor
     919/     618 : 33                  		xpal 	p3 												; put in P3
     920/     619 : C4 20               		ldi 	' '												; erase character there
     921/     61B : CB 00               		st 		(p3)
     922/     61D : 90 DC               		jmp 	__PCExit 										; and exit.
     923/     61F :                     
     924/     61F :                     __PCNewLine:
     925/     61F : C1 00               		ld 		(p1) 											; read cursor position
     926/     621 : D4 70               		ani 	0x70 											; line
     927/     623 : 02                  		ccl 													; next line
     928/     624 : F4 10               		adi 	0x10
     929/     626 : C9 00               		st 		(p1) 											; write back
     930/     628 : 33                  		xpal 	p3 												; put in P3.L
     931/     629 : 90 C4               		jmp 	__PCBlankNewLine
     932/     62B :                     
     933/     62B :                     ; ****************************************************************************************************************
     934/     62B :                     ; ****************************************************************************************************************
     935/     62B :                     ;
     936/     62B :                     ;					Print current address followed by A data bytes. Doesn't update current address
     937/     62B :                     ;
     938/     62B :                     ; ****************************************************************************************************************
     939/     62B :                     ; ****************************************************************************************************************
     940/     62B :                     
     941/     62B :                     PrintAddressData:
     942/     62B : CE FF               		st 		@-1(p2) 										; save count, we don't restore this.
     943/     62D : C4 05               		ldi 	(PrintHexByte-1)/256 							; save and set up P3
     944/     62F : 37                  		xpah 	p3
     945/     630 : CE FF               		st 		@-1(p2)
     946/     632 : C4 8A               		ldi 	(PrintHexByte-1)&255
     947/     634 : 33                  		xpal 	p3
     948/     635 : CE FF               		st 		@-1(p2)
     949/     637 : C4 0C               		ldi 	current / 256 									; point P1 to current address
     950/     639 : 35                  		xpah 	p1
     951/     63A : C4 19               		ldi 	current & 255
     952/     63C : 31                  		xpal 	p1
     953/     63D : C1 01               		ld 		1(p1) 											; read high byte of address
     954/     63F : 02                  		ccl
     955/     640 : 3F                  		xppc 	p3												; print w/o leading space
     956/     641 : C1 00               		ld 		0(p1)											; read low byte of address
     957/     643 : 02                  		ccl 	
     958/     644 : 3F                  		xppc 	p3 												; print w/o leading space.
     959/     645 : 01                  		xae 													; put in E
     960/     646 : C1 01               		ld 		1(p1) 											; high byte to P1.H
     961/     648 : 35                  		xpah 	p1
     962/     649 : 40                  		lde 													; low byte to P1.H
     963/     64A : 31                  		xpal 	p1
     964/     64B :                     _PADLoop:
     965/     64B : BA 02               		dld 	2(p2) 											; decrement counter
     966/     64D : 94 09               		jp 		_PADPrint 										; if +ve print another byte
     967/     64F :                     
     968/     64F : C6 01               		ld 		@1(p2) 											; restore P3, skipping A hence @2
     969/     651 : 33                  		xpal 	p3
     970/     652 : C6 02               		ld 		@2(p2)
     971/     654 : 37                  		xpah 	p3
     972/     655 : 3F                  		xppc 	p3
     973/     656 : 90 D3               		jmp 	PrintAddressData
     974/     658 :                     
     975/     658 :                     _PADPrint:
     976/     658 : C5 01               		ld 		@1(p1) 											; read byte advance pointer
     977/     65A : 03                  		scl
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 25 - 12/2/2015 13:45:23


     978/     65B : 3F                  		xppc 	p3 												; print with space.
     979/     65C : 90 ED               		jmp 	_PADLoop
     980/     65E :                     
     981/     65E :                     ; ****************************************************************************************************************
     982/     65E :                     ;
     983/     65E :                     ;		Look at the parameter string for a parameter, processing @ and Pn as you go, CS if parameter found
     984/     65E :                     ; 		CC otherwise. Return parameter value in P1. Falls through
     985/     65E :                     ;
     986/     65E :                     ; ****************************************************************************************************************
     987/     65E :                     
     988/     65E :                     GetParameter:
     989/     65E : C4 0C               		ldi 	parPosn/256 									; current position into P1
     990/     660 : 35                  		xpah 	p1
     991/     661 : C4 1C               		ldi 	parPosn&255 					
     992/     663 : 31                  		xpal 	p1
     993/     664 : C4 00               		ldi 	0 												; -1(p2) is the low byte result
     994/     666 : CA FF               		st 		-1(p2) 											; -2(p2) is the high byte result
     995/     668 : CA FE               		st 		-2(p2)
     996/     66A :                     
     997/     66A : C1 00               		ld 		(p1) 											; read the current position,P1 points to character
     998/     66C : 31                  		xpal 	p1 												; when we put it in P1.L
     999/     66D :                     
    1000/     66D :                     __GPASkip:														; skip over spaces to first alphanumeric.
    1001/     66D : C1 00               		ld 		(p1) 											; read character
    1002/     66F : 98 7B               		jz 		__GPAExitFail 									; if zero, then end of the input string.
    1003/     671 : C5 01               		ld 		@1(p1) 											; read it, advancing.
    1004/     673 : E4 20               		xri 	32 												; is it space ?
    1005/     675 : 98 F6               		jz 		__GPASkip 
    1006/     677 : E4 60               		xri 	32!'@'											; is it @ ?
    1007/     679 : 98 5E               		jz 		__GPAAtModifier 
    1008/     67B : E4 10               		xri 	'@'!'P' 										; is it P ?
    1009/     67D : 98 4C               		jz 		__GPAPointerModifier
    1010/     67F :                     
    1011/     67F :                     __GPANextCharacter:
    1012/     67F : C1 FF               		ld 		-1(p1) 											; get value back after post increment.
    1013/     681 : 02                  		ccl
    1014/     682 : F4 50               		adi 	128-48 											; this will be +ve if A < '0'
    1015/     684 : 94 66               		jp 		__GPAExitFail
    1016/     686 : FC 09               		cai 	9 												; will be +ve if A < '9', CY/L was clear.	
    1017/     688 : 94 0A               		jp 		__GPAFoundHex
    1018/     68A : FC 07               		cai 	7 												; will be +ve if A < 'A', CY/L was set
    1019/     68C : 94 5E               		jp 		__GPAExitFail
    1020/     68E : F4 79               		adi 	0xFF-0x85-1 									; will be +ve if A > 'F', CY/L was set.
    1021/     690 : 94 5A               		jp 		__GPAExitFail 					
    1022/     692 : F4 76               		adi 	(0x70-0xFA) & 0xFF 								; make the range as below, CY/L was clear
    1023/     694 :                     __GPAFoundHex: 													; enter here 0-9 = $76..$7F, A-F = $70..$75
    1024/     694 : 02                  		ccl  													; convert that to a hex nibble.
    1025/     695 : F4 0A               		adi 	10
    1026/     697 : D4 0F               		ani 	0xF
    1027/     699 : 01                  		xae 													; save in E, temporarily
    1028/     69A : C4 04               		ldi 	4 												; now shift the result 4 bits to the left.
    1029/     69C : CA FD               		st 		-3(p2) 											; -3(p2) is the counter
    1030/     69E :                     __GPAShift:
    1031/     69E : 02                  		ccl
    1032/     69F : C2 FF               		ld 		-1(p2) 											; shift 16 bit result 1 bit to the left.
    1033/     6A1 : F2 FF               		add 	-1(p2)
    1034/     6A3 : CA FF               		st 		-1(p2)
    1035/     6A5 : C2 FE               		ld 		-2(p2)
    1036/     6A7 : F2 FE               		add 	-2(p2)
    1037/     6A9 : CA FE               		st 		-2(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 26 - 12/2/2015 13:45:23


    1038/     6AB : BA FD               		dld 	-3(p2) 											; do it four times
    1039/     6AD : 9C EF               		jnz 	__GPAShift 	
    1040/     6AF : C2 FF               		ld 		-1(p2) 											; Or E into the LSB
    1041/     6B1 : 58                  		ore
    1042/     6B2 : CA FF               		st 		-1(p2)
    1043/     6B4 :                     
    1044/     6B4 : C5 01               		ld 		@1(p1) 											; look at next character, post incrementing.
    1045/     6B6 : 03                  		scl
    1046/     6B7 : FC 22               		cai 	34 												; if it is after space and ! (label marker)
    1047/     6B9 : 94 C4               		jp 		__GPANextCharacter 								; go back and put it in place.
    1048/     6BB :                     
    1049/     6BB : C5 FF               		ld 		@-1(p1) 										; undo the increment, incase we've just read zero.
    1050/     6BD :                     
    1051/     6BD : C4 1C               		ldi 	parPosn & 255 									; put the parPosn address in P1.L, new posn into A
    1052/     6BF : 31                  		xpal 	p1
    1053/     6C0 : C9 00               		st 		(p1) 											; and write it back
    1054/     6C2 : C2 FF               		ld 		-1(p2) 											; put the result into P1
    1055/     6C4 : 31                  		xpal 	p1
    1056/     6C5 : C2 FE               		ld 		-2(p2)
    1057/     6C7 : 35                  		xpah 	p1
    1058/     6C8 : 03                  		scl 													; set CY/L to indicate okay
    1059/     6C9 : 90 22               		jmp 	__GPAExit
    1060/     6CB :                     
    1061/     6CB :                     __GPAPointerModifier:
    1062/     6CB : C1 00               		ld 		(p1) 											; read P<something> ?
    1063/     6CD : D4 FC               		ani 	0xFC 											; is it '0' .. '3'?
    1064/     6CF : E4 30               		xri 	'0'
    1065/     6D1 : 9C 19               		jnz 	__GPAExitFail 									; it didn't work, not 0..3
    1066/     6D3 : C5 01               		ld 		@1(p1) 											; re-read it and advance
    1067/     6D5 : D4 03               		ani 	3												; lower 2 bits only
    1068/     6D7 : 90 02               		jmp 	__GPAAdjustModifier
    1069/     6D9 :                     __GPAAtModifier:
    1070/     6D9 : C4 04               		ldi 	4 												; set modifier adjustment to +4
    1071/     6DB :                     __GPAAdjustModifier:
    1072/     6DB : CA FD               		st 		-3(p2) 
    1073/     6DD : C4 1D               		ldi 	modifier & 255 									; point P1 to modifier, save current address in E
    1074/     6DF : 31                  		xpal 	p1
    1075/     6E0 : 01                  		xae 
    1076/     6E1 : C1 00               		ld 		(p1) 											; read modifier
    1077/     6E3 : 02                  		ccl
    1078/     6E4 : F2 FD               		add 	-3(p2) 											; add the modifying value to it.
    1079/     6E6 : C9 00               		st 		(p1) 											; write modifier.
    1080/     6E8 : 40                  		lde 													; restore current address to P1.L
    1081/     6E9 : 31                  		xpal 	p1
    1082/     6EA : 90 81               		jmp 	__GPASkip 										; go back to skip over.
    1083/     6EC :                     
    1084/     6EC :                     __GPAExitFail:
    1085/     6EC : 02                  		ccl 													; carry clear, e.g. nothing read in / error.
    1086/     6ED :                     __GPAExit:
    1087/     6ED : 3F                  		xppc 	p3
    1088/     6EE :                     
    1089/     6EE :                     ; ****************************************************************************************************************
    1090/     6EE :                     ;
    1091/     6EE :                     ;		Store parameter value in P1 in the current address, if CS. Falls through.
    1092/     6EE :                     ;
    1093/     6EE :                     ; ****************************************************************************************************************
    1094/     6EE :                     
    1095/     6EE :                     UpdateCurrentAddress:
    1096/     6EE : 06                  		csa 													; get status reg
    1097/     6EF : 94 0C               		jp 		__UCAExit 										; if carry flag clear then exit.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 27 - 12/2/2015 13:45:23


    1098/     6F1 :                     
    1099/     6F1 : C4 19               		ldi 	current & 255 									; current address to P1.L, acquired address to E
    1100/     6F3 : 31                  		xpal 	p1
    1101/     6F4 : 01                  		xae
    1102/     6F5 : C4 0C               		ldi 	current / 256 									; current address to P1.H, acquired to A
    1103/     6F7 : 35                  		xpah 	p1
    1104/     6F8 : C9 01               		st 		1(p1) 											; store address back
    1105/     6FA : 40                  		lde
    1106/     6FB : C9 00               		st 		0(p1)
    1107/     6FD :                     __UCAExit:
    1108/     6FD : 3F                  		xppc 	p3
    1109/     6FE :                     
    1110/     6FE :                     ; ****************************************************************************************************************
    1111/     6FE :                     ;
    1112/     6FE :                     ;		Get current address into P1.
    1113/     6FE :                     ;
    1114/     6FE :                     ; ****************************************************************************************************************
    1115/     6FE :                     
    1116/     6FE :                     GetCurrentAddress:
    1117/     6FE : C4 0C               		ldi 	current/256 									; current address ptr in P1
    1118/     700 : 35                  		xpah 	p1
    1119/     701 : C4 19               		ldi 	current&255
    1120/     703 : 31                  		xpal 	p1
    1121/     704 : C1 00               		ld 		0(p1) 											; low byte to E
    1122/     706 : 01                  		xae
    1123/     707 : C1 01               		ld 		1(p1) 											; high byte to A
    1124/     709 : 35                  		xpah 	p1 												; then to P1.H
    1125/     70A : 40                  		lde 													; low byte to P1.L
    1126/     70B : 31                  		xpal 	p1 
    1127/     70C : 3F                  		xppc 	p3
    1128/     70D :                     
    1129/     70D : 53 43 2F 4D 50 20   		db 		"SC/MP Monitor by Paul Robson paul@robsons.org.uk Jan 2016."
                    4D 6F 6E 69 74 6F 
                    72 20 62 79 20 50 
                    61 75 6C 20 52 6F 
                    62 73 6F 6E 20 70 
                    61 75 6C 40 72 6F 
                    62 73 6F 6E 73 2E 
                    6F 72 67 2E 75 6B 
                    20 4A 61 6E 20 32 
                    30 31 36 2E 
    1130/     747 :                     
    1131/     747 :                     ; ****************************************************************************************************************
    1132/     747 :                     ;
    1133/     747 :                     ;											List of commands and Jump Table
    1134/     747 :                     ;
    1135/     747 :                     ; ****************************************************************************************************************
    1136/     747 :                     
    1137/     747 :                     		include commands.inc 									; must be at the end, so the command table is in
(1)    1/     747 :                             org 0x0747
(1)    2/     747 :                     ;
(1)    3/     747 :                     ; 	This file is generated automatically by gencommands.py
(1)    4/     747 :                     ;
(1)    5/     747 :                     __CommandList:
(1)    6/     747 : 94 21                       dw    0x2194 ; HLT
(1)    7/     749 : 00                          db    0x00
(1)    8/     74A : 25 60                       dw    0x6025 ; XAE
(1)    9/     74C : 01                          db    0x01
(1)   10/     74D : 6C 0C                       dw    0x0c6c ; CCL
(1)   11/     74F : 02                          db    0x02
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 28 - 12/2/2015 13:45:23


(1)   12/     750 : 6C 4C                       dw    0x4c6c ; SCL
(1)   13/     752 : 03                          db    0x03
(1)   14/     753 : 2E 11                       dw    0x112e ; DIN
(1)   15/     755 : 04                          db    0x04
(1)   16/     756 : AE 24                       dw    0x24ae ; IEN
(1)   17/     758 : 05                          db    0x05
(1)   18/     759 : 61 0E                       dw    0x0e61 ; CSA
(1)   19/     75B : 06                          db    0x06
(1)   20/     75C : 33 0C                       dw    0x0c33 ; CAS
(1)   21/     75E : 07                          db    0x07
(1)   22/     75F : F0 39                       dw    0x39f0 ; NOP
(1)   23/     761 : 08                          db    0x08
(1)   24/     762 : 2F 4D                       dw    0x4d2f ; SIO
(1)   25/     764 : 19                          db    0x19
(1)   26/     765 : 72 02                       dw    0x0272 ; SR
(1)   27/     767 : 1C                          db    0x1c
(1)   28/     768 : 4C 4E                       dw    0x4e4c ; SRL
(1)   29/     76A : 1D                          db    0x1d
(1)   30/     76B : 52 02                       dw    0x0252 ; RR
(1)   31/     76D : 1E                          db    0x1e
(1)   32/     76E : 4C 4A                       dw    0x4a4c ; RRL
(1)   33/     770 : 1F                          db    0x1f
(1)   34/     771 : 0D 00                       dw    0x000d ; M
(1)   35/     773 : 20                          db    0x20
(1)   36/     774 : 01 00                       dw    0x0001 ; A
(1)   37/     776 : 21                          db    0x21
(1)   38/     777 : 07 00                       dw    0x0007 ; G
(1)   39/     779 : 22                          db    0x22
(1)   40/     77A : B4 42                       dw    0x42b4 ; PUT
(1)   41/     77C : 23                          db    0x23
(1)   42/     77D : B4 1C                       dw    0x1cb4 ; GET
(1)   43/     77F : 24                          db    0x24
(1)   44/     780 : 03 00                       dw    0x0003 ; C
(1)   45/     782 : 25                          db    0x25
(1)   46/     783 : 02 00                       dw    0x0002 ; B
(1)   47/     785 : 26                          db    0x26
(1)   48/     786 : 0C 00                       dw    0x000c ; L
(1)   49/     788 : 27                          db    0x27
(1)   50/     789 : 04 00                       dw    0x0004 ; D
(1)   51/     78B : 28                          db    0x28
(1)   52/     78C : 0C 62                       dw    0x620c ; XPL
(1)   53/     78E : 30                          db    0x30
(1)   54/     78F : 08 62                       dw    0x6208 ; XPH
(1)   55/     791 : 34                          db    0x34
(1)   56/     792 : 03 62                       dw    0x6203 ; XPC
(1)   57/     794 : 3C                          db    0x3c
(1)   58/     795 : 85 30                       dw    0x3085 ; LDE
(1)   59/     797 : 40                          db    0x40
(1)   60/     798 : C5 05                       dw    0x05c5 ; ANE
(1)   61/     79A : 50                          db    0x50
(1)   62/     79B : 45 3E                       dw    0x3e45 ; ORE
(1)   63/     79D : 58                          db    0x58
(1)   64/     79E : 45 62                       dw    0x6245 ; XRE
(1)   65/     7A0 : 60                          db    0x60
(1)   66/     7A1 : 25 10                       dw    0x1025 ; DAE
(1)   67/     7A3 : 68                          db    0x68
(1)   68/     7A4 : 85 04                       dw    0x0485 ; ADE
(1)   69/     7A6 : 70                          db    0x70
(1)   70/     7A7 : 25 0C                       dw    0x0c25 ; CAE
(1)   71/     7A9 : 78                          db    0x78
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 29 - 12/2/2015 13:45:23


(1)   72/     7AA : 99 11                       dw    0x1199 ; DLY
(1)   73/     7AC : 8F                          db    0x8f
(1)   74/     7AD : B0 29                       dw    0x29b0 ; JMP
(1)   75/     7AF : 90                          db    0x90
(1)   76/     7B0 : 50 01                       dw    0x0150 ; JP
(1)   77/     7B2 : 94                          db    0x94
(1)   78/     7B3 : 5A 01                       dw    0x015a ; JZ
(1)   79/     7B5 : 98                          db    0x98
(1)   80/     7B6 : DA 29                       dw    0x29da ; JNZ
(1)   81/     7B8 : 9C                          db    0x9c
(1)   82/     7B9 : 84 25                       dw    0x2584 ; ILD
(1)   83/     7BB : A8                          db    0xa8
(1)   84/     7BC : 84 11                       dw    0x1184 ; DLD
(1)   85/     7BE : B8                          db    0xb8
(1)   86/     7BF : 84 01                       dw    0x0184 ; LD
(1)   87/     7C1 : C0                          db    0xc0
(1)   88/     7C2 : 89 30                       dw    0x3089 ; LDI
(1)   89/     7C4 : C4                          db    0xc4
(1)   90/     7C5 : 74 02                       dw    0x0274 ; ST
(1)   91/     7C7 : C8                          db    0xc8
(1)   92/     7C8 : C4 05                       dw    0x05c4 ; AND
(1)   93/     7CA : D0                          db    0xd0
(1)   94/     7CB : C9 05                       dw    0x05c9 ; ANI
(1)   95/     7CD : D4                          db    0xd4
(1)   96/     7CE : F2 01                       dw    0x01f2 ; OR
(1)   97/     7D0 : D8                          db    0xd8
(1)   98/     7D1 : 49 3E                       dw    0x3e49 ; ORI
(1)   99/     7D3 : DC                          db    0xdc
(1)  100/     7D4 : F2 61                       dw    0x61f2 ; XOR
(1)  101/     7D6 : E0                          db    0xe0
(1)  102/     7D7 : 49 62                       dw    0x6249 ; XRI
(1)  103/     7D9 : E4                          db    0xe4
(1)  104/     7DA : 24 10                       dw    0x1024 ; DAD
(1)  105/     7DC : E8                          db    0xe8
(1)  106/     7DD : 29 10                       dw    0x1029 ; DAI
(1)  107/     7DF : EC                          db    0xec
(1)  108/     7E0 : 84 04                       dw    0x0484 ; ADD
(1)  109/     7E2 : F0                          db    0xf0
(1)  110/     7E3 : 89 04                       dw    0x0489 ; ADI
(1)  111/     7E5 : F4                          db    0xf4
(1)  112/     7E6 : 24 0C                       dw    0x0c24 ; CAD
(1)  113/     7E8 : F8                          db    0xf8
(1)  114/     7E9 : 29 0C                       dw    0x0c29 ; CAI
(1)  115/     7EB : FC                          db    0xfc
(1)  116/     7EC :                     __CommandListEnd:
(1)  117/     7EC : 00 00                       dw    0x0000 ; End Marker	
(1)  118/     7EE :                     
(1)  119/     7EE :                     __CommandTable:
(1)  120/     7EE : 72 04                       dw    MemoryDump_Command
(1)  121/     7F0 : BB 03                       dw    Address_Command
(1)  122/     7F2 : CE 03                       dw    Go_Command
(1)  123/     7F4 : DB 03                       dw    PutTape_Command
(1)  124/     7F6 : 2C 04                       dw    LoadTape_Command
(1)  125/     7F8 : 07 02                       dw    ClearScreen_Command
(1)  126/     7FA : 9C 04                       dw    EnterBytes_Command
(1)  127/     7FC : 54 04                       dw    Label_Command
(1)  128/     7FE : BE 04                       dw    Disassemble_Command
(1)  129/     800 :                     
    1138/     800 :                     																; the same page.
    1139/     800 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 30 - 12/2/2015 13:45:23


    1140/     800 :                     ; ****************************************************************************************************************
    1141/     800 :                     ;
    1142/     800 :                     ;													Tape Format. 
    1143/     800 :                     ;
    1144/     800 :                     ; ****************************************************************************************************************
    1145/     800 :                     ;
    1146/     800 :                     ;		1 x start bit 		'1' value is held for period of time.
    1147/     800 :                     ;		8 x data bits  		'0 or 1' value is held for a period of time.
    1148/     800 :                     ;		1 x continuation	'0' if another bit follows, '1' if end.
    1149/     800 :                     ;		at least 2 bit times between bytes.
    1150/     800 :                     ;
    1151/     800 :                     ;		Use DLY 4 with A = 0 (DLY 6 to skip half-start)
    1152/     800 :                     ; 		= 13 + 2 * 0 + 514 * 4 microcycles
    1153/     800 :                     ;		= 2,069 microcycles
    1154/     800 :                     ;	
    1155/     800 :                     ;		which is about 240 bits per second.
    1156/     800 :                     ;
    1157/     800 :                     ; ****************************************************************************************************************
    1158/     800 :                     ;
    1159/     800 :                     ;												Monitor Commands
    1160/     800 :                     ;
    1161/     800 :                     ; ****************************************************************************************************************
    1162/     800 :                     ;
    1163/     800 :                     ;		A [aaaa] 			Set current address to aaaa
    1164/     800 :                     ;		B [cc] [dd] [ee]..	Fill memory from current address
    1165/     800 :                     ; 		C 					Clear screen
    1166/     800 :                     ;		D [aaaa] 			Disassemble from aaaa
    1167/     800 :                     ;		G aaaa 				Run from address - address must be given - return with XPPC P3
    1168/     800 :                     ; 		L n 				Set label n to the current address (up to 32 labels 00-1F)
    1169/     800 :                     ; 		M [aaaa] 			Memory dump from current address/aaaa (6 lines, 4 bytes per line)
    1170/     800 :                     ; 		GET [aaaa] 			Load tape to current address/aaa
    1171/     800 :                     ;		PUT [nnnn]			Write nnnn bytes from current address onwards to tape.
    1172/     800 :                     ;
    1173/     800 :                     ;		Command Line Assembler
    1174/     800 :                     ;
    1175/     800 :                     ;		Standard SC/MP mnemonics, except for XPAH, XPAL, XPPC, HALT and DINT which are XPH XPL XPC HLT DIN
    1176/     800 :                     ;		respectively (4 character mnemonics not supported)
    1177/     800 :                     ;
    1178/     800 :                     ;		Address modes are written as such:
    1179/     800 :                     ;
    1180/     800 :                     ;		Direct:			LD 	address 					(offset auto calculated, also for jump)
    1181/     800 :                     ;		Indexed:		LD  P1 7 						(normally ld 7(p1))
    1182/     800 :                     ;		Immediate:		DLY 42 					
    1183/     800 :                     ;		AutoIndexed:	LD @P1 4 						(normally ld @4(p1))
    1184/     800 :                     ;
    1185/     800 :                     ;		Labels are accessed via the pling, so to jump to label 4 rather than address 4 you write
    1186/     800 :                     ;
    1187/     800 :                     ;		JMP 4!
    1188/     800 :                     ;
    1189/     800 :                     ;		Documentation of the Mathematics functions are in the included file maths.asm
    1190/     800 :                     ;
    1191/     800 :                     ; ****************************************************************************************************************
    1192/     800 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 31 - 12/2/2015 13:45:23


  symbol table (* = unused):
  ------------------------

 ADDRESS_COMMAND :              3BB C |  AHI [SCMPMULTIPLY] :             3 - |
 ALO [SCMPMULTIPLY] :             2 - | *ARCHITECTURE :  i386-unknown-win32 - |
 BHI [SCMPMULTIPLY] :             1 - | *BIGENDIAN :                      0 - |
 BITHI [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFFF - |
 BITLO [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFFE - |
 BLO [SCMPMULTIPLY] :             0 - |  BOOTMONITOR :                  1ED C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CLEARSCREENLOOP :              20C C |  CLEARSCREEN_COMMAND :          207 C |
 CODESTART :                    C30 - |  COMMANDMAINLOOP :              26A C |
*CONSTPI :        3.141592653589793 - |  CURRENT :                      C19 - |
 CURSOR :                       C18 - | *DATE :                   12/2/2015 - |
 DENOMINATORHI [SCMPDIVIDE] :     1 - |  DENOMINATORLO [SCMPDIVIDE] :     0 - |
 DIGITCOUNT [SCMPTOINTEGER] :                              FFFFFFFFFFFFFFFF - |
 DISASSEMBLE_COMMAND :          4BE C |  ENTERBYTES_COMMAND :           49C C |
 ETEMP [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFF8 - |
 EXTRACT5BIT :                  2D5 C | *FALSE :                          0 - |
 FINDTOPMEMORY :                1FF C | *FULLPMMU :                       1 - |
*GETCURRENTADDRESS :            6FE C |  GETPARAMETER :                 65E C |
 GOBOOT :                         5 C |  GO_COMMAND :                   3CE C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - |  ISINIT :                       C1B - |
 KBDBUFFER :                    C20 - |  KBDBUFFERLN :                   10 - |
 KEYBOARDLOOP :                 27F C |  LABELCOUNT :                    18 - |
 LABELS :                       C00 - |  LABEL_COMMAND :                454 C |
*LISTON :                         1 - |  LOADTAPE_COMMAND :             42C C |
*MACEXP :                         1 - |  MATHS :                         43 C |
 MATH_ADD :                      5F C |  MATH_DIVIDE :                  12C C |
 MATH_DIVIDE2 :                  C7 C | *MATH_ERROR :                    5B C |
 MATH_EXIT :                     5C C |  MATH_EXIT1 :                    C5 C |
 MATH_EXIT3 :                   12A C |  MATH_MULTIPLY :                 81 C |
 MATH_RANDOM :                    C C |  MATH_SUBTRACT :                 6F C |
 MATH_TOINTEGER :                C9 C |  MEMORYDUMP_COMMAND :           472 C |
 MESSAGE :                      24B C |  MESSAGELOOP :                  244 C |
 MODIFIER :                     C1D - | *MOMCPU :                         C - |
*MOMCPUNAME :                 SC/MP - | *NESTMAX :                      100 - |
 NUMERATORHI [SCMPDIVIDE] :       3 - |  NUMERATORLO [SCMPDIVIDE] :       2 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PARPOSN :                      C1C - |  PRINTADDRESSDATA :             62B C |
 PRINTCHARACTER :               5BE C |  PRINTHEXBYTE :                 58B C |
 PUTTAPE_COMMAND :              3DB C |
 QUOTIENTHI [SCMPDIVIDE] :                                 FFFFFFFFFFFFFFFD - |
 QUOTIENTLO [SCMPDIVIDE] :                                 FFFFFFFFFFFFFFFC - |
 RANDOM :                       C1E - | *RELAXED :                        0 - |
 REMAINDERHI [SCMPDIVIDE] :                                FFFFFFFFFFFFFFFB - |
 REMAINDERLO [SCMPDIVIDE] :                                FFFFFFFFFFFFFFFA - |
 RESULTHI [SCMPMULTIPLY] :                                 FFFFFFFFFFFFFFFF - |
 RESULTHI [SCMPTOINTEGER] :                                FFFFFFFFFFFFFFFE - |
 RESULTLO [SCMPMULTIPLY] :                                 FFFFFFFFFFFFFFFE - |
 RESULTLO [SCMPTOINTEGER] :                                FFFFFFFFFFFFFFFD - |
 SHIFTCOUNT [SCMPTOINTEGER] :                              FFFFFFFFFFFFFFFC - |
 SIGNCOUNT [SCMPDIVIDE] :                                  FFFFFFFFFFFFFFF9 - |
 TAPEDELAY :                      4 - |
 TEMPHI [SCMPTOINTEGER] :                                  FFFFFFFFFFFFFFFB - |
 TEMPLO [SCMPTOINTEGER] :                                  FFFFFFFFFFFFFFFA - |
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 32 - 12/2/2015 13:45:23


*TIME :                    13:45:23 - |  TOINT_END [SCMPTOINTEGER] :    11C C |
 TOINT_LOOP [SCMPTOINTEGER] :    D1 C |  TOINT_NOADD [SCMPTOINTEGER] :  108 C |
 TOINT_SHIFT [SCMPTOINTEGER] :   EA C | *TRUE :                           1 - |
*UPDATECURRENTADDRESS :         6EE C |  VARBASE :                      C18 - |
*VERSION :                     142F - |  _KBDWAITKEY :                  288 C |
 _KBDWAITRELEASE :              282 C |  _PADLOOP :                     64B C |
 _PADPRINT :                    658 C |  _PUTTAPEBIT :                  40B C |
 _PUTTAPEBYTE :                 3F6 C |  _PUTTAPELEADER :               3F0 C |
 __ASMCONTINUE :                379 C |  __ASMEXIT :                    3B1 C |
 __ASMNOPARAMETER :             371 C |  __ASSEMBLER :                  342 C |
 __BOOTMONITOR :                1F7 C |  __CMDMAINLOOP1 :               2C6 C |
 __CMDMAINLOOP2 :               3C7 C |  __CMDMAINLOOP3 :               3D9 C |
 __CMDMAINLOOP4 :               428 C |  __CMDMAINLOOP5 :               452 C |
 __CMDMAINLOOP6 :               49A C |  __CMDMAINLOOP7 :               506 C |
 __CMDPARAMETERFAIL :           3BF C |  __CMDPARAMETERFAIL1 :          42A C |
 __COMMANDERROR :               338 C |  __COMMANDLIST :                747 C |
 __COMMANDLISTEND :             7EC C |  __COMMANDTABLE :               7EE C |
 __DASSFINDOPCODE :             4ED C |  __DASSFOUNDOPCODE :            508 C |
 __DASSLOOP :                   4C4 C |  __DASSLOOP2 :                  504 C |
 __DASSNEXT :                   562 C |  __DASSNEXTOPCODE :             500 C |
 __DASSNOOPERAND :              4E3 C |  __DASSNOTAUTOINDEXED :         57F C |
 __DASSNOTIMMEDIATE :           514 C |  __DASSPRINTMNEMONIC :          529 C |
 __DASSPRINTMODIFIER :          573 C |  __DASSPRINTOPERAND :           554 C |
 __DASSSHIFTENCODE :            539 C |  __DASSSKIPSPACE :              535 C |
 __DCLOOP :                     478 C |
 __DIVIDECOMPLETE [SCMPDIVIDE] : 1C2 C |
 __DIVIDECONTINUE [SCMPDIVIDE] : 195 C |
 __DIVIDEEXIT [SCMPDIVIDE] :    1AF C |  __DIVIDELOOP [SCMPDIVIDE] :    16C C |
 __DIVIDENOINCREMAINDER [SCMPDIVIDE] :                                  189 C |
 __DIVIDENOTSIGNED [SCMPDIVIDE] :                                       162 C |
 __DIVIDEREMAINDERGREATER [SCMPDIVIDE] :                                1DA C |
 __DIVIDEUNSIGNLOOP [SCMPDIVIDE] :                                      14A C |
 __EX5SHIFT :                   2E0 C |  __EXTRACTEND :                 2F6 C |
 __FINDCOMMANDLOOP :            301 C |  __GETTAPEBITS :                442 C |
 __GETTAPEWAIT :                432 C |  __GPAADJUSTMODIFIER :          6DB C |
 __GPAATMODIFIER :              6D9 C |  __GPAEXIT :                    6ED C |
 __GPAEXITFAIL :                6EC C |  __GPAFOUNDHEX :                694 C |
 __GPANEXTCHARACTER :           67F C |  __GPAPOINTERMODIFIER :         6CB C |
 __GPASHIFT :                   69E C |  __GPASKIP :                    66D C |
 __KBDBACKSPACE :               2BA C |  __KBDEXIT :                    2C8 C |
 __KBDNOTLOWER :                2AE C |  __MARANDOMNOXOR :               32 C |
 __MATH_EXIT2 [SCMPDIVIDE] :    16A C |  __MULTIPLYEXIT [SCMPMULTIPLY] : BA C |
 __MULTIPLYLOOP [SCMPMULTIPLY] : 87 C |
 __MULTIPLYNOADD [SCMPMULTIPLY] : A0 C |
 __PCBACKSPACE :                613 C |  __PCBLANKNEWLINE :             5EF C |
 __PCBLANKNEWLINELOOP :         5F3 C |  __PCEXIT :                     5FB C |
 __PCNEWLINE :                  61F C |  __PHBNOSPACE :                 59D C |
 __UCAEXIT :                    6FD C |

    182 symbols
     31 unused symbols

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 33 - 12/2/2015 13:45:23


  defined macros:
  ---------------

SHIFTLEFT                             | SHIFTRIGHT                           

      2 macros

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 34 - 12/2/2015 13:45:23


  codepages:
  ----------

STANDARD (0 changed characters)


0.02 seconds assembly time

   1738 lines source file
   1780 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
