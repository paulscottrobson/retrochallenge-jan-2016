 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 1 - 12/4/2015 10:28:39


       1/       0 :                     ; ******************************************************************************************************************
       2/       0 :                     ; ******************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;												Machine Language Monitor
       5/       0 :                     ;
       6/       0 :                     ; ******************************************************************************************************************
       7/       0 :                     ; ******************************************************************************************************************
       8/       0 :                     
       9/       0 :                     		cpu	sc/mp
      10/       0 :                     
      11/       0 : =0xC00              labels 		= 0xC00												; labels, 1 byte each
      12/       0 : =0x18               labelCount 	= 24 												; number of labels.
      13/       0 :                     
      14/       0 : =0xC18              varBase 	= labels+labelCount 								; variables after labels start here.
      15/       0 :                     
      16/       0 : =0xC18              cursor 		= varBase 											; cursor position ($00-$7F)
      17/       0 : =0xC19              current 	= varBase+1 										; current address (lo,hi)
      18/       0 : =0xC1B              isInit      = varBase+3 										; if already initialised, this is $A7.
      19/       0 : =0xC1C              parPosn		= varBase+4 										; current param offset in buffer (low addr)
      20/       0 : =0xC1D              modifier  	= varBase+5 										; instruction modifier (@,Pn) when assembling.
      21/       0 : =0xC1E              kbdBuffer 	= varBase+6 										; 16 character keyboard buffer
      22/       0 : =0x10               kbdBufferLn = 16 										
      23/       0 :                     
      24/       0 : =0xC2E              codeStart 	= kbdBuffer+kbdBufferLn								; user code starts here after the keyboard buffer.
      25/       0 :                     														
      26/       0 : =0x4                tapeDelay 	= 4 												; DLY parameter for 1 tape bit width.
      27/       0 :                     																; (smaller = faster tape I/O - see file end.)
      28/       0 :                     
      29/       0 :                     		org 	0x0000
      30/       0 : 08                  		nop 													; mandatory pre-increment NOP
      31/       1 :                     
      32/       1 :                     		include maths.asm 										; import the maths routines, accessed via $0003
(1)    1/       1 :                     ; ******************************************************************************************************************
(1)    2/       1 :                     ; ******************************************************************************************************************
(1)    3/       1 :                     ;
(1)    4/       1 :                     ;										16 bit Arithmetic routines
(1)    5/       1 :                     ;
(1)    6/       1 :                     ; ******************************************************************************************************************
(1)    7/       1 :                     ; ******************************************************************************************************************
(1)    8/       1 :                     
(1)    9/       1 : 90 02               	jmp	 	GoBoot 												; this will be at location 1.
(1)   10/       3 : 90 43               	jmp 	Maths 												; maths routine, at location 3.
(1)   11/       5 :                     
(1)   12/       5 :                     	; any other routines you care to call.
(1)   13/       5 :                     
(1)   14/       5 :                     GoBoot:
(1)   15/       5 : C4 05               	ldi 	(BootMonitor-1) & 255 								; jump to Boot Monitor
(1)   16/       7 : 33                  	xpal 	p3
(1)   17/       8 : C4 02               	ldi 	(BootMonitor-1) / 256
(1)   18/       A : 37                  	xpah 	p3
(1)   19/       B : 3F                  	xppc 	p3
(1)   20/       C :                     
(1)   21/       C :                     ; ******************************************************************************************************************
(1)   22/       C :                     ;											16 Bit shift left/right macros
(1)   23/       C :                     ; ******************************************************************************************************************
(1)   24/       C :                     
(1)   25/       C :                     shiftLeft macro val
(1)   26/       C :                     	ccl 													
(1)   27/       C :                     	ld 		val(p2)
(1)   28/       C :                     	add 	val(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 2 - 12/4/2015 10:28:39


(1)   29/       C :                     	st 		val(p2)
(1)   30/       C :                     	ld 		val+1(p2)
(1)   31/       C :                     	add 	val+1(p2)
(1)   32/       C :                     	st 		val+1(p2)		
(1)   33/       C :                     	endm
(1)   34/       C :                     
(1)   35/       C :                     shiftRight macro val
(1)   36/       C :                     	ccl
(1)   37/       C :                     	ld 		val+1(p2)
(1)   38/       C :                     	rrl 
(1)   39/       C :                     	st 		val+1(p2)
(1)   40/       C :                     	ld 		val(p2)
(1)   41/       C :                     	rrl 
(1)   42/       C :                     	st 		val(p2)
(1)   43/       C :                     	endm
(1)   44/       C :                     
(1)   45/       C :                     ; ******************************************************************************************************************
(1)   46/       C :                     ;										$ (Integer -> ASCII, p1 backwards)
(1)   47/       C :                     ; ******************************************************************************************************************
(1)   48/       C :                     
(1)   49/       C :                     MATH_ToASCII:
(1)   50/       C : C4 00               	ldi 	0 												; write a terminating NULL to the string
(1)   51/       E : C9 00               	st 		0(p1)
(1)   52/      10 :                     
(1)   53/      10 : C6 FE               	ld 		@-2(p2) 										; reserve 2 spaces on the stack.
(1)   54/      12 : C2 03               	ld 		3(p2) 											; copy original TOS to new TOS
(1)   55/      14 : CA 01               	st 		1(p2)
(1)   56/      16 : C2 02               	ld 		2(p2)
(1)   57/      18 : CA 00               	st 		0(p2)
(1)   58/      1A :                     
(1)   59/      1A : 37                  	xpah 	p3 												; save P3 on stack.
(1)   60/      1B : CA 03               	st 		3(p2) 											; where the number has just come from
(1)   61/      1D : 33                  	xpal 	p3												; we restore P3 last.
(1)   62/      1E : CA 02               	st 		2(p2)
(1)   63/      20 :                     
(1)   64/      20 :                     __ToASCII_Loop:
(1)   65/      20 : C4 00               	ldi 	(Maths-1)/256 									; set P3 to Maths routine
(1)   66/      22 : 37                  	xpah 	p3
(1)   67/      23 : C4 47               	ldi 	(Maths-1)&255
(1)   68/      25 : 33                  	xpal 	p3
(1)   69/      26 : C4 00               	ldi 	0  												; push 10 on the stack
(1)   70/      28 : CE FF               	st 		@-1(p2)
(1)   71/      2A : C4 0A               	ldi 	10
(1)   72/      2C : CE FF               	st 		@-1(p2)
(1)   73/      2E : C4 5C               	ldi 	'\\'											; unsigned division
(1)   74/      30 : 3F                  	xppc 	p3 												; calculate the result.
(1)   75/      31 :                     
(1)   76/      31 : C2 FE               	ld 		-2(p2) 											; get the remainder
(1)   77/      33 : DC 30               	ori 	'0'												; make ASCII
(1)   78/      35 : CD FF               	st 		@-1(p1) 										; save in the buffer, moving pointer backwards.
(1)   79/      37 :                     
(1)   80/      37 : C2 00               	ld 		0(p2) 											; loop back if TOS non zero
(1)   81/      39 : DA 01               	or 		1(p2)
(1)   82/      3B : 9C E3               	jnz 	__ToASCII_Loop
(1)   83/      3D :                     
(1)   84/      3D : C6 02               	ld 		@2(p2) 											; throw that away
(1)   85/      3F :                     
(1)   86/      3F : C6 01               	ld 		@1(p2) 											; restore P3
(1)   87/      41 : 33                  	xpal 	p3
(1)   88/      42 : C6 01               	ld 		@1(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 3 - 12/4/2015 10:28:39


(1)   89/      44 : 37                  	xpah 	p3
(1)   90/      45 : 02                  	ccl 													; result is fine.
(1)   91/      46 : 90 1F               	jmp 	MATH_Exit
(1)   92/      48 :                     
(1)   93/      48 :                     ; ******************************************************************************************************************
(1)   94/      48 :                     ;
(1)   95/      48 :                     ;		Maths routines : the (P2) stack functions as a number stack.  So to push $1234 on the stack you do
(1)   96/      48 :                     ;
(1)   97/      48 :                     ;		ld 	#$12
(1)   98/      48 :                     ;		st 	@-1(p2) 					1(p2) is the MSB of TOS
(1)   99/      48 :                     ;		ld 	#$34
(1)  100/      48 :                     ;		st 	@-1(p2) 					0(p2) is the LSB of TOS
(1)  101/      48 :                     ;
(1)  102/      48 :                     ;		on entry, A is the function (+,-,*,/ etc.). P2 should be left in the 'correct' state afterwards,
(1)  103/      48 :                     ;		so if you add two numbers then p2 will be 2 higher than when the routine was entered.
(1)  104/      48 :                     ;
(1)  105/      48 :                     ;		Supported : + - (add/subtract)
(1)  106/      48 :                     ;					* 	(multiply) 
(1)  107/      48 :                     ;					/ 	(signed divide) 
(1)  108/      48 :                     ;					\ 	(unsigned divide)
(1)  109/      48 :                     ;					? 	(ASCII @ p1 -> Integer. CS on error. P1 points to first non numeric character
(1)  110/      48 :                     ;					$ 	(Integer -> ASCII @p1. On start, p1 should point to the end of butter as written backwards)
(1)  111/      48 :                     ;
(1)  112/      48 :                     ;		Returns CS on error:
(1)  113/      48 :                     ;				Divisons			Division by zero error, no change to the stack values
(1)  114/      48 :                     ;				ASCII->Integer 		No legal number, p1 points to 'bad' character, no change to stack.
(1)  115/      48 :                     ;									(Note that the conversion is terminated by the first non digit, so this
(1)  116/      48 :                     ;									 error means the first character was not a digit.)
(1)  117/      48 :                     ;
(1)  118/      48 :                     ;		For both divisions, the remainder is kept on the stack immediately below the TOS, this is by design.
(1)  119/      48 :                     ;		and can be accessed by ld -1(p2) (hi) ld -2(p2) (lo).
(1)  120/      48 :                     ;
(1)  121/      48 :                     ;
(1)  122/      48 :                     ;		Note that division uses a fair chunk of the stack :)
(1)  123/      48 :                     ;
(1)  124/      48 :                     ; ******************************************************************************************************************
(1)  125/      48 :                     
(1)  126/      48 :                     Maths:															; maths support routine.
(1)  127/      48 : E4 24               	xri 	'$'													; integer to ASCII conversion
(1)  128/      4A : 98 C0               	jz 		MATH_ToASCII
(1)  129/      4C : E4 0F               	xri 	'$'!'+' 											; 16 bit addition
(1)  130/      4E : 98 1A               	jz 		MATH_Add 
(1)  131/      50 : E4 06               	xri 	'+'!'-' 											; 16 bit subtraction
(1)  132/      52 : 98 26               	jz 		MATH_Subtract
(1)  133/      54 : E4 07               	xri 	'-'!'*'												; 16 bit signed/unsigned multiplication
(1)  134/      56 : 98 34               	jz 		MATH_Multiply 										
(1)  135/      58 : E4 05               	xri 	'*'!'/' 											; 16 bit signed division
(1)  136/      5A : 02                  	ccl 
(1)  137/      5B : 98 75               	jz 		MATH_Divide2
(1)  138/      5D : E4 73               	xri 	'/'!'\\' 											; 16 bit unsigned division
(1)  139/      5F : 03                  	scl
(1)  140/      60 : 98 70               	jz 		MATH_Divide2
(1)  141/      62 : E4 63               	xri 	'\\'!'?' 											; ASCII (P1) -> Integer (? operator)
(1)  142/      64 : 98 6E               	jz 		MATH_ToInteger
(1)  143/      66 :                     
(1)  144/      66 :                     MATH_Error:
(1)  145/      66 : 03                  	scl 														; error, unknown command.
(1)  146/      67 :                     
(1)  147/      67 :                     MATH_Exit:
(1)  148/      67 : 3F                  	xppc 	p3 													; return
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 4 - 12/4/2015 10:28:39


(1)  149/      68 : 90 DE               	jmp  	Maths 												; re-entrant
(1)  150/      6A :                     
(1)  151/      6A :                     ; ******************************************************************************************************************
(1)  152/      6A :                     ;													+ :	16 Bit Add
(1)  153/      6A :                     ; ******************************************************************************************************************
(1)  154/      6A :                     
(1)  155/      6A :                     MATH_Add:
(1)  156/      6A : 02                  	ccl 										
(1)  157/      6B : C6 01               	ld 		@1(p2) 												; read LSB of TOS and unstack
(1)  158/      6D : F2 01               	add 	1(p2)
(1)  159/      6F : CA 01               	st 		1(p2)
(1)  160/      71 : C6 01               	ld 		@1(p2) 												; read MSB of TOS and unstack
(1)  161/      73 : F2 01               	add 	1(p2)
(1)  162/      75 : CA 01               	st 		1(p2)
(1)  163/      77 : 02                  	ccl
(1)  164/      78 : 90 ED               	jmp 	MATH_Exit
(1)  165/      7A :                     
(1)  166/      7A :                     ; ******************************************************************************************************************
(1)  167/      7A :                     ;												 - : 16 Bit Subtract
(1)  168/      7A :                     ; ******************************************************************************************************************
(1)  169/      7A :                     
(1)  170/      7A :                     MATH_Subtract:
(1)  171/      7A : 03                  	scl 										
(1)  172/      7B : C2 02               	ld 		2(p2) 												; read LSB of TOS 
(1)  173/      7D : FA 00               	cad 	0(p2)
(1)  174/      7F : CA 02               	st 		2(p2)
(1)  175/      81 : C2 03               	ld 		3(p2) 												; read MSB of TOS
(1)  176/      83 : FA 01               	cad 	1(p2)
(1)  177/      85 : CA 03               	st 		3(p2)
(1)  178/      87 : C6 02               	ld 		@2(p2)
(1)  179/      89 : 02                  	ccl
(1)  180/      8A : 90 DB               	jmp 	MATH_Exit
(1)  181/      8C :                     
(1)  182/      8C :                     ; ******************************************************************************************************************
(1)  183/      8C :                     ;									'*' : 16 bit signed or unsigned multiply
(1)  184/      8C :                     ; ******************************************************************************************************************
(1)  185/      8C :                     
(1)  186/      8C :                     MATH_Multiply:
(1)  187/      8C :                     
(1)  188/      8C :                     	section SCMPMultiply
(1)  189/      8C :                     
(1)  190/      8C : =0x3                aHi = 3 														; allocated values for A,B and Result.
(1)  191/      8C : =0x2                aLo = 2 														; (see arithmetic.py)
(1)  192/      8C : =0x1                bHi = 1
(1)  193/      8C : =0x0                bLo = 0
(1)  194/      8C : =0xFFFFFFFFF..      resultHi = -1
(1)  195/      8C : =0xFFFFFFFFF..      resultLo = -2
(1)  196/      8C :                     
(1)  197/      8C : C4 00               	ldi 	0 													; clear result
(1)  198/      8E : CA FF               	st 		resultHi(p2)
(1)  199/      90 : CA FE               	st 		resultLo(p2)
(1)  200/      92 :                     __MultiplyLoop:
(1)  201/      92 : C2 01               	ld 		bHi(p2) 											; if b is zero then exit
(1)  202/      94 : DA 00               	or 		bLo(p2)
(1)  203/      96 : 98 2D               	jz 		__MultiplyExit
(1)  204/      98 : C2 00               	ld 		bLo(p2) 											; if b bit 0 is set.
(1)  205/      9A : D4 01               	ani 	1
(1)  206/      9C : 98 0D               	jz 		__MultiplyNoAdd
(1)  207/      9E : 02                  	ccl 														; add a to the result
(1)  208/      9F : C2 FE               	ld 		resultLo(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 5 - 12/4/2015 10:28:39


(1)  209/      A1 : F2 02               	add 	aLo(p2)
(1)  210/      A3 : CA FE               	st 		resultLo(p2)
(1)  211/      A5 : C2 FF               	ld 		resultHi(p2)
(1)  212/      A7 : F2 03               	add 	aHi(p2)
(1)  213/      A9 : CA FF               	st 		resultHi(p2)
(1)  214/      AB :                     __MultiplyNoAdd:
(1)  215/      AB : (MACRO)             	shiftleft aLo 												; shift A left once.
(1)  215/      AB : 02                          ccl                                                                                                     
(1)  215/      AC : C2 02                       ld              ALO(p2)
(1)  215/      AE : F2 02                       add     ALO(p2)
(1)  215/      B0 : CA 02                       st              ALO(p2)
(1)  215/      B2 : C2 03                       ld              ALO+1(p2)
(1)  215/      B4 : F2 03                       add     ALO+1(p2)
(1)  215/      B6 : CA 03                       st              ALO+1(p2)               
(1)  216/      B8 : (MACRO)             	shiftright bLo 												; shift b right one.
(1)  216/      B8 : 02                          ccl
(1)  216/      B9 : C2 01                       ld              BLO+1(p2)
(1)  216/      BB : 1F                          rrl 
(1)  216/      BC : CA 01                       st              BLO+1(p2)
(1)  216/      BE : C2 00                       ld              BLO(p2)
(1)  216/      C0 : 1F                          rrl 
(1)  216/      C1 : CA 00                       st              BLO(p2)
(1)  217/      C3 : 90 CD               	jmp 	__MultiplyLoop
(1)  218/      C5 :                     
(1)  219/      C5 :                     __MultiplyExit:
(1)  220/      C5 : C2 FE               	ld 		resultLo(p2) 										; copy result lo to what will be new TOS
(1)  221/      C7 : CA 02               	st 		2(p2)
(1)  222/      C9 : C2 FF               	ld 		resultHi(p2)
(1)  223/      CB : CA 03               	st 		3(p2)
(1)  224/      CD : C6 02               	ld 		@2(p2) 												; fix up the number stack.
(1)  225/      CF :                     	endsection SCMPMultiply
(1)  226/      CF :                     
(1)  227/      CF : 02                  	ccl
(1)  228/      D0 :                     MATH_Exit1:
(1)  229/      D0 : 90 95               	jmp 	MATH_Exit
(1)  230/      D2 :                     
(1)  231/      D2 :                     ; ******************************************************************************************************************
(1)  232/      D2 :                     ;								? Convert string at P1 to 16 bit integer base 10
(1)  233/      D2 :                     ; ******************************************************************************************************************
(1)  234/      D2 :                     
(1)  235/      D2 :                     MATH_Divide2:
(1)  236/      D2 : 90 66               	jmp 	MATH_Divide
(1)  237/      D4 :                     
(1)  238/      D4 :                     MATH_ToInteger:
(1)  239/      D4 :                     
(1)  240/      D4 :                     	section SCMPToInteger
(1)  241/      D4 :                     
(1)  242/      D4 : =0xFFFFFFFFF..      digitCount = -1													; digits converted.
(1)  243/      D4 : =0xFFFFFFFFF..      resultHi = -2  													; result is pushed at the end
(1)  244/      D4 : =0xFFFFFFFFF..      resultLo = -3 
(1)  245/      D4 : =0xFFFFFFFFF..      shiftCount = -4 												; counter used when multiplying by 10.
(1)  246/      D4 : =0xFFFFFFFFF..      tempHi = -5 													; temporary result for x 10.
(1)  247/      D4 : =0xFFFFFFFFF..      tempLo = -6
(1)  248/      D4 :                     
(1)  249/      D4 : C4 00               	ldi 	0 													; clear digitcount and result to zero
(1)  250/      D6 : CA FF               	st 		digitCount(p2)
(1)  251/      D8 : CA FE               	st 		resultHi(p2)
(1)  252/      DA : CA FD               	st 		resultLo(p2)
(1)  253/      DC :                     ToInt_Loop:
(1)  254/      DC : C1 00               	ld 		0(p1) 												; read next digit
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 6 - 12/4/2015 10:28:39


(1)  255/      DE : 03                  	scl 	
(1)  256/      DF : FC 3A               	cai 	'9'+1
(1)  257/      E1 : 94 44               	jp 		ToInt_End 											; if > 9 then fail.
(1)  258/      E3 : F4 8A               	adi 	128+10 												; if < 0 then fail
(1)  259/      E5 : 94 40               	jp 		ToInt_End
(1)  260/      E7 : AA FF               	ild 	digitCount(p2) 										; increment count of digits converted.
(1)  261/      E9 : C4 02               	ldi 	2 													; set shift counter to 2
(1)  262/      EB : CA FC               	st 		shiftCount(p2)
(1)  263/      ED : C2 FE               	ld 		resultHi(p2) 										; copy result current to temp
(1)  264/      EF : CA FB               	st 		tempHi(p2)
(1)  265/      F1 : C2 FD               	ld 		resultLo(p2)
(1)  266/      F3 : CA FA               	st 		tempLo(p2)
(1)  267/      F5 :                     ToInt_Shift:
(1)  268/      F5 : (MACRO)             	shiftleft resultLo 											; shift result left
(1)  268/      F5 : 02                          ccl                                                                                                     
(1)  268/      F6 : C2 FD                       ld              RESULTLO(p2)
(1)  268/      F8 : F2 FD                       add     RESULTLO(p2)
(1)  268/      FA : CA FD                       st              RESULTLO(p2)
(1)  268/      FC : C2 FE                       ld              RESULTLO+1(p2)
(1)  268/      FE : F2 FE                       add     RESULTLO+1(p2)
(1)  268/     100 : CA FE                       st              RESULTLO+1(p2)               
(1)  269/     102 : BA FC               	dld 	shiftCount(p2) 										; after 2nd time round (x 4) will be zero
(1)  270/     104 : 9C 0D               	jnz 	ToInt_NoAdd
(1)  271/     106 : 02                  	ccl 														; add original value when x 4 - e.g. x 5
(1)  272/     107 : C2 FD               	ld 		resultLo(p2)
(1)  273/     109 : F2 FA               	add 	tempLo(p2)
(1)  274/     10B : CA FD               	st 		resultLo(p2)
(1)  275/     10D : C2 FE               	ld 		resultHi(p2)
(1)  276/     10F : F2 FB               	add 	tempHi(p2)
(1)  277/     111 : CA FE               	st 		resultHi(p2)
(1)  278/     113 :                     ToInt_NoAdd:
(1)  279/     113 : C2 FC               	ld 		shiftCount(p2) 										; go round until -ve, e.g. 3 in total.
(1)  280/     115 : 94 DE               	jp 		ToInt_Shift
(1)  281/     117 :                     
(1)  282/     117 : C5 01               	ld 		@1(p1) 												; read the digit already tested.
(1)  283/     119 : D4 0F               	ani 	0x0F 												; to a number
(1)  284/     11B : 02                  	ccl 
(1)  285/     11C : F2 FD               	add 	resultLo(p2) 										; add to result
(1)  286/     11E : CA FD               	st 		resultLo(p2)
(1)  287/     120 : 06                  	csa 														; if carry clear
(1)  288/     121 : 94 B9               	jp 		ToInt_Loop 											; go round again.
(1)  289/     123 : AA FE               	ild 	resultHi(p2) 										; adds the carry to high
(1)  290/     125 : 90 B5               	jmp 	ToInt_Loop
(1)  291/     127 :                     
(1)  292/     127 :                     ToInt_End:
(1)  293/     127 : C2 FF               	ld 		digitCount(p2) 										; if digit count = 0, e.g. nothing converted
(1)  294/     129 : 03                  	scl
(1)  295/     12A : 98 A4               	jz 		MATH_Exit1 											; exit with carry set
(1)  296/     12C :                     
(1)  297/     12C : C2 FE               	ld 		resultHi(p2) 										; save result on stack
(1)  298/     12E : CA FF               	st 		-1(p2)
(1)  299/     130 : C2 FD               	ld 		resultLo(p2)
(1)  300/     132 : CE FE               	st 		@-2(p2)
(1)  301/     134 : 02                  	ccl 														; clear carry as okay, and exit.
(1)  302/     135 :                     	endsection SCMPToInteger
(1)  303/     135 :                     
(1)  304/     135 :                     MATH_Exit3:
(1)  305/     135 : 90 99               	jmp 	MATH_Exit1
(1)  306/     137 :                     
(1)  307/     137 :                     ; ******************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 7 - 12/4/2015 10:28:39


(1)  308/     137 :                     ;							'/' : 16 bit signed/unsigned divide (CY/L = 0 = signed)
(1)  309/     137 :                     ; ******************************************************************************************************************
(1)  310/     137 :                     
(1)  311/     137 :                     MATH_DivideByZero:												; come here for divide by zero.
(1)  312/     137 : 03                  	scl
(1)  313/     138 : 90 FB               	jmp 	MATH_Exit3
(1)  314/     13A :                     
(1)  315/     13A :                     MATH_Divide:
(1)  316/     13A :                     
(1)  317/     13A :                     	section 	SCMPDivide
(1)  318/     13A :                     
(1)  319/     13A : =0x1                denominatorHi = 1 												; input values to division
(1)  320/     13A : =0x0                denominatorLo = 0 												; (see arithmetic.py)
(1)  321/     13A : =0x3                numeratorHi = 3
(1)  322/     13A : =0x2                numeratorLo = 2
(1)  323/     13A : =0xFFFFFFFFF..      bitHi = -1 														; bit shifted for division test.
(1)  324/     13A : =0xFFFFFFFFF..      bitLo = -2
(1)  325/     13A : =0xFFFFFFFFF..      quotientHi = -3 												; quotient
(1)  326/     13A : =0xFFFFFFFFF..      quotientLo = -4
(1)  327/     13A : =0xFFFFFFFFF..      remainderHi = -5 												; remainder
(1)  328/     13A : =0xFFFFFFFFF..      remainderLo = -6
(1)  329/     13A : =0xFFFFFFFFF..      signCount = -7 													; sign of result (bit 0)
(1)  330/     13A : =0xFFFFFFFFF..      eTemp = -8 														; temporary value of sign.
(1)  331/     13A : =0xFFFFFFFFF..      tempHi = -9 													; high byte temporary
(1)  332/     13A :                     
(1)  333/     13A : C2 00               	ld 		denominatorLo(p2) 									; check denominator 
(1)  334/     13C : DA 01               	or 		denominatorHi(p2) 
(1)  335/     13E : 98 F7               	jz 		MATH_DivideByZero 									; fail if dividing by zero.
(1)  336/     140 :                     
(1)  337/     140 : C4 00               	ldi 	0 													; clear quotient and remainder
(1)  338/     142 : CA FD               	st 		quotientHi(p2)
(1)  339/     144 : CA FC               	st 		quotientLo(p2)
(1)  340/     146 : CA FB               	st 		remainderHi(p2)
(1)  341/     148 : CA FA               	st 		remainderLo(p2)
(1)  342/     14A : CA F9               	st 		signCount(p2)
(1)  343/     14C : CA FE               	st 		bitLo(p2) 											; set bit to 0x8000
(1)  344/     14E : C4 80               	ldi 	0x80 
(1)  345/     150 : CA FF               	st 		bitHi(p2)
(1)  346/     152 :                     
(1)  347/     152 : 40                  	lde 														; save E
(1)  348/     153 : CA F8               	st 		eTemp(p2)
(1)  349/     155 :                     
(1)  350/     155 : 06                  	csa 														; look at carry bit
(1)  351/     156 : D4 80               	ani 	0x80 												; if set, unsigned division.
(1)  352/     158 : 9C 24               	jnz 	__DivideLoop 										; so skip over the sign removal code.
(1)  353/     15A :                     
(1)  354/     15A : C4 03               	ldi 	3
(1)  355/     15C :                     __DivideUnsignLoop:
(1)  356/     15C : 01                  	xae 														; store in E
(1)  357/     15D : C2 80               	ld 		-0x80(p2) 											; read high byte
(1)  358/     15F : 94 13               	jp 		__DivideNotSigned 									; if +ve then skip
(1)  359/     161 : AA F9               	ild 	signCount(p2) 										; bump sign count
(1)  360/     163 : C6 FF               	ld 		@-1(p2) 											; dec P2 to access the LSB
(1)  361/     165 : C4 00               	ldi 	0
(1)  362/     167 : 03                  	scl 
(1)  363/     168 : FA 80               	cad 	-0x80(p2)
(1)  364/     16A : CA 80               	st 		-0x80(p2)
(1)  365/     16C : C6 01               	ld 		@1(p2) 												; inc P2 to access the MSB
(1)  366/     16E : C4 00               	ldi 	0
(1)  367/     170 : FA 80               	cad 	-0x80(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 8 - 12/4/2015 10:28:39


(1)  368/     172 : CA 80               	st 		-0x80(p2)
(1)  369/     174 :                     __DivideNotSigned:
(1)  370/     174 : 01                  	xae 														; retrieve E
(1)  371/     175 : 03                  	scl 														; subtract 2
(1)  372/     176 : FC 02               	cai 	2
(1)  373/     178 : 94 E2               	jp 		__DivideUnsignLoop 									; not finished yet.
(1)  374/     17A : 90 02               	jmp 	__DivideLoop
(1)  375/     17C :                     
(1)  376/     17C :                     __MATH_Exit2
(1)  377/     17C : 90 B7               	jmp 	MATH_Exit3
(1)  378/     17E :                     
(1)  379/     17E :                     __DivideLoop:
(1)  380/     17E : C2 FE               	ld 		bitLo(p2) 											; keep going until all bits done.
(1)  381/     180 : DA FF               	or 		bitHi(p2)
(1)  382/     182 : 98 42               	jz 		__DivideExit
(1)  383/     184 :                     
(1)  384/     184 : (MACRO)             	shiftleft remainderLo 										; shift remainder left.
(1)  384/     184 : 02                          ccl                                                                                                     
(1)  384/     185 : C2 FA                       ld              REMAINDERLO(p2)
(1)  384/     187 : F2 FA                       add     REMAINDERLO(p2)
(1)  384/     189 : CA FA                       st              REMAINDERLO(p2)
(1)  384/     18B : C2 FB                       ld              REMAINDERLO+1(p2)
(1)  384/     18D : F2 FB                       add     REMAINDERLO+1(p2)
(1)  384/     18F : CA FB                       st              REMAINDERLO+1(p2)               
(1)  385/     191 :                     
(1)  386/     191 : C2 03               	ld 		numeratorHi(p2)										; if numerator MSB is set
(1)  387/     193 : 94 06               	jp 		__DivideNoIncRemainder
(1)  388/     195 :                     
(1)  389/     195 : AA FA               	ild 	remainderLo(p2) 									; then increment remainder
(1)  390/     197 : 9C 02               	jnz 	__DivideNoIncRemainder
(1)  391/     199 : AA FB               	ild 	remainderHi(p2)
(1)  392/     19B :                     __DivideNoIncRemainder:
(1)  393/     19B :                     
(1)  394/     19B : 03                  	scl 														; calculate remainder-denominator (temp)
(1)  395/     19C : C2 FA               	ld 		remainderLo(p2)
(1)  396/     19E : FA 00               	cad 	denominatorLo(p2)
(1)  397/     1A0 : 01                  	xae 														; save in E.
(1)  398/     1A1 : C2 FB               	ld 		remainderHi(p2)
(1)  399/     1A3 : FA 01               	cad 	denominatorHi(p2) 									; temp.high is now in A
(1)  400/     1A5 : CA F7               	st 		tempHi(p2) 											; temp.high now saved
(1)  401/     1A7 : 06                  	csa 														; check carry flag
(1)  402/     1A8 : D4 80               	ani 	0x80 	
(1)  403/     1AA : 9C 45               	jnz 	__DivideRemainderGreater 							; if set then remainder >= denominator
(1)  404/     1AC :                     
(1)  405/     1AC :                     __DivideContinue:
(1)  406/     1AC : (MACRO)             	shiftright 	bitLo 											; shift bit right
(1)  406/     1AC : 02                          ccl
(1)  406/     1AD : C2 FF                       ld              BITLO+1(p2)
(1)  406/     1AF : 1F                          rrl 
(1)  406/     1B0 : CA FF                       st              BITLO+1(p2)
(1)  406/     1B2 : C2 FE                       ld              BITLO(p2)
(1)  406/     1B4 : 1F                          rrl 
(1)  406/     1B5 : CA FE                       st              BITLO(p2)
(1)  407/     1B7 : (MACRO)             	shiftleft   numeratorLo 									; shift numerator left
(1)  407/     1B7 : 02                          ccl                                                                                                     
(1)  407/     1B8 : C2 02                       ld              NUMERATORLO(p2)
(1)  407/     1BA : F2 02                       add     NUMERATORLO(p2)
(1)  407/     1BC : CA 02                       st              NUMERATORLO(p2)
(1)  407/     1BE : C2 03                       ld              NUMERATORLO+1(p2)
(1)  407/     1C0 : F2 03                       add     NUMERATORLO+1(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 9 - 12/4/2015 10:28:39


(1)  407/     1C2 : CA 03                       st              NUMERATORLO+1(p2)               
(1)  408/     1C4 : 90 B8               	jmp 		__DivideLoop
(1)  409/     1C6 :                     
(1)  410/     1C6 :                     __DivideExit:
(1)  411/     1C6 : C2 F9               	ld 		signCount(p2) 										; is the result signed
(1)  412/     1C8 : D4 01               	ani 	0x01
(1)  413/     1CA : 98 0D               	jz 		__DivideComplete
(1)  414/     1CC : 03                  	scl 														; if so, reapply the sign.
(1)  415/     1CD : C4 00               	ldi 	0
(1)  416/     1CF : FA FC               	cad 	quotientLo(p2)
(1)  417/     1D1 : CA FC               	st 		quotientLo(p2)
(1)  418/     1D3 : C4 00               	ldi 	0
(1)  419/     1D5 : FA FD               	cad 	quotientHi(p2)
(1)  420/     1D7 : CA FD               	st 		quotientHi(p2)
(1)  421/     1D9 :                     
(1)  422/     1D9 :                     __DivideComplete:
(1)  423/     1D9 : C2 FD               	ld 		quotientHi(p2) 										; copy quotient to what will be TOS
(1)  424/     1DB : CA 03               	st 		3(p2)
(1)  425/     1DD : C2 FC               	ld 		quotientLo(p2)
(1)  426/     1DF : CA 02               	st 		2(p2)
(1)  427/     1E1 : C2 FB               	ld 		remainderHi(p2) 									; put remainder immediately after it if we want it
(1)  428/     1E3 : CA 01               	st 		1(p2)
(1)  429/     1E5 : C2 FA               	ld 		remainderLo(p2) 
(1)  430/     1E7 : CA 00               	st 		0(p2)
(1)  431/     1E9 :                     
(1)  432/     1E9 : C2 F8               	ld 		eTemp(p2) 											; restore E
(1)  433/     1EB : 01                  	xae 
(1)  434/     1EC : C6 02               	ld 		@2(p2) 												; fix stack back up leaving quotient and hidden remainder
(1)  435/     1EE : 02                  	ccl 														; return no error.
(1)  436/     1EF : 90 8B               	jmp 	__MATH_Exit2
(1)  437/     1F1 :                     
(1)  438/     1F1 :                     __DivideRemainderGreater: 										; this is the "if temp >= 0 bit"
(1)  439/     1F1 : C2 F7               	ld 		tempHi(p2) 											; get the difference back.
(1)  440/     1F3 : CA FB               	st 		remainderHi(p2) 									; save temp.high value into remainder.high
(1)  441/     1F5 : 40                  	lde 														; copy temp.low to remainder.low
(1)  442/     1F6 : CA FA               	st 		remainderLo(p2) 
(1)  443/     1F8 :                     
(1)  444/     1F8 : C2 FC               	ld 		quotientLo(p2) 										; or bit into quotient
(1)  445/     1FA : DA FE               	or 		bitLo(p2)
(1)  446/     1FC : CA FC               	st 		quotientLo(p2)
(1)  447/     1FE : C2 FD               	ld 		quotientHi(p2)
(1)  448/     200 : DA FF               	or 		bitHi(p2)
(1)  449/     202 : CA FD               	st 		quotientHi(p2)
(1)  450/     204 : 90 A6               	jmp 	__DivideContinue
(1)  451/     206 :                     
(1)  452/     206 :                     
(1)  453/     206 :                     	endsection	SCMPDivide
(1)  454/     206 :                     
      33/     206 :                     
      34/     206 :                     ; ******************************************************************************************************************
      35/     206 :                     ;
      36/     206 :                     ;				Boot Up. First we check for a ROM @ $9000 and if it is 0x68 we boot there instead
      37/     206 :                     ;
      38/     206 :                     ; ******************************************************************************************************************
      39/     206 :                     
      40/     206 :                     BootMonitor:
      41/     206 : C4 90               		ldi 	0x90 											; point P1 to $9000 which is the first ROM.
      42/     208 : 35                  		xpah 	p1
      43/     209 : C1 00               		ld 		0(p1) 											; if that byte is $68, go straight there.
      44/     20B : E4 68               		xri 	0x68  											; we can boot into VTL-2 or whatever.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 10 - 12/4/2015 10:28:39


      45/     20D : 9C 01               		jnz 	__BootMonitor
      46/     20F : 3D                  		xppc 	p1 												; e.g. JMP $9001
      47/     210 :                     __BootMonitor:
      48/     210 :                     
      49/     210 :                     ; ******************************************************************************************************************
      50/     210 :                     ;
      51/     210 :                     ;									Find Top of Memory to initialise the stack.
      52/     210 :                     ;
      53/     210 :                     ;			(slightly tweaked to work round 4+12 emulator limitations - will work on real chip)
      54/     210 :                     ; ******************************************************************************************************************
      55/     210 :                     
      56/     210 : C4 0F               		ldi 	0x0F 											; point P2 to theoretical top of RAM on basic m/c
      57/     212 : 36                  		xpah 	p2 												; e.g. 0xFFF
      58/     213 : C4 FF               		ldi 	0xFF 											; ideally you'd make this 0x003F and remove the ld
      59/     215 : 32                  		xpal 	p2 												; but the emulators don't do 4+12 math. Only matters here.
      60/     216 : C6 40               		ld 		@64(p2) 										; fix the predecrement (wrap around not emulated)
      61/     218 :                     FindTopMemory:
      62/     218 : C4 A5               		ldi 	0xA5 											; try to write this to memory
      63/     21A : CE C0               		st 		@-64(p2) 										; predecrementing by 64.
      64/     21C : E2 00               		xor 	(p2) 											; did it write correctly.
      65/     21E : 9C F8               		jnz 	FindTopMemory 									; now P2 points to top of memory.
      66/     220 :                     
      67/     220 :                     ; ******************************************************************************************************************
      68/     220 :                     ;
      69/     220 :                     ;												Clear the screen
      70/     220 :                     ;
      71/     220 :                     ; ******************************************************************************************************************
      72/     220 :                     
      73/     220 :                     ClearScreen_Command:
      74/     220 : C4 00               		ldi 	0 												; set P1 to zero to access VRAM via write.
      75/     222 : 35                  		xpah 	p1
      76/     223 : C4 00               		ldi 	0
      77/     225 :                     ClearScreenLoop:
      78/     225 : 31                  		xpal 	p1												; clear screen
      79/     226 : C4 20               		ldi 	' '
      80/     228 : CD 01               		st 		@1(p1)
      81/     22A : 31                  		xpal 	p1
      82/     22B : 94 F8               		jp 		ClearScreenLoop
      83/     22D : C4 0C               		ldi 	Cursor/256 										; reset the cursor position to TOS
      84/     22F : 35                  		xpah 	p1
      85/     230 : C4 18               		ldi 	Cursor&255
      86/     232 : 31                  		xpal 	p1 
      87/     233 : C4 00               		ldi 	0 												; Note: could save 2 bytes here, P1.H is 0.
      88/     235 : C9 00               		st 		0(p1)											
      89/     237 :                     
      90/     237 :                     ; ****************************************************************************************************************
      91/     237 :                     ;
      92/     237 :                     ;												Check if initialised.
      93/     237 :                     ;
      94/     237 :                     ; ****************************************************************************************************************
      95/     237 :                     
      96/     237 : C1 03               		ld 		isInit-Cursor(p1) 								; have we initialised ?
      97/     239 : E4 A7               		xri 	0xA7 											; if so this byte should be $A7
      98/     23B : 98 4B               		jz 		CommandMainLoop
      99/     23D : C4 A7               		ldi 	0xA7 											; set the initialised byte
     100/     23F : C9 03               		st 		isInit-Cursor(p1)
     101/     241 :                     
     102/     241 : C4 0C               		ldi 	codeStart/256 									; set the initial work address
     103/     243 : C9 02               		st 		Current-Cursor+1(p1)
     104/     245 : C4 2E               		ldi 	codeStart&255
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 11 - 12/4/2015 10:28:39


     105/     247 : C9 01               		st 		Current-Cursor(p1)
     106/     249 :                     																; print boot message - can lose this if required.
     107/     249 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     108/     24B : 37                  		xpah 	p3 
     109/     24C : C4 DB               		ldi 	(PrintCharacter-1)&255
     110/     24E : 33                  		xpal 	p3
     111/     24F : C4 02               		ldi 	Message / 256 									; set P1 = boot message
     112/     251 : 35                  		xpah 	p1
     113/     252 : C4 5C               		ldi 	Message & 255
     114/     254 : 31                  		xpal 	p1
     115/     255 :                     MessageLoop:
     116/     255 : C5 01               		ld 		@1(p1) 											; read character
     117/     257 : 98 22               		jz 		InitialBeep 									; end of message
     118/     259 : 3F                  		xppc 	p3 												; print it
     119/     25A : 90 F9               		jmp 	MessageLoop
     120/     25C :                     
     121/     25C :                     Message:
     122/     25C : 2A 2A 20 53 43 2F   		db 		"** SC/MP OS **",13 							; short boot message
                    4D 50 20 4F 53 20 
                    2A 2A 0D 
     123/     26B : 56 30 2E 39 32 20   		db 		"V0.92 PSR 2016",13
                    50 53 52 20 32 30 
                    31 36 0D 
     124/     27A : 00                  		db 		0
     125/     27B :                     
     126/     27B :                     InitialBeep:
     127/     27B : C4 01               		ldi 	1 												; Beep on booting.
     128/     27D : 07                  		cas 													; play low tone
     129/     27E : 8F FF               		dly 	0xFF
     130/     280 : C4 05               		ldi 	5												; play high tone.
     131/     282 : 07                  		cas
     132/     283 : 8F FF               		dly 	0xFF
     133/     285 : C4 00               		ldi 	0 												; sound off.
     134/     287 : 07                  		cas
     135/     288 :                     
     136/     288 :                     ; ****************************************************************************************************************
     137/     288 :                     ;
     138/     288 :                     ;													Main Loop
     139/     288 :                     ;
     140/     288 :                     ; ****************************************************************************************************************
     141/     288 :                     
     142/     288 :                     CommandMainLoop:
     143/     288 : C4 06               		ldi 	(PrintAddressData-1)/256						; print Address only
     144/     28A : 37                  		xpah 	p3
     145/     28B : C4 48               		ldi 	(PrintAddressData-1)&255
     146/     28D : 33                  		xpal 	p3
     147/     28E : C4 00               		ldi 	0 												; no data elements
     148/     290 : 3F                  		xppc 	p3
     149/     291 :                     
     150/     291 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     151/     293 : 37                  		xpah 	p3
     152/     294 : C4 DB               		ldi 	(PrintCharacter-1)&255
     153/     296 : 33                  		xpal 	p3
     154/     297 : C4 5D               		ldi 	']'												; print the prompt.
     155/     299 : 3F                  		xppc 	p3
     156/     29A :                     
     157/     29A :                     ; ****************************************************************************************************************
     158/     29A :                     ;
     159/     29A :                     ;											Keyboard Line Input
     160/     29A :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 12 - 12/4/2015 10:28:39


     161/     29A :                     ; ****************************************************************************************************************
     162/     29A :                     
     163/     29A : C4 00               		ldi 	0 												; set E = character position.
     164/     29C : 01                  		xae 
     165/     29D :                     KeyboardLoop:
     166/     29D : C4 08               		ldi 	0x8 											; set P1 to point to keyboard latch
     167/     29F : 35                  		xpah 	p1
     168/     2A0 :                     _KBDWaitRelease:
     169/     2A0 : C1 00               		ld 		0(p1) 											; wait for strobe to clear
     170/     2A2 : 94 02               		jp 		_KBDWaitKey
     171/     2A4 : 90 FA               		jmp 	_KBDWaitRelease
     172/     2A6 :                     _KBDWaitKey:
     173/     2A6 : C1 00               		ld 		0(p1) 											; wait for strobe, i.e. new key
     174/     2A8 : 94 FC               		jp 		_KBDWaitKey
     175/     2AA : D4 7F               		ani 	0x7F 											; throw away bit 7
     176/     2AC : CA FF               		st 		-1(p2) 											; save key.
     177/     2AE :                     
     178/     2AE : C4 0C               		ldi 	kbdBuffer/256 									; set P1 = keyboard buffer
     179/     2B0 : 35                  		xpah 	p1
     180/     2B1 : C4 1E               		ldi 	kbdBuffer&255
     181/     2B3 : 31                  		xpal 	p1		
     182/     2B4 :                     
     183/     2B4 : C2 FF               		ld 		-1(p2) 											; read key
     184/     2B6 : E4 08               		xri 	8 												; is it backspace
     185/     2B8 : 98 1E               		jz 		__KBDBackSpace
     186/     2BA : E4 05               		xri 	8!13 											; is it CR, then exit
     187/     2BC : 98 28               		jz 		__KBDExit
     188/     2BE :                     
     189/     2BE : 40                  		lde 													; have we a full buffer.
     190/     2BF : E4 10               		xri 	kbdBufferLn 									; if so, ignore the key.
     191/     2C1 : 98 DA               		jz 		KeyboardLoop
     192/     2C3 :                     
     193/     2C3 : C2 FF               		ld 		-1(p2) 											; restore the key.
     194/     2C5 : 02                  		ccl
     195/     2C6 : F4 20               		adi 	0x20											; will make lower case -ve
     196/     2C8 : 94 02               		jp 		__KBDNotLower
     197/     2CA : FC 20               		cai 	0x20 											; capitalise
     198/     2CC :                     __KBDNotLower:
     199/     2CC : F4 E0               		adi 	0xE0 											; fix up.
     200/     2CE : C9 80               		st 		-0x80(p1) 										; save in the buffer using E as index.
     201/     2D0 : 3F                  		xppc 	p3 												; print the character
     202/     2D1 : 01                  		xae 													; increment E
     203/     2D2 : 02                  		ccl
     204/     2D3 : F4 01               		adi 	1
     205/     2D5 : 01                  		xae
     206/     2D6 : 90 C5               		jmp 	KeyboardLoop 									; and get the next key.
     207/     2D8 :                     
     208/     2D8 :                     __KBDBackSpace:
     209/     2D8 : 40                  		lde 													; get position
     210/     2D9 : 98 C2               		jz 		KeyboardLoop 									; can't go back if at beginning
     211/     2DB : 03                  		scl 													; go back 1 from E
     212/     2DC : FC 01               		cai 	1
     213/     2DE : 01                  		xae 
     214/     2DF : C4 08               		ldi 	8 												; print a backspace
     215/     2E1 : 3F                  		xppc 	p3
     216/     2E2 : 90 B9               		jmp 	KeyboardLoop 									; and go round again.
     217/     2E4 :                     
     218/     2E4 :                     __CmdMainLoop1:
     219/     2E4 : 90 A2               		jmp 	CommandMainLoop
     220/     2E6 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 13 - 12/4/2015 10:28:39


     221/     2E6 :                     __KBDExit:
     222/     2E6 : C9 80               		st 		-0x80(p1) 										; add the ASCIIZ terminator.
     223/     2E8 : C4 0D               		ldi 	13												; print a new line.
     224/     2EA : 3F                  		xppc 	p3
     225/     2EB :                     
     226/     2EB :                     ; ****************************************************************************************************************
     227/     2EB :                     ;
     228/     2EB :                     ;						Extract the 5 bit 3 letter (max command value). P1 points to buffer
     229/     2EB :                     ;
     230/     2EB :                     ; ****************************************************************************************************************
     231/     2EB :                     
     232/     2EB : C4 00               		ldi 	0
     233/     2ED : 01                  		xae 													; E contains the LSB of the 5 bit shift
     234/     2EE : 40                  		lde 	
     235/     2EF : CA FF               		st 		-1(p2) 											; -1(P2) contains the MSB
     236/     2F1 : C9 FF               		st 		modifier-kbdBuffer(p1)							; clear the modifier.
     237/     2F3 :                     Extract5Bit:
     238/     2F3 : C1 00               		ld 		(p1) 											; look at character
     239/     2F5 : 02                  		ccl 													; add 128-65, will be +ve if < 64
     240/     2F6 : F4 3F               		adi 	128-65
     241/     2F8 : 94 1A               		jp 		__ExtractEnd
     242/     2FA : C4 05               		ldi 	5 												; shift current value left 5 times using -2(p2)
     243/     2FC : CA FE               		st 		-2(p2)
     244/     2FE :                     __Ex5Shift:
     245/     2FE : 40                  		lde 													; shift E left into CY/L
     246/     2FF : 02                  		ccl
     247/     300 : 70                  		ade 
     248/     301 : 01                  		xae
     249/     302 : C2 FF               		ld 		-1(p2) 											; shift CY/L into -1(p2) and carry/link
     250/     304 : F2 FF               		add 	-1(p2)
     251/     306 : CA FF               		st 		-1(p2)
     252/     308 : BA FE               		dld 	-2(p2) 											; done it 5 times ?
     253/     30A : 9C F2               		jnz 	__Ex5Shift
     254/     30C : C5 01               		ld 		@1(p1) 											; re-read character.
     255/     30E : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     256/     310 : 58                  		ore 													; OR into E
     257/     311 : 01                  		xae
     258/     312 : 90 DF               		jmp 	Extract5Bit 									; go and get the next one.
     259/     314 :                     
     260/     314 :                     __ExtractEnd:
     261/     314 : C4 1C               		ldi 	parPosn & 255 									; P1.L = Parameter Position, A = first non cmd char
     262/     316 : 31                  		xpal	p1
     263/     317 : C9 00               		st 		(p1) 											; write to parameter position.
     264/     319 :                     
     265/     319 :                     ; ****************************************************************************************************************
     266/     319 :                     ;
     267/     319 :                     ;						Find command in -1 (P2) (High) E (Low) in Command table
     268/     319 :                     ;	
     269/     319 :                     ; ****************************************************************************************************************
     270/     319 :                     
     271/     319 : C4 47               		ldi 	__commandList & 255 							; point P1 to the command list
     272/     31B : 31                  		xpal 	p1
     273/     31C : C4 07               		ldi 	__commandList / 256 		
     274/     31E : 35                  		xpah 	p1	
     275/     31F :                     __FindCommandLoop:
     276/     31F : C1 00               		ld 		0(p1) 											; reached the end of the table ?
     277/     321 : D9 01               		or 		1(p1)											; which is marked by word 0000
     278/     323 : 98 31               		jz 		__CommandError
     279/     325 : C5 03               		ld 		@3(p1) 											; read low byte, and point to next
     280/     327 : 60                  		xre
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 14 - 12/4/2015 10:28:39


     281/     328 : 9C F5               		jnz 	__FindCommandLoop 								; if different to LSB loop back.
     282/     32A : C1 FE               		ld 		-2(p1) 											; read the high byte
     283/     32C : E2 FF               		xor 	-1(p2) 											; if different to the MSB loop back.
     284/     32E : 9C EF               		jnz 	__FindCommandLoop
     285/     330 :                     
     286/     330 :                     ; ****************************************************************************************************************
     287/     330 :                     ;
     288/     330 :                     ;				Found command, figure out if ASM or Command, if Command go to that routine
     289/     330 :                     ;
     290/     330 :                     ; ****************************************************************************************************************
     291/     330 :                     
     292/     330 : C4 7B               		ldi 	(GetParameter-1) & 255 							; point P3 to the get parameter code.
     293/     332 : 33                  		xpal 	p3
     294/     333 : C4 06               		ldi 	(GetParameter-1) / 256
     295/     335 : 37                  		xpah 	p3
     296/     336 :                     
     297/     336 : C1 FF               		ld 		-1(p1) 											; read the operation code.
     298/     338 : D4 F0               		ani 	0xF0 											; look at the m-s-nibble - commands are 0x20.
     299/     33A : E4 20               		xri 	0x20
     300/     33C : 9C 22               		jnz 	__Assembler
     301/     33E :                     
     302/     33E : C1 FF               		ld 		-1(p1) 											; re-read it
     303/     340 : 02                  		ccl
     304/     341 : F1 FF               		add 	-1(p1) 											; double it
     305/     343 : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     306/     345 : F4 EE               		adi 	__CommandTable & 255 							; make P1 point to the command table entry
     307/     347 : 31                  		xpal 	p1
     308/     348 : C4 07               		ldi 	__CommandTable / 256 					
     309/     34A : 35                  		xpah 	p1
     310/     34B : C1 00               		ld 		0(p1) 											; read low address
     311/     34D : 01                  		xae
     312/     34E : C1 01               		ld 		1(p1) 											; read high address
     313/     350 : 35                  		xpah 	p1 												; put in P1.H
     314/     351 : 40                  		lde 													; get low address
     315/     352 : 31                  		xpal 	p1 												; put in P1.L
     316/     353 : C5 FF               		ld 		@-1(p1) 										; fix up for the pre-increment
     317/     355 : 3D                  		xppc 	p1 												; and go there.
     318/     356 :                     
     319/     356 :                     __CommandError: 												; unknown command.
     320/     356 : C4 03               		ldi 	3 												; set the beeper on
     321/     358 : 07                  		cas
     322/     359 : 8F FF               		dly 	0xFF 											; short delay
     323/     35B : C4 00               		ldi 	0 												; set the beeper off
     324/     35D : 07                  		cas
     325/     35E : 90 84               		jmp 	__CmdMainLoop1
     326/     360 :                     
     327/     360 :                     ; ****************************************************************************************************************
     328/     360 :                     ;												In line Assembler
     329/     360 :                     ; ****************************************************************************************************************
     330/     360 :                     
     331/     360 :                     __Assembler:
     332/     360 : C1 FF               		ld 		-1(p1) 											; this is the operation code to use.
     333/     362 : CE FF               		st 		@-1(p2) 										; push on the stack.
     334/     364 :                     
     335/     364 : 3F                  		xppc 	p3 												; evaluate (any) parameter if present
     336/     365 : 06                  		csa 													; check carry flag set
     337/     366 : 94 27               		jp 		__ASMNoParameter  								; if clear, no parameter was provided.
     338/     368 :                     
     339/     368 : C4 1C               		ldi 	parPosn & 255
     340/     36A : 31                  		xpal 	p1 												; get the parameter LSB
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 15 - 12/4/2015 10:28:39


     341/     36B : CE FF               		st 		@-1(p2) 										; push that on the stack, set P1 to parPosn
     342/     36D : C4 0C               		ldi 	parPosn / 256
     343/     36F : 35                  		xpah 	p1
     344/     370 : C1 00               		ld 		(p1) 											; read current position
     345/     372 : 31                  		xpal 	p1 												; P1 now points to character.
     346/     373 : C1 00               		ld 		(p1) 											; read character
     347/     375 : E4 21               		xri 	'!'												; is it the label pling ?
     348/     377 : 9C 1E               		jnz 	__ASMContinue 									; we don't need to change this pointer , we should technically.
     349/     379 : C2 00               		ld 		(p2) 											; read the value, which is the label number
     350/     37B : 03                  		scl
     351/     37C : FC 18               		cai 	labelCount 										; is it a valid label number
     352/     37E : 94 D6               		jp 		__CommandError 									; no, beep.
     353/     380 : C2 00               		ld 		(p2) 											; re-read the label number
     354/     382 : 01                  		xae 													; put in E
     355/     383 : C4 0C               		ldi 	Labels/256 										; point p1 to labels
     356/     385 : 35                  		xpah 	p1
     357/     386 : C4 00               		ldi 	Labels&255 
     358/     388 : 31                  		xpal 	p1
     359/     389 : C1 80               		ld 		-0x80(p1) 										; read label indexed using E.
     360/     38B : CA 00               		st 		(p2) 											; save as the operand
     361/     38D : 90 08               		jmp 	__ASMContinue 									; and continue
     362/     38F :                     
     363/     38F :                     __ASMNoParameter:
     364/     38F : C2 00               		ld 		(p2) 											; read the pushed operation code
     365/     391 : D4 80               		ani 	0x80 											; is bit 7 set ?
     366/     393 : 9C C1               		jnz 	__CommandError 									; if it is, we need a parameter
     367/     395 : CE FF               		st 		@-1(p2) 										; push zero on the stack as a dummy parameter.
     368/     397 :                     
     369/     397 :                     __ASMContinue:
     370/     397 : C4 0C               		ldi 	Current/256 									; p3 = &Current Address
     371/     399 : 37                  		xpah 	p3
     372/     39A : C4 19               		ldi 	Current&255
     373/     39C : 33                  		xpal 	p3
     374/     39D :                     
     375/     39D : C3 04               		ld 		modifier-Current(p3) 							; get the modifier (e.g. @,Pn etc.)
     376/     39F : 02                  		ccl
     377/     3A0 : F2 01               		add 	1(p2) 											; add to the opcode and write it back
     378/     3A2 : CA 01               		st 		1(p2)
     379/     3A4 :                     
     380/     3A4 : C3 00               		ld 		(p3) 											; read current address into P1
     381/     3A6 : 31                  		xpal 	p1
     382/     3A7 : C3 01               		ld 		1(p3)
     383/     3A9 : 35                  		xpah 	p1
     384/     3AA :                     
     385/     3AA : C2 01               		ld 		1(p2) 											; read opcode.
     386/     3AC : CD 01               		st 		@1(p1) 											; write out to current address and bump it.
     387/     3AE : 94 1F               		jp 		__ASMExit 										; if +ve then no operand byte, exit.
     388/     3B0 :                     
     389/     3B0 : C2 00               		ld 		(p2) 											; read the operand byte
     390/     3B2 : CD 01               		st 		@1(p1) 											; write that out as well.
     391/     3B4 :                     
     392/     3B4 : C3 04               		ld 		modifier-Current(p3) 							; look at the modifier 
     393/     3B6 : 9C 17               		jnz 	__ASMExit 										; if non zero we don't need to do anything P0 = 00
     394/     3B8 : C2 01               		ld 		1(p2) 											; DLY is a special case
     395/     3BA : E4 8F               		xri 	0x8F 											; where the modifier is zero but not PC relative.
     396/     3BC : 98 11               		jz 		__ASMExit 												
     397/     3BE :                     
     398/     3BE : C1 FF               		ld 		-1(p1) 											; read operand
     399/     3C0 : 02                  		ccl 													; one fewer because we want the current addr+1 low
     400/     3C1 : FB 00               		cad 	(p3) 											; subtract the current address low.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 16 - 12/4/2015 10:28:39


     401/     3C3 : C9 FF               		st 		-1(p1) 											; write it back
     402/     3C5 :                     
     403/     3C5 : C2 01               		ld 		1(p2) 											; read opcode again
     404/     3C7 : D4 F0               		ani 	0xF0 											; is it 9x (a JMP command)
     405/     3C9 : E4 90               		xri 	0x90
     406/     3CB : 9C 02               		jnz 	__ASMExit 										; if not, we are done
     407/     3CD : B9 FF               		dld 	-1(p1) 											; one fewer because of the pre-increment
     408/     3CF :                     __ASMExit:
     409/     3CF : 31                  		xpal 	p1 												; write current address back out
     410/     3D0 : CB 00               		st 		(p3)
     411/     3D2 : 35                  		xpah 	p1
     412/     3D3 : CB 01               		st 		1(p3)
     413/     3D5 : C6 02               		ld 		@2(p2) 											; drop stack values.
     414/     3D7 :                     
     415/     3D7 : 90 0C               		jmp 	__CmdMainLoop2 									; back to command loop
     416/     3D9 :                     
     417/     3D9 :                     ; ****************************************************************************************************************
     418/     3D9 :                     ; ****************************************************************************************************************
     419/     3D9 :                     ;
     420/     3D9 :                     ;												Commands Section
     421/     3D9 :                     ;
     422/     3D9 :                     ; ****************************************************************************************************************
     423/     3D9 :                     ; ****************************************************************************************************************
     424/     3D9 :                     
     425/     3D9 :                     ; ****************************************************************************************************************
     426/     3D9 :                     ;											A : Set Current address
     427/     3D9 :                     ; ****************************************************************************************************************
     428/     3D9 :                     
     429/     3D9 :                     Address_Command:
     430/     3D9 : 3F                  		xppc 	p3 												; get parameter if exists
     431/     3DA : 3F                  		xppc 	p3 												; update current if exists.
     432/     3DB : 90 08               		jmp 	__CmdMainLoop2
     433/     3DD :                     
     434/     3DD :                     __CmdParameterFail:
     435/     3DD : C4 02               		ldi 	2 												; set the beeper on
     436/     3DF : 07                  		cas
     437/     3E0 : 8F FF               		dly 	0xFF 											; short delay
     438/     3E2 : C4 00               		ldi 	0 												; set the beeper off
     439/     3E4 : 07                  		cas
     440/     3E5 :                     __CmdMainLoop2:													; and go back to the start.
     441/     3E5 : C4 87               		ldi 	(CommandMainLoop-1) & 255
     442/     3E7 : 33                  		xpal 	p3
     443/     3E8 : C4 02               		ldi 	(CommandMainLoop-1) / 256
     444/     3EA : 37                  		xpah 	p3
     445/     3EB : 3F                  		xppc 	p3
     446/     3EC :                     
     447/     3EC :                     ; ****************************************************************************************************************
     448/     3EC :                     ;										G : Go (Address must be specified.)
     449/     3EC :                     ; ****************************************************************************************************************
     450/     3EC :                     
     451/     3EC :                     Go_Command:
     452/     3EC : 3F                  		xppc 	p3 												; get parameter, which should exist.
     453/     3ED : 06                  		csa 													; look at CY/L which is set if it was.
     454/     3EE : 94 ED               		jp 		__CmdParameterFail 								; if it is clear, beep an error.
     455/     3F0 : 31                  		xpal 	p1 												; copy P1 to P3
     456/     3F1 : 33                  		xpal 	p3
     457/     3F2 : 35                  		xpah 	p1
     458/     3F3 : 37                  		xpah 	p3
     459/     3F4 : C7 FF               		ld 		@-1(p3) 										; fix up for pre increment
     460/     3F6 : 3F                  		xppc 	p3 												; call the routine.		
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 17 - 12/4/2015 10:28:39


     461/     3F7 :                     __CmdMainLoop3:
     462/     3F7 : 90 EC               		jmp 	__CmdMainLoop2 									; re-enter monitor.
     463/     3F9 :                     
     464/     3F9 :                     ; ****************************************************************************************************************
     465/     3F9 :                     ;			PUT Write to tape : data mandatory, it is the byte count from the current address.
     466/     3F9 :                     ; ****************************************************************************************************************
     467/     3F9 :                     
     468/     3F9 :                     PutTape_Command:
     469/     3F9 : 3F                  		xppc 	p3 												; get the bytes to write.
     470/     3FA : 06                  		csa 													; if CC, no value was provided
     471/     3FB : 94 E0               		jp 		__CmdParameterFail 								; which is an error.
     472/     3FD : 31                  		xpal 	p1 												; store low byte count in -1(P2)
     473/     3FE : CA FF               		st 		-1(p2)
     474/     400 : 35                  		xpah 	p1 												; store high byte count in -2(P2)
     475/     401 : CA FE               		st 		-2(p2)
     476/     403 : 02                  		ccl 													; skip over the update current address
     477/     404 : 3F                  		xppc 	p3 												; this won't update current address as CY/L = 0
     478/     405 : 3F                  		xppc 	p3 												; and load the current address into P1.
     479/     406 : C4 00               		ldi 	0 												; set the output tape bit low
     480/     408 : 01                  		xae
     481/     409 : 19                  		sio
     482/     40A : C4 20               		ldi 	32 												; tape leader
     483/     40C : CA FD               		st 		-3(p2)
     484/     40E :                     _PutTapeLeader:
     485/     40E : 8F FF               		dly 	0xFF
     486/     410 : BA FD               		dld 	-3(p2)
     487/     412 : 9C FA               		jnz 	_PutTapeLeader
     488/     414 :                     _PutTapeByte:													; output byte at P1
     489/     414 : C4 00               		ldi 	0 												; set output bit to 0
     490/     416 : 01                  		xae 	
     491/     417 : 19                  		sio
     492/     418 : 8F 10               		dly 	tapeDelay * 4 									; 0 continuation bit + gap between tapes with no signal 
     493/     41A : C4 01               		ldi 	0x1 											; set bit high
     494/     41C : 01                  		xae
     495/     41D : 19                  		sio 
     496/     41E : C4 00               		ldi 	0
     497/     420 : 8F 04               		dly 	tapeDelay 										; output the start bit.
     498/     422 : C5 01               		ld 		@1(p1) 											; read the byte and put it in E.
     499/     424 : 01                  		xae
     500/     425 : C4 08               		ldi 	8 												; output 8 bits
     501/     427 : CA FD               		st 		-3(p2)
     502/     429 :                     _PutTapeBit:
     503/     429 : 19                  		sio 													; output MSB and shift
     504/     42A : C4 00               		ldi 	0
     505/     42C : 8F 04               		dly 	tapeDelay 								
     506/     42E : BA FD               		dld 	-3(p2) 											; do all 8 bits.
     507/     430 : 9C F7               		jnz 	_PutTapeBit
     508/     432 : BA FF               		dld 	-1(p2) 											; decrement counter
     509/     434 : 9C DE               		jnz 	_PutTapeByte
     510/     436 : BA FE               		dld 	-2(p2) 											; note MSB goes 0 to -1 when finished.
     511/     438 : 94 DA               		jp 		_PutTapeByte
     512/     43A : C4 01               		ldi 	0x01 											; add the termination bit.
     513/     43C : 01                  		xae
     514/     43D : 19                  		sio
     515/     43E : C4 00               		ldi 	0 												; put that out.
     516/     440 : 8F 04               		dly 	TapeDelay
     517/     442 : C4 00               		ldi 	0 												; and set the leve back to 0
     518/     444 : 01                  		xae 
     519/     445 : 19                  		sio
     520/     446 :                     __CmdMainLoop4:
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 18 - 12/4/2015 10:28:39


     521/     446 : 90 AF               		jmp 	__CmdMainLoop3
     522/     448 :                     
     523/     448 :                     __CmdParameterFail1:
     524/     448 : 90 93               		jmp 	__CmdParameterFail
     525/     44A :                     
     526/     44A :                     ; ****************************************************************************************************************
     527/     44A :                     ;						GET [addr] load tape to current position or given address.
     528/     44A :                     ; ****************************************************************************************************************
     529/     44A :                     
     530/     44A :                     LoadTape_Command:
     531/     44A : 3F                  		xppc	p3 												; get parameter
     532/     44B : 3F                  		xppc 	p3												; update current address
     533/     44C : 3F                  		xppc 	p3 												; current address to P1.
     534/     44D : C4 08               		ldi 	0x8 											; point P3 to the keyboard.
     535/     44F : 37                  		xpah 	p3
     536/     450 :                     __GetTapeWait:
     537/     450 : C3 00               		ld 		0(p3) 											; check keyboard break
     538/     452 : D4 80               		ani 	0x80
     539/     454 : 9C F2               		jnz 	__CmdParameterFail1
     540/     456 : 19                  		sio 													; wait for the start bit, examine tape in.
     541/     457 : 40                  		lde 
     542/     458 : 94 F6               		jp 		__GetTapeWait
     543/     45A : 8F 06               		dly 	tapeDelay * 3 / 2 								; half way into the first bit.
     544/     45C : C4 08               		ldi 	8 												; read in 8 bits.
     545/     45E : CA FF               		st 		-1(p2)
     546/     460 :                     __GetTapeBits:
     547/     460 : 19                  		sio 													; read in one bit
     548/     461 : C4 00               		ldi 	0
     549/     463 : 8F 04               		dly 	tapeDelay 										; delay to next bit
     550/     465 : BA FF               		dld 	-1(p2) 											; read 8 bits.
     551/     467 : 9C F7               		jnz 	__GetTapeBits 
     552/     469 : 40                  		lde 													; store byte at current address
     553/     46A : CD 01               		st 		@1(p1)
     554/     46C : 19                  		sio 													; read in the byte, which is zero if continuing.
     555/     46D : 40                  		lde  													; examine bit 7 shifted in.
     556/     46E : 94 E0               		jp 		__GetTapeWait 									; if zero, wait for the next start bit.
     557/     470 :                     __CmdMainLoop5:
     558/     470 : 90 D4               		jmp 	__CmdMainLoop4
     559/     472 :                     
     560/     472 :                     ; ****************************************************************************************************************
     561/     472 :                     ;										L : nn Set Label to current address
     562/     472 :                     ; ****************************************************************************************************************
     563/     472 :                     
     564/     472 :                     Label_Command:
     565/     472 : 3F                  		xppc 	p3 												; get parameter
     566/     473 : 06                  		csa 													; check it exists, CY/L must be set
     567/     474 : 94 D2               		jp 		__CmdParameterFail1
     568/     476 : 31                  		xpal 	p1 												; get into A
     569/     477 : 01                  		xae 													; put into E
     570/     478 : 40                  		lde 													; get back
     571/     479 : 03                  		scl
     572/     47A : FC 18               		cai 	labelCount 										; check is < number of labels
     573/     47C : 94 CA               		jp 		__CmdParameterFail1
     574/     47E :                     
     575/     47E : C4 0C               		ldi 	Current/256 									; point P1 to current address
     576/     480 : 35                  		xpah 	p1
     577/     481 : C4 19               		ldi 	Current&255
     578/     483 : 31                  		xpal 	p1
     579/     484 : C1 00               		ld 		(p1) 											; read current address
     580/     486 : 31                  		xpal 	p1 												; save in P1.Low
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 19 - 12/4/2015 10:28:39


     581/     487 : C4 00               		ldi 	Labels&255 										; get labels low byte in same page as current address
     582/     489 : 02                  		ccl
     583/     48A : 70                  		ade 													; add label # to it
     584/     48B : 31                  		xpal 	p1 												; put in P1.L and restore current address low
     585/     48C : C9 00               		st 		(p1) 											; store current address low in label space.
     586/     48E : 90 E0               		jmp 	__CmdMainLoop5 									; and exit.
     587/     490 :                     
     588/     490 :                     ; ****************************************************************************************************************
     589/     490 :                     ;											M :	Dump Memory
     590/     490 :                     ; ****************************************************************************************************************
     591/     490 :                     
     592/     490 :                     MemoryDump_Command:
     593/     490 : 3F                  		xppc 	p3 												; get parameter if exists
     594/     491 : 3F                  		xppc 	p3 												; update current if exists.
     595/     492 : C4 07               		ldi 	7 												; print seven rows
     596/     494 : CE FF               		st 		@-1(p2)
     597/     496 :                     __DCLoop:
     598/     496 : C4 06               		ldi 	(PrintAddressData-1)/256						; print one row of address and data.
     599/     498 : 37                  		xpah 	p3
     600/     499 : C4 48               		ldi 	(PrintAddressData-1)&255
     601/     49B : 33                  		xpal 	p3
     602/     49C : C4 04               		ldi 	4
     603/     49E : 3F                  		xppc 	p3
     604/     49F : C4 0C               		ldi 	Current/256 									; point P1 to current
     605/     4A1 : 35                  		xpah 	p1
     606/     4A2 : C4 19               		ldi 	Current&255 
     607/     4A4 : 31                  		xpal 	p1
     608/     4A5 : C1 00               		ld 		0(p1) 											; add 4 to current address
     609/     4A7 : 02                  		ccl
     610/     4A8 : F4 04               		adi 	4
     611/     4AA : C9 00               		st 		0(p1)
     612/     4AC : C1 01               		ld 		1(p1)
     613/     4AE : F4 00               		adi 	0
     614/     4B0 : C9 01               		st 		1(p1)
     615/     4B2 : BA 00               		dld 	(p2) 											; do it 7 times
     616/     4B4 : 9C E0               		jnz 	__DCLoop
     617/     4B6 : C6 01               		ld 		@1(p2) 											; fix up stack.
     618/     4B8 :                     __CmdMainLoop6:
     619/     4B8 : 90 B6               		jmp 	__CmdMainLoop5
     620/     4BA :                     
     621/     4BA :                     
     622/     4BA :                     ; ****************************************************************************************************************
     623/     4BA :                     ;								B: Enter Bytes (no address, sequence of byte data)
     624/     4BA :                     ; ****************************************************************************************************************
     625/     4BA :                     
     626/     4BA :                     EnterBytes_Command:
     627/     4BA : C4 7B               		ldi 	(GetParameter-1) & 255 							; P3 = Get Parameter routine
     628/     4BC : 33                  		xpal 	p3
     629/     4BD : C4 06               		ldi 	(GetParameter-1) / 256 	
     630/     4BF : 37                  		xpah 	p3
     631/     4C0 : 3F                  		xppc 	p3 												; get the parameter.
     632/     4C1 : 06                  		csa 													; look at carry
     633/     4C2 : 94 AC               		jp 		__CmdMainLoop5 									; carry clear, no value.
     634/     4C4 : C4 0C               		ldi 	Current/256 									; make P1 point to current
     635/     4C6 : 35                  		xpah 	p1
     636/     4C7 : C4 19               		ldi 	Current&255 										
     637/     4C9 : 31                  		xpal 	p1 												; this pulls the byte value into A
     638/     4CA : 01                  		xae 													; save it in E
     639/     4CB : C1 00               		ld 		0(p1) 											; copy address to save to into P3
     640/     4CD : 33                  		xpal 	p3
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 20 - 12/4/2015 10:28:39


     641/     4CE : C1 01               		ld 		1(p1) 
     642/     4D0 : 37                  		xpah 	p3 
     643/     4D1 : 40                  		lde 													; get byte back
     644/     4D2 : CB 00               		st 		(p3) 											; save it in that location
     645/     4D4 : A9 00               		ild 	0(p1) 											; bump current address and go back and try again.
     646/     4D6 : 9C E2               		jnz 	EnterBytes_Command
     647/     4D8 : A9 01               		ild 	1(p1)
     648/     4DA : 90 DE               		jmp 	EnterBytes_Command
     649/     4DC :                     
     650/     4DC :                     ; ****************************************************************************************************************
     651/     4DC :                     ;											D [aaaa] Disassembler
     652/     4DC :                     ; ****************************************************************************************************************
     653/     4DC :                     
     654/     4DC :                     Disassemble_Command:	
     655/     4DC : 3F                  		xppc 	p3 												; evaluate
     656/     4DD : 3F                  		xppc 	p3 												; update current if new value
     657/     4DE : C4 07               		ldi 	7												; instructions to disassemble counter
     658/     4E0 : CE FC               		st 		@-4(p2)											; p2 + 0 = counter p2 + 1 = opcode p2 + 2 = operand
     659/     4E2 :                     __DAssLoop:														; p2 + 3 = opcode - base opcode.
     660/     4E2 : C4 06               		ldi 	(PrintAddressData-1)/256						; print Address only
     661/     4E4 : 37                  		xpah 	p3
     662/     4E5 : C4 48               		ldi 	(PrintAddressData-1)&255
     663/     4E7 : 33                  		xpal 	p3
     664/     4E8 : C4 00               		ldi 	0
     665/     4EA : 3F                  		xppc 	p3
     666/     4EB : C4 0C               		ldi 	Current / 256 									; point P1 to current address
     667/     4ED : 35                  		xpah 	p1
     668/     4EE : C4 19               		ldi 	Current & 255
     669/     4F0 : 31                  		xpal 	p1
     670/     4F1 : C1 00               		ld 		0(p1) 											; load current address into P3
     671/     4F3 : 33                  		xpal 	p3
     672/     4F4 : C1 01               		ld 		1(p1)
     673/     4F6 : 37                  		xpah 	p3
     674/     4F7 : C7 01               		ld 		@1(p3) 											; read opcode
     675/     4F9 : CA 01               		st 		1(p2) 											; save it
     676/     4FB : 94 04               		jp 		__DAssNoOperand 								; if +ve no operand
     677/     4FD : C7 01               		ld 		@1(p3) 											; read operand
     678/     4FF : CA 02               		st 		2(p2) 											; save it
     679/     501 :                     __DAssNoOperand:
     680/     501 : C4 E9               		ldi 	(__CommandListEnd-3) & 255
     681/     503 : 33                  		xpal 	p3 												; update current position, setting P3 to last entry
     682/     504 : C9 00               		st 		0(p1)											; in command table.
     683/     506 : C4 07               		ldi 	(__CommandListEnd-3) / 256
     684/     508 : 37                  		xpah 	p3
     685/     509 : C9 01               		st 		1(p1)
     686/     50B :                     
     687/     50B :                     __DAssFindOpcode: 												; the table is : text (word) opcode (byte)
     688/     50B : C2 01               		ld 		1(p2) 											; get opcode
     689/     50D : E3 02               		xor 	2(p3) 											; check in the same 8 byte page.
     690/     50F : D4 F0               		ani 	0xF0
     691/     511 : 9C 0B               		jnz 	__DAssNextOpcode
     692/     513 : C2 01               		ld 		1(p2) 											; get opcode
     693/     515 : 03                  		scl
     694/     516 : FB 02               		cad 	2(p3) 											; subtract the base opcode.
     695/     518 : CA 03               		st 		3(p2) 											; save a the offset (possible)
     696/     51A : D4 E0               		ani 	0xE0 											; it needs to be 0x20 or less
     697/     51C : 98 08               		jz 		__DAssFoundOpcode 								; if >= 0 then found the correct opcode.
     698/     51E :                     __DAssNextOpcode:
     699/     51E : C7 FD               		ld 		@-3(p3) 										; go to previous entry in table
     700/     520 : 90 E9               		jmp 	__DAssFindOpcode
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 21 - 12/4/2015 10:28:39


     701/     522 :                     
     702/     522 :                     __DAssLoop2:
     703/     522 : 90 BE               		jmp 	__DAssLoop
     704/     524 :                     __CmdMainLoop7:
     705/     524 : 90 92               		jmp 	__CmdMainLoop6
     706/     526 :                     
     707/     526 :                     __DAssFoundOpcode:
     708/     526 : C3 02               		ld 		2(p3) 											; look at opcode that matched.
     709/     528 : D4 87               		ani 	0x87 											; match with 1xxx x100
     710/     52A : E4 84               		xri 	0x84 											; which is all the immediate instructions.		
     711/     52C : 9C 04               		jnz 	__DAssNotImmediate
     712/     52E : C2 03               		ld 		3(p2) 											; only do immediate if base offset is zero
     713/     530 : 9C EC               		jnz 	__DAssNextOpcode 								; fixes C0-C7 being LD, but C4 being LDI.
     714/     532 :                     __DAssNotImmediate:
     715/     532 : C3 00               		ld 		0(p3) 											; save LSB of text on stack
     716/     534 : CE FF               		st 		@-1(p2)
     717/     536 : C3 01               		ld 		1(p3) 											; and the MSB of text on stack
     718/     538 : CE FF               		st 		@-1(p2)
     719/     53A :                     
     720/     53A : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     721/     53C : 37                  		xpah 	p3
     722/     53D : C4 DB               		ldi 	(PrintCharacter-1) & 255 
     723/     53F : 33                  		xpal 	p3
     724/     540 : C4 20               		ldi 	' '												; print a space.
     725/     542 : 3F                  		xppc 	p3
     726/     543 :                     
     727/     543 : C4 03               		ldi 	3 												; print 3 characters
     728/     545 : CE FF               		st 		@-1(p2) 										; so +0 is count, +1 = text MSB, +2 = text LSB
     729/     547 :                     __DAssPrintMnemonic:
     730/     547 : C2 01               		ld 		1(p2) 											; get text MSB which is in bits .xxxxx..
     731/     549 : 1C                  		sr 														; shift right twice.
     732/     54A : 1C                  		sr
     733/     54B : D4 1F               		ani 	0x1F 											; lower 5 bits only
     734/     54D : 98 04               		jz 		__DAssSkipSpace 								; don't print spaces (00000)
     735/     54F : 02                  		ccl 													; make it 7 bit ASCII code.
     736/     550 : F4 40               		adi 	64 							
     737/     552 : 3F                  		xppc 	p3 												; display the character
     738/     553 :                     __DAssSkipSpace:
     739/     553 : C4 05               		ldi 	5 												; now shift the encoded data left 5 times
     740/     555 : CA FF               		st 		-1(p2)
     741/     557 :                     __DAssShiftEncode:
     742/     557 : 02                  		ccl
     743/     558 : C2 02               		ld 		2(p2)
     744/     55A : F2 02               		add 	2(p2)
     745/     55C : CA 02               		st 		2(p2)
     746/     55E : C2 01               		ld 		1(p2)
     747/     560 : F2 01               		add 	1(p2)
     748/     562 : CA 01               		st 		1(p2)
     749/     564 : BA FF               		dld 	-1(p2)
     750/     566 : 9C EF               		jnz 	__DAssShiftEncode
     751/     568 : BA 00               		dld 	0(p2) 											; done all three characters
     752/     56A : 9C DB               		jnz 	__DAssPrintMnemonic 							; if not keep going.
     753/     56C :                     
     754/     56C : C6 03               		ld 		@3(p2) 											; remove mnemonic stuff off the stack.
     755/     56E :                     
     756/     56E : C2 03               		ld 		3(p2) 											; print instruction modifier if required.
     757/     570 : 9C 1F               		jnz 	__DAssPrintModifier
     758/     572 :                     
     759/     572 :                     __DAssPrintOperand:
     760/     572 : C2 01               		ld 		1(p2) 											; get original opcode
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 22 - 12/4/2015 10:28:39


     761/     574 : 94 0A               		jp 		__DAssNext 										; if no operand go to next line of disassembly.
     762/     576 : C4 05               		ldi 	(PrintHexByte-1) / 256 							; set P3 to point to the hex printer
     763/     578 : 37                  		xpah 	p3
     764/     579 : C4 A8               		ldi 	(PrintHexByte-1) & 255
     765/     57B : 33                  		xpal 	p3
     766/     57C : C2 02               		ld 		2(p2) 											; get operand
     767/     57E : 03                  		scl 
     768/     57F : 3F                  		xppc 	p3 												; print it out with a leading space.
     769/     580 :                     
     770/     580 :                     __DAssNext:
     771/     580 : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     772/     582 : 37                  		xpah 	p3
     773/     583 : C4 DB               		ldi 	(PrintCharacter-1) & 255 
     774/     585 : 33                  		xpal 	p3
     775/     586 : C4 0D               		ldi 	13												; print a newline.
     776/     588 : 3F                  		xppc 	p3
     777/     589 :                     
     778/     589 : BA 00               		dld 	0(p2) 											; done all 6 lines
     779/     58B : 9C 95               		jnz 	__DAssLoop2 									; no, go round again.
     780/     58D : C6 04               		ld 		@4(p2) 											; fix up the stack.
     781/     58F : 90 93               		jmp 	__CmdMainLoop7 									; and time to exit.
     782/     591 :                     
     783/     591 :                     
     784/     591 :                     __DAssPrintModifier:
     785/     591 : C4 20               		ldi 	' '												; print leading space
     786/     593 : 3F                  		xppc 	p3
     787/     594 : C2 03               		ld 		3(p2) 											; read modifier
     788/     596 : D4 04               		ani 	0x04 											; is @ bit set
     789/     598 : 98 03               		jz 		__DAssNotAutoIndexed
     790/     59A : C4 40               		ldi 	'@'												; print '@'
     791/     59C : 3F                  		xppc 	p3
     792/     59D :                     __DAssNotAutoIndexed:
     793/     59D : C4 50               		ldi 	'P'												; print 'P'
     794/     59F : 3F                  		xppc 	p3
     795/     5A0 : C2 03               		ld 		3(p2) 											; print pointer register
     796/     5A2 : D4 03               		ani 	3
     797/     5A4 : DC 30               		ori 	'0'
     798/     5A6 : 3F                  		xppc 	p3
     799/     5A7 : 90 C9               		jmp 	__DAssPrintOperand 								; and print operand.
     800/     5A9 :                     
     801/     5A9 :                     
     802/     5A9 :                     ; ****************************************************************************************************************
     803/     5A9 :                     ; ****************************************************************************************************************
     804/     5A9 :                     ;
     805/     5A9 :                     ;						Print A as a hexadecimal 2 digit value. If CY/L set precede with space
     806/     5A9 :                     ;
     807/     5A9 :                     ; ****************************************************************************************************************
     808/     5A9 :                     ; ****************************************************************************************************************
     809/     5A9 :                     
     810/     5A9 :                     PrintHexByte:
     811/     5A9 : CE FF               		st 		@-1(p2) 										; push A and P3, set P3 up to print character
     812/     5AB : C4 05               		ldi 	(PrintCharacter-1)/256
     813/     5AD : 37                  		xpah 	p3
     814/     5AE : CE FF               		st 		@-1(p2)
     815/     5B0 : C4 DB               		ldi 	(PrintCharacter-1)&255
     816/     5B2 : 33                  		xpal 	p3
     817/     5B3 : CE FF               		st 		@-1(p2)
     818/     5B5 : 06                  		csa 													; check carry
     819/     5B6 : 94 03               		jp 		__PHBNoSpace									; if clear, no space.
     820/     5B8 : C4 20               		ldi 	' '												; print leading space
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 23 - 12/4/2015 10:28:39


     821/     5BA : 3F                  		xppc 	p3 
     822/     5BB :                     __PHBNoSpace:
     823/     5BB : C2 02               		ld 		2(p2) 											; read digit
     824/     5BD : 1C                  		sr 														; convert MSB
     825/     5BE : 1C                  		sr
     826/     5BF : 1C                  		sr
     827/     5C0 : 1C                  		sr
     828/     5C1 : 02                  		ccl
     829/     5C2 : EC 90               		dai 	0x90
     830/     5C4 : EC 40               		dai 	0x40
     831/     5C6 : 3F                  		xppc 	p3 												; print
     832/     5C7 : C2 02               		ld 		2(p2) 											; read digit
     833/     5C9 : D4 0F               		ani 	0x0F 											; convert LSB
     834/     5CB : 02                  		ccl
     835/     5CC : EC 90               		dai 	0x90
     836/     5CE : EC 40               		dai 	0x40
     837/     5D0 : 3F                  		xppc 	p3 												; print
     838/     5D1 :                     
     839/     5D1 : C6 01               		ld 		@1(p2) 											; restore P3 & A and Return
     840/     5D3 : 33                  		xpal 	p3
     841/     5D4 : C6 01               		ld 		@1(p2)
     842/     5D6 : 37                  		xpah 	p3
     843/     5D7 : C6 01               		ld 		@1(p2)
     844/     5D9 : 3F                  		xppc 	p3
     845/     5DA : 90 CD               		jmp 	PrintHexByte
     846/     5DC :                     
     847/     5DC :                     ; ****************************************************************************************************************
     848/     5DC :                     ; ****************************************************************************************************************
     849/     5DC :                     ;
     850/     5DC :                     ;		Print Character in A, preserves all registers, re-entrant. Handles 13 (New Line), 8 (Backspace)
     851/     5DC :                     ;		Characters 32 - 95 only.
     852/     5DC :                     ;	
     853/     5DC :                     ;		Rolls to screen top rather than scrolling.
     854/     5DC :                     ;
     855/     5DC :                     ; ****************************************************************************************************************
     856/     5DC :                     ; ****************************************************************************************************************
     857/     5DC :                     
     858/     5DC :                     PrintCharacter:
     859/     5DC : CE FF               		st 		@-1(p2) 										; save A
     860/     5DE : C4 0C               		ldi 	Cursor/256 										; save P1, setting up P1 -> Cursor at same time.
     861/     5E0 : 35                  		xpah 	p1
     862/     5E1 : CE FF               		st 		@-1(p2)
     863/     5E3 : C4 18               		ldi 	Cursor&255
     864/     5E5 : 31                  		xpal 	p1
     865/     5E6 : CE FF               		st 		@-1(p2)
     866/     5E8 : C4 00               		ldi 	0 												; save P3, setting up P3 -> Page 0 (Video RAM Write)
     867/     5EA : 37                  		xpah 	p3
     868/     5EB : CE FF               		st 		@-1(p2)
     869/     5ED : 33                  		xpal 	p3
     870/     5EE : CE FF               		st 		@-1(p2)
     871/     5F0 :                     
     872/     5F0 : C1 00               		ld 		(p1) 											; read cursor position
     873/     5F2 : 33                  		xpal 	p3 												; put in P3.Low
     874/     5F3 :                     
     875/     5F3 : C4 20               		ldi 	' ' 											; erase the cursor.
     876/     5F5 : CB 00               		st 		0(p3)
     877/     5F7 :                     
     878/     5F7 : C2 04               		ld 		4(p2) 											; read character to print.
     879/     5F9 : E4 0D               		xri 	13 												; is it CR ?
     880/     5FB : 98 40               		jz 		__PCNewLine 									; if so, go to new line.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 24 - 12/4/2015 10:28:39


     881/     5FD : E4 05               		xri 	13!8 											; is it Backspace ?
     882/     5FF : 98 30               		jz 		__PCBackSpace
     883/     601 :                     
     884/     601 : C2 04               		ld 		4(p2) 											; get character to print
     885/     603 : D4 3F               		ani 	0x3F 											; make 6 bit ASCII
     886/     605 : CF 01               		st 		@1(p3) 											; write into P3, e.g. the screen and bump it.
     887/     607 : A9 00               		ild 	(p1) 											; increment cursor position and load
     888/     609 : D4 0F               		ani 	15 												; are we at line start ?
     889/     60B : 9C 0C               		jnz 	__PCExit 										; if so, erase the current line.
     890/     60D :                     
     891/     60D :                     __PCBlankNewLine:
     892/     60D : C4 10               		ldi 	16 												; count to 16, the number of spaces to write out.
     893/     60F : CA FF               		st 		-1(p2) 
     894/     611 :                     __PCBlankNewLineLoop:
     895/     611 : C4 20               		ldi 	' '
     896/     613 : CF 01               		st 		@1(p3)
     897/     615 : BA FF               		dld 	-1(p2)
     898/     617 : 9C F8               		jnz 	__PCBlankNewLineLoop
     899/     619 :                     
     900/     619 :                     __PCExit:
     901/     619 : C1 00               		ld 		(p1) 											; read cursor
     902/     61B : 33                  		xpal 	p3 												; put in P3.L
     903/     61C : C4 9B               		ldi 	0x9B 											; shaded block cursor on screen
     904/     61E : CB 00               		st 		(p3)
     905/     620 : C6 01               		ld 		@1(p2)											; restore P3
     906/     622 : 33                  		xpal 	p3
     907/     623 : C6 01               		ld 		@1(p2)
     908/     625 : 37                  		xpah 	p3
     909/     626 : C6 01               		ld 		@1(p2)											; restore P1
     910/     628 : 31                  		xpal 	p1
     911/     629 : C6 01               		ld 		@1(p2)
     912/     62B : 35                  		xpah 	p1
     913/     62C : C6 01               		ld 		@1(p2) 											; restore A and Return.	
     914/     62E : 3F                  		xppc 	p3
     915/     62F : 90 AB               		jmp 	PrintCharacter 									; and it is re-entrant.
     916/     631 :                     
     917/     631 :                     __PCBackSpace:
     918/     631 : 33                  		xpal 	p3 												; get current cursor position
     919/     632 : 98 E5               		jz 		__PCExit 										; if top of screen then exit.
     920/     634 : B9 00               		dld 	(p1) 											; backspace and load cursor
     921/     636 : 33                  		xpal 	p3 												; put in P3
     922/     637 : C4 20               		ldi 	' '												; erase character there
     923/     639 : CB 00               		st 		(p3)
     924/     63B : 90 DC               		jmp 	__PCExit 										; and exit.
     925/     63D :                     
     926/     63D :                     __PCNewLine:
     927/     63D : C1 00               		ld 		(p1) 											; read cursor position
     928/     63F : D4 70               		ani 	0x70 											; line
     929/     641 : 02                  		ccl 													; next line
     930/     642 : F4 10               		adi 	0x10
     931/     644 : C9 00               		st 		(p1) 											; write back
     932/     646 : 33                  		xpal 	p3 												; put in P3.L
     933/     647 : 90 C4               		jmp 	__PCBlankNewLine
     934/     649 :                     
     935/     649 :                     ; ****************************************************************************************************************
     936/     649 :                     ; ****************************************************************************************************************
     937/     649 :                     ;
     938/     649 :                     ;					Print current address followed by A data bytes. Doesn't update current address
     939/     649 :                     ;
     940/     649 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 25 - 12/4/2015 10:28:39


     941/     649 :                     ; ****************************************************************************************************************
     942/     649 :                     
     943/     649 :                     PrintAddressData:
     944/     649 : CE FF               		st 		@-1(p2) 										; save count, we don't restore this.
     945/     64B : C4 05               		ldi 	(PrintHexByte-1)/256 							; save and set up P3
     946/     64D : 37                  		xpah 	p3
     947/     64E : CE FF               		st 		@-1(p2)
     948/     650 : C4 A8               		ldi 	(PrintHexByte-1)&255
     949/     652 : 33                  		xpal 	p3
     950/     653 : CE FF               		st 		@-1(p2)
     951/     655 : C4 0C               		ldi 	current / 256 									; point P1 to current address
     952/     657 : 35                  		xpah 	p1
     953/     658 : C4 19               		ldi 	current & 255
     954/     65A : 31                  		xpal 	p1
     955/     65B : C1 01               		ld 		1(p1) 											; read high byte of address
     956/     65D : 02                  		ccl
     957/     65E : 3F                  		xppc 	p3												; print w/o leading space
     958/     65F : C1 00               		ld 		0(p1)											; read low byte of address
     959/     661 : 02                  		ccl 	
     960/     662 : 3F                  		xppc 	p3 												; print w/o leading space.
     961/     663 : 01                  		xae 													; put in E
     962/     664 : C1 01               		ld 		1(p1) 											; high byte to P1.H
     963/     666 : 35                  		xpah 	p1
     964/     667 : 40                  		lde 													; low byte to P1.H
     965/     668 : 31                  		xpal 	p1
     966/     669 :                     _PADLoop:
     967/     669 : BA 02               		dld 	2(p2) 											; decrement counter
     968/     66B : 94 09               		jp 		_PADPrint 										; if +ve print another byte
     969/     66D :                     
     970/     66D : C6 01               		ld 		@1(p2) 											; restore P3, skipping A hence @2
     971/     66F : 33                  		xpal 	p3
     972/     670 : C6 02               		ld 		@2(p2)
     973/     672 : 37                  		xpah 	p3
     974/     673 : 3F                  		xppc 	p3
     975/     674 : 90 D3               		jmp 	PrintAddressData
     976/     676 :                     
     977/     676 :                     _PADPrint:
     978/     676 : C5 01               		ld 		@1(p1) 											; read byte advance pointer
     979/     678 : 03                  		scl
     980/     679 : 3F                  		xppc 	p3 												; print with space.
     981/     67A : 90 ED               		jmp 	_PADLoop
     982/     67C :                     
     983/     67C :                     ; ****************************************************************************************************************
     984/     67C :                     ;
     985/     67C :                     ;		Look at the parameter string for a parameter, processing @ and Pn as you go, CS if parameter found
     986/     67C :                     ; 		CC otherwise. Return parameter value in P1. Falls through
     987/     67C :                     ;
     988/     67C :                     ; ****************************************************************************************************************
     989/     67C :                     
     990/     67C :                     GetParameter:
     991/     67C : C4 0C               		ldi 	parPosn/256 									; current position into P1
     992/     67E : 35                  		xpah 	p1
     993/     67F : C4 1C               		ldi 	parPosn&255 					
     994/     681 : 31                  		xpal 	p1
     995/     682 : C4 00               		ldi 	0 												; -1(p2) is the low byte result
     996/     684 : CA FF               		st 		-1(p2) 											; -2(p2) is the high byte result
     997/     686 : CA FE               		st 		-2(p2)
     998/     688 :                     
     999/     688 : C1 00               		ld 		(p1) 											; read the current position,P1 points to character
    1000/     68A : 31                  		xpal 	p1 												; when we put it in P1.L
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 26 - 12/4/2015 10:28:39


    1001/     68B :                     
    1002/     68B :                     __GPASkip:														; skip over spaces to first alphanumeric.
    1003/     68B : C1 00               		ld 		(p1) 											; read character
    1004/     68D : 98 7B               		jz 		__GPAExitFail 									; if zero, then end of the input string.
    1005/     68F : C5 01               		ld 		@1(p1) 											; read it, advancing.
    1006/     691 : E4 20               		xri 	32 												; is it space ?
    1007/     693 : 98 F6               		jz 		__GPASkip 
    1008/     695 : E4 60               		xri 	32!'@'											; is it @ ?
    1009/     697 : 98 5E               		jz 		__GPAAtModifier 
    1010/     699 : E4 10               		xri 	'@'!'P' 										; is it P ?
    1011/     69B : 98 4C               		jz 		__GPAPointerModifier
    1012/     69D :                     
    1013/     69D :                     __GPANextCharacter:
    1014/     69D : C1 FF               		ld 		-1(p1) 											; get value back after post increment.
    1015/     69F : 02                  		ccl
    1016/     6A0 : F4 50               		adi 	128-48 											; this will be +ve if A < '0'
    1017/     6A2 : 94 66               		jp 		__GPAExitFail
    1018/     6A4 : FC 09               		cai 	9 												; will be +ve if A < '9', CY/L was clear.	
    1019/     6A6 : 94 0A               		jp 		__GPAFoundHex
    1020/     6A8 : FC 07               		cai 	7 												; will be +ve if A < 'A', CY/L was set
    1021/     6AA : 94 5E               		jp 		__GPAExitFail
    1022/     6AC : F4 79               		adi 	0xFF-0x85-1 									; will be +ve if A > 'F', CY/L was set.
    1023/     6AE : 94 5A               		jp 		__GPAExitFail 					
    1024/     6B0 : F4 76               		adi 	(0x70-0xFA) & 0xFF 								; make the range as below, CY/L was clear
    1025/     6B2 :                     __GPAFoundHex: 													; enter here 0-9 = $76..$7F, A-F = $70..$75
    1026/     6B2 : 02                  		ccl  													; convert that to a hex nibble.
    1027/     6B3 : F4 0A               		adi 	10
    1028/     6B5 : D4 0F               		ani 	0xF
    1029/     6B7 : 01                  		xae 													; save in E, temporarily
    1030/     6B8 : C4 04               		ldi 	4 												; now shift the result 4 bits to the left.
    1031/     6BA : CA FD               		st 		-3(p2) 											; -3(p2) is the counter
    1032/     6BC :                     __GPAShift:
    1033/     6BC : 02                  		ccl
    1034/     6BD : C2 FF               		ld 		-1(p2) 											; shift 16 bit result 1 bit to the left.
    1035/     6BF : F2 FF               		add 	-1(p2)
    1036/     6C1 : CA FF               		st 		-1(p2)
    1037/     6C3 : C2 FE               		ld 		-2(p2)
    1038/     6C5 : F2 FE               		add 	-2(p2)
    1039/     6C7 : CA FE               		st 		-2(p2)
    1040/     6C9 : BA FD               		dld 	-3(p2) 											; do it four times
    1041/     6CB : 9C EF               		jnz 	__GPAShift 	
    1042/     6CD : C2 FF               		ld 		-1(p2) 											; Or E into the LSB
    1043/     6CF : 58                  		ore
    1044/     6D0 : CA FF               		st 		-1(p2)
    1045/     6D2 :                     
    1046/     6D2 : C5 01               		ld 		@1(p1) 											; look at next character, post incrementing.
    1047/     6D4 : 03                  		scl
    1048/     6D5 : FC 22               		cai 	34 												; if it is after space and ! (label marker)
    1049/     6D7 : 94 C4               		jp 		__GPANextCharacter 								; go back and put it in place.
    1050/     6D9 :                     
    1051/     6D9 : C5 FF               		ld 		@-1(p1) 										; undo the increment, incase we've just read zero.
    1052/     6DB :                     
    1053/     6DB : C4 1C               		ldi 	parPosn & 255 									; put the parPosn address in P1.L, new posn into A
    1054/     6DD : 31                  		xpal 	p1
    1055/     6DE : C9 00               		st 		(p1) 											; and write it back
    1056/     6E0 : C2 FF               		ld 		-1(p2) 											; put the result into P1
    1057/     6E2 : 31                  		xpal 	p1
    1058/     6E3 : C2 FE               		ld 		-2(p2)
    1059/     6E5 : 35                  		xpah 	p1
    1060/     6E6 : 03                  		scl 													; set CY/L to indicate okay
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 27 - 12/4/2015 10:28:39


    1061/     6E7 : 90 22               		jmp 	__GPAExit
    1062/     6E9 :                     
    1063/     6E9 :                     __GPAPointerModifier:
    1064/     6E9 : C1 00               		ld 		(p1) 											; read P<something> ?
    1065/     6EB : D4 FC               		ani 	0xFC 											; is it '0' .. '3'?
    1066/     6ED : E4 30               		xri 	'0'
    1067/     6EF : 9C 19               		jnz 	__GPAExitFail 									; it didn't work, not 0..3
    1068/     6F1 : C5 01               		ld 		@1(p1) 											; re-read it and advance
    1069/     6F3 : D4 03               		ani 	3												; lower 2 bits only
    1070/     6F5 : 90 02               		jmp 	__GPAAdjustModifier
    1071/     6F7 :                     __GPAAtModifier:
    1072/     6F7 : C4 04               		ldi 	4 												; set modifier adjustment to +4
    1073/     6F9 :                     __GPAAdjustModifier:
    1074/     6F9 : CA FD               		st 		-3(p2) 
    1075/     6FB : C4 1D               		ldi 	modifier & 255 									; point P1 to modifier, save current address in E
    1076/     6FD : 31                  		xpal 	p1
    1077/     6FE : 01                  		xae 
    1078/     6FF : C1 00               		ld 		(p1) 											; read modifier
    1079/     701 : 02                  		ccl
    1080/     702 : F2 FD               		add 	-3(p2) 											; add the modifying value to it.
    1081/     704 : C9 00               		st 		(p1) 											; write modifier.
    1082/     706 : 40                  		lde 													; restore current address to P1.L
    1083/     707 : 31                  		xpal 	p1
    1084/     708 : 90 81               		jmp 	__GPASkip 										; go back to skip over.
    1085/     70A :                     
    1086/     70A :                     __GPAExitFail:
    1087/     70A : 02                  		ccl 													; carry clear, e.g. nothing read in / error.
    1088/     70B :                     __GPAExit:
    1089/     70B : 3F                  		xppc 	p3
    1090/     70C :                     
    1091/     70C :                     ; ****************************************************************************************************************
    1092/     70C :                     ;
    1093/     70C :                     ;		Store parameter value in P1 in the current address, if CS. Falls through.
    1094/     70C :                     ;
    1095/     70C :                     ; ****************************************************************************************************************
    1096/     70C :                     
    1097/     70C :                     UpdateCurrentAddress:
    1098/     70C : 06                  		csa 													; get status reg
    1099/     70D : 94 0C               		jp 		__UCAExit 										; if carry flag clear then exit.
    1100/     70F :                     
    1101/     70F : C4 19               		ldi 	current & 255 									; current address to P1.L, acquired address to E
    1102/     711 : 31                  		xpal 	p1
    1103/     712 : 01                  		xae
    1104/     713 : C4 0C               		ldi 	current / 256 									; current address to P1.H, acquired to A
    1105/     715 : 35                  		xpah 	p1
    1106/     716 : C9 01               		st 		1(p1) 											; store address back
    1107/     718 : 40                  		lde
    1108/     719 : C9 00               		st 		0(p1)
    1109/     71B :                     __UCAExit:
    1110/     71B : 3F                  		xppc 	p3
    1111/     71C :                     
    1112/     71C :                     ; ****************************************************************************************************************
    1113/     71C :                     ;
    1114/     71C :                     ;		Get current address into P1.
    1115/     71C :                     ;
    1116/     71C :                     ; ****************************************************************************************************************
    1117/     71C :                     
    1118/     71C :                     GetCurrentAddress:
    1119/     71C : C4 0C               		ldi 	current/256 									; current address ptr in P1
    1120/     71E : 35                  		xpah 	p1
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 28 - 12/4/2015 10:28:39


    1121/     71F : C4 19               		ldi 	current&255
    1122/     721 : 31                  		xpal 	p1
    1123/     722 : C1 00               		ld 		0(p1) 											; low byte to E
    1124/     724 : 01                  		xae
    1125/     725 : C1 01               		ld 		1(p1) 											; high byte to A
    1126/     727 : 35                  		xpah 	p1 												; then to P1.H
    1127/     728 : 40                  		lde 													; low byte to P1.L
    1128/     729 : 31                  		xpal 	p1 
    1129/     72A : 3F                  		xppc 	p3
    1130/     72B :                     
    1131/     72B :                     ; ****************************************************************************************************************
    1132/     72B :                     ;
    1133/     72B :                     ;											List of commands and Jump Table
    1134/     72B :                     ;
    1135/     72B :                     ; ****************************************************************************************************************
    1136/     72B :                     
    1137/     72B :                     		include commands.inc 									; must be at the end, so the command table is in
(1)    1/     747 :                             org 0x0747
(1)    2/     747 :                     ;
(1)    3/     747 :                     ; 	This file is generated automatically by gencommands.py
(1)    4/     747 :                     ;
(1)    5/     747 :                     __CommandList:
(1)    6/     747 : 94 21                       dw    0x2194 ; HLT
(1)    7/     749 : 00                          db    0x00
(1)    8/     74A : 25 60                       dw    0x6025 ; XAE
(1)    9/     74C : 01                          db    0x01
(1)   10/     74D : 6C 0C                       dw    0x0c6c ; CCL
(1)   11/     74F : 02                          db    0x02
(1)   12/     750 : 6C 4C                       dw    0x4c6c ; SCL
(1)   13/     752 : 03                          db    0x03
(1)   14/     753 : 2E 11                       dw    0x112e ; DIN
(1)   15/     755 : 04                          db    0x04
(1)   16/     756 : AE 24                       dw    0x24ae ; IEN
(1)   17/     758 : 05                          db    0x05
(1)   18/     759 : 61 0E                       dw    0x0e61 ; CSA
(1)   19/     75B : 06                          db    0x06
(1)   20/     75C : 33 0C                       dw    0x0c33 ; CAS
(1)   21/     75E : 07                          db    0x07
(1)   22/     75F : F0 39                       dw    0x39f0 ; NOP
(1)   23/     761 : 08                          db    0x08
(1)   24/     762 : 2F 4D                       dw    0x4d2f ; SIO
(1)   25/     764 : 19                          db    0x19
(1)   26/     765 : 72 02                       dw    0x0272 ; SR
(1)   27/     767 : 1C                          db    0x1c
(1)   28/     768 : 4C 4E                       dw    0x4e4c ; SRL
(1)   29/     76A : 1D                          db    0x1d
(1)   30/     76B : 52 02                       dw    0x0252 ; RR
(1)   31/     76D : 1E                          db    0x1e
(1)   32/     76E : 4C 4A                       dw    0x4a4c ; RRL
(1)   33/     770 : 1F                          db    0x1f
(1)   34/     771 : 0D 00                       dw    0x000d ; M
(1)   35/     773 : 20                          db    0x20
(1)   36/     774 : 01 00                       dw    0x0001 ; A
(1)   37/     776 : 21                          db    0x21
(1)   38/     777 : 07 00                       dw    0x0007 ; G
(1)   39/     779 : 22                          db    0x22
(1)   40/     77A : B4 42                       dw    0x42b4 ; PUT
(1)   41/     77C : 23                          db    0x23
(1)   42/     77D : B4 1C                       dw    0x1cb4 ; GET
(1)   43/     77F : 24                          db    0x24
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 29 - 12/4/2015 10:28:39


(1)   44/     780 : 03 00                       dw    0x0003 ; C
(1)   45/     782 : 25                          db    0x25
(1)   46/     783 : 02 00                       dw    0x0002 ; B
(1)   47/     785 : 26                          db    0x26
(1)   48/     786 : 0C 00                       dw    0x000c ; L
(1)   49/     788 : 27                          db    0x27
(1)   50/     789 : 04 00                       dw    0x0004 ; D
(1)   51/     78B : 28                          db    0x28
(1)   52/     78C : 0C 62                       dw    0x620c ; XPL
(1)   53/     78E : 30                          db    0x30
(1)   54/     78F : 08 62                       dw    0x6208 ; XPH
(1)   55/     791 : 34                          db    0x34
(1)   56/     792 : 03 62                       dw    0x6203 ; XPC
(1)   57/     794 : 3C                          db    0x3c
(1)   58/     795 : 85 30                       dw    0x3085 ; LDE
(1)   59/     797 : 40                          db    0x40
(1)   60/     798 : C5 05                       dw    0x05c5 ; ANE
(1)   61/     79A : 50                          db    0x50
(1)   62/     79B : 45 3E                       dw    0x3e45 ; ORE
(1)   63/     79D : 58                          db    0x58
(1)   64/     79E : 45 62                       dw    0x6245 ; XRE
(1)   65/     7A0 : 60                          db    0x60
(1)   66/     7A1 : 25 10                       dw    0x1025 ; DAE
(1)   67/     7A3 : 68                          db    0x68
(1)   68/     7A4 : 85 04                       dw    0x0485 ; ADE
(1)   69/     7A6 : 70                          db    0x70
(1)   70/     7A7 : 25 0C                       dw    0x0c25 ; CAE
(1)   71/     7A9 : 78                          db    0x78
(1)   72/     7AA : 99 11                       dw    0x1199 ; DLY
(1)   73/     7AC : 8F                          db    0x8f
(1)   74/     7AD : B0 29                       dw    0x29b0 ; JMP
(1)   75/     7AF : 90                          db    0x90
(1)   76/     7B0 : 50 01                       dw    0x0150 ; JP
(1)   77/     7B2 : 94                          db    0x94
(1)   78/     7B3 : 5A 01                       dw    0x015a ; JZ
(1)   79/     7B5 : 98                          db    0x98
(1)   80/     7B6 : DA 29                       dw    0x29da ; JNZ
(1)   81/     7B8 : 9C                          db    0x9c
(1)   82/     7B9 : 84 25                       dw    0x2584 ; ILD
(1)   83/     7BB : A8                          db    0xa8
(1)   84/     7BC : 84 11                       dw    0x1184 ; DLD
(1)   85/     7BE : B8                          db    0xb8
(1)   86/     7BF : 84 01                       dw    0x0184 ; LD
(1)   87/     7C1 : C0                          db    0xc0
(1)   88/     7C2 : 89 30                       dw    0x3089 ; LDI
(1)   89/     7C4 : C4                          db    0xc4
(1)   90/     7C5 : 74 02                       dw    0x0274 ; ST
(1)   91/     7C7 : C8                          db    0xc8
(1)   92/     7C8 : C4 05                       dw    0x05c4 ; AND
(1)   93/     7CA : D0                          db    0xd0
(1)   94/     7CB : C9 05                       dw    0x05c9 ; ANI
(1)   95/     7CD : D4                          db    0xd4
(1)   96/     7CE : F2 01                       dw    0x01f2 ; OR
(1)   97/     7D0 : D8                          db    0xd8
(1)   98/     7D1 : 49 3E                       dw    0x3e49 ; ORI
(1)   99/     7D3 : DC                          db    0xdc
(1)  100/     7D4 : F2 61                       dw    0x61f2 ; XOR
(1)  101/     7D6 : E0                          db    0xe0
(1)  102/     7D7 : 49 62                       dw    0x6249 ; XRI
(1)  103/     7D9 : E4                          db    0xe4
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 30 - 12/4/2015 10:28:39


(1)  104/     7DA : 24 10                       dw    0x1024 ; DAD
(1)  105/     7DC : E8                          db    0xe8
(1)  106/     7DD : 29 10                       dw    0x1029 ; DAI
(1)  107/     7DF : EC                          db    0xec
(1)  108/     7E0 : 84 04                       dw    0x0484 ; ADD
(1)  109/     7E2 : F0                          db    0xf0
(1)  110/     7E3 : 89 04                       dw    0x0489 ; ADI
(1)  111/     7E5 : F4                          db    0xf4
(1)  112/     7E6 : 24 0C                       dw    0x0c24 ; CAD
(1)  113/     7E8 : F8                          db    0xf8
(1)  114/     7E9 : 29 0C                       dw    0x0c29 ; CAI
(1)  115/     7EB : FC                          db    0xfc
(1)  116/     7EC :                     __CommandListEnd:
(1)  117/     7EC : 00 00                       dw    0x0000 ; End Marker	
(1)  118/     7EE :                     
(1)  119/     7EE :                     __CommandTable:
(1)  120/     7EE : 90 04                       dw    MemoryDump_Command
(1)  121/     7F0 : D9 03                       dw    Address_Command
(1)  122/     7F2 : EC 03                       dw    Go_Command
(1)  123/     7F4 : F9 03                       dw    PutTape_Command
(1)  124/     7F6 : 4A 04                       dw    LoadTape_Command
(1)  125/     7F8 : 20 02                       dw    ClearScreen_Command
(1)  126/     7FA : BA 04                       dw    EnterBytes_Command
(1)  127/     7FC : 72 04                       dw    Label_Command
(1)  128/     7FE : DC 04                       dw    Disassemble_Command
(1)  129/     800 :                     
    1138/     800 :                     																; the same page.
    1139/     800 :                     
    1140/     800 :                     ; ****************************************************************************************************************
    1141/     800 :                     ;
    1142/     800 :                     ;													Tape Format. 
    1143/     800 :                     ;
    1144/     800 :                     ; ****************************************************************************************************************
    1145/     800 :                     ;
    1146/     800 :                     ;		1 x start bit 		'1' value is held for period of time.
    1147/     800 :                     ;		8 x data bits  		'0 or 1' value is held for a period of time.
    1148/     800 :                     ;		1 x continuation	'0' if another bit follows, '1' if end.
    1149/     800 :                     ;		at least 2 bit times between bytes.
    1150/     800 :                     ;
    1151/     800 :                     ;		Use DLY 4 with A = 0 (DLY 6 to skip half-start)
    1152/     800 :                     ; 		= 13 + 2 * 0 + 514 * 4 microcycles
    1153/     800 :                     ;		= 2,069 microcycles
    1154/     800 :                     ;	
    1155/     800 :                     ;		which is about 240 bits per second.
    1156/     800 :                     ;
    1157/     800 :                     ; ****************************************************************************************************************
    1158/     800 :                     ;
    1159/     800 :                     ;												Monitor Commands
    1160/     800 :                     ;
    1161/     800 :                     ; ****************************************************************************************************************
    1162/     800 :                     ;
    1163/     800 :                     ;		A [aaaa] 			Set current address to aaaa
    1164/     800 :                     ;		B [cc] [dd] [ee]..	Put Bytes cc dd ee etc. in memory from current address onwards.
    1165/     800 :                     ; 		C 					Clear screen
    1166/     800 :                     ;		D [aaaa] 			Disassemble from aaaa (7 lines of disassembly)
    1167/     800 :                     ;		G aaaa 				Run from address - address must be given - return with XPPC P3
    1168/     800 :                     ; 		L n 				Set label n to the current address (up to 24 labels 00-17)
    1169/     800 :                     ; 		M [aaaa] 			Memory dump from current address/aaaa (7 lines, 4 bytes per line)
    1170/     800 :                     ; 		GET [aaaa] 			Load tape to current address/aaa
    1171/     800 :                     ;		PUT [nnnn]			Write nnnn bytes from current address onwards to tape.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 31 - 12/4/2015 10:28:39


    1172/     800 :                     ;
    1173/     800 :                     ;		Command Line Assembler:
    1174/     800 :                     ;
    1175/     800 :                     ;		Standard SC/MP mnemonics, except for XPAH, XPAL, XPPC, HALT and DINT which are XPH XPL XPC HLT DIN
    1176/     800 :                     ;		respectively (4 character mnemonics not supported)
    1177/     800 :                     ;
    1178/     800 :                     ;		Address modes are written as such:
    1179/     800 :                     ;
    1180/     800 :                     ;		Direct:			LD 	address 					(offset auto calculated, also for jump)
    1181/     800 :                     ;		Indexed:		LD  P1 7 						(normally ld 7(p1))
    1182/     800 :                     ;		Immediate:		DLY 42 					
    1183/     800 :                     ;		AutoIndexed:	LD @P1 4 						(normally ld @4(p1))
    1184/     800 :                     ;
    1185/     800 :                     ;		Labels are accessed via the pling, so to jump to label 4 rather than address 4 you write
    1186/     800 :                     ;
    1187/     800 :                     ;		JMP 4!
    1188/     800 :                     ;
    1189/     800 :                     ;		Documentation of the Mathematics functions are in the included file maths.asm. Sort of.
    1190/     800 :                     ;
    1191/     800 :                     ; ****************************************************************************************************************
    1192/     800 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 32 - 12/4/2015 10:28:39


  symbol table (* = unused):
  ------------------------

 ADDRESS_COMMAND :              3D9 C |  AHI [SCMPMULTIPLY] :             3 - |
 ALO [SCMPMULTIPLY] :             2 - | *ARCHITECTURE :  i386-unknown-win32 - |
 BHI [SCMPMULTIPLY] :             1 - | *BIGENDIAN :                      0 - |
 BITHI [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFFF - |
 BITLO [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFFE - |
 BLO [SCMPMULTIPLY] :             0 - |  BOOTMONITOR :                  206 C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CLEARSCREENLOOP :              225 C |  CLEARSCREEN_COMMAND :          220 C |
 CODESTART :                    C2E - |  COMMANDMAINLOOP :              288 C |
*CONSTPI :        3.141592653589793 - |  CURRENT :                      C19 - |
 CURSOR :                       C18 - | *DATE :                   12/4/2015 - |
 DENOMINATORHI [SCMPDIVIDE] :     1 - |  DENOMINATORLO [SCMPDIVIDE] :     0 - |
 DIGITCOUNT [SCMPTOINTEGER] :                              FFFFFFFFFFFFFFFF - |
 DISASSEMBLE_COMMAND :          4DC C |  ENTERBYTES_COMMAND :           4BA C |
 ETEMP [SCMPDIVIDE] :                                      FFFFFFFFFFFFFFF8 - |
 EXTRACT5BIT :                  2F3 C | *FALSE :                          0 - |
 FINDTOPMEMORY :                218 C | *FULLPMMU :                       1 - |
*GETCURRENTADDRESS :            71C C |  GETPARAMETER :                 67C C |
 GOBOOT :                         5 C |  GO_COMMAND :                   3EC C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - |  INITIALBEEP :                  27B C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 ISINIT :                       C1B - |  KBDBUFFER :                    C1E - |
 KBDBUFFERLN :                   10 - |  KEYBOARDLOOP :                 29D C |
 LABELCOUNT :                    18 - |  LABELS :                       C00 - |
 LABEL_COMMAND :                472 C | *LISTON :                         1 - |
 LOADTAPE_COMMAND :             44A C | *MACEXP :                         1 - |
 MATHS :                         48 C |  MATH_ADD :                      6A C |
 MATH_DIVIDE :                  13A C |  MATH_DIVIDE2 :                  D2 C |
 MATH_DIVIDEBYZERO :            137 C | *MATH_ERROR :                    66 C |
 MATH_EXIT :                     67 C |  MATH_EXIT1 :                    D0 C |
 MATH_EXIT3 :                   135 C |  MATH_MULTIPLY :                 8C C |
 MATH_SUBTRACT :                 7A C |  MATH_TOASCII :                   C C |
 MATH_TOINTEGER :                D4 C |  MEMORYDUMP_COMMAND :           490 C |
 MESSAGE :                      25C C |  MESSAGELOOP :                  255 C |
 MODIFIER :                     C1D - | *MOMCPU :                         C - |
*MOMCPUNAME :                 SC/MP - | *NESTMAX :                      100 - |
 NUMERATORHI [SCMPDIVIDE] :       3 - |  NUMERATORLO [SCMPDIVIDE] :       2 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PARPOSN :                      C1C - |  PRINTADDRESSDATA :             649 C |
 PRINTCHARACTER :               5DC C |  PRINTHEXBYTE :                 5A9 C |
 PUTTAPE_COMMAND :              3F9 C |
 QUOTIENTHI [SCMPDIVIDE] :                                 FFFFFFFFFFFFFFFD - |
 QUOTIENTLO [SCMPDIVIDE] :                                 FFFFFFFFFFFFFFFC - |
*RELAXED :                        0 - |
 REMAINDERHI [SCMPDIVIDE] :                                FFFFFFFFFFFFFFFB - |
 REMAINDERLO [SCMPDIVIDE] :                                FFFFFFFFFFFFFFFA - |
 RESULTHI [SCMPMULTIPLY] :                                 FFFFFFFFFFFFFFFF - |
 RESULTHI [SCMPTOINTEGER] :                                FFFFFFFFFFFFFFFE - |
 RESULTLO [SCMPMULTIPLY] :                                 FFFFFFFFFFFFFFFE - |
 RESULTLO [SCMPTOINTEGER] :                                FFFFFFFFFFFFFFFD - |
 SHIFTCOUNT [SCMPTOINTEGER] :                              FFFFFFFFFFFFFFFC - |
 SIGNCOUNT [SCMPDIVIDE] :                                  FFFFFFFFFFFFFFF9 - |
 TAPEDELAY :                      4 - |
 TEMPHI [SCMPTOINTEGER] :                                  FFFFFFFFFFFFFFFB - |
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 33 - 12/4/2015 10:28:39


 TEMPHI [SCMPDIVIDE] :                                     FFFFFFFFFFFFFFF7 - |
 TEMPLO [SCMPTOINTEGER] :                                  FFFFFFFFFFFFFFFA - |
*TIME :                    10:28:39 - |  TOINT_END [SCMPTOINTEGER] :    127 C |
 TOINT_LOOP [SCMPTOINTEGER] :    DC C |  TOINT_NOADD [SCMPTOINTEGER] :  113 C |
 TOINT_SHIFT [SCMPTOINTEGER] :   F5 C | *TRUE :                           1 - |
*UPDATECURRENTADDRESS :         70C C |  VARBASE :                      C18 - |
*VERSION :                     142F - |  _KBDWAITKEY :                  2A6 C |
 _KBDWAITRELEASE :              2A0 C |  _PADLOOP :                     669 C |
 _PADPRINT :                    676 C |  _PUTTAPEBIT :                  429 C |
 _PUTTAPEBYTE :                 414 C |  _PUTTAPELEADER :               40E C |
 __ASMCONTINUE :                397 C |  __ASMEXIT :                    3CF C |
 __ASMNOPARAMETER :             38F C |  __ASSEMBLER :                  360 C |
 __BOOTMONITOR :                210 C |  __CMDMAINLOOP1 :               2E4 C |
 __CMDMAINLOOP2 :               3E5 C |  __CMDMAINLOOP3 :               3F7 C |
 __CMDMAINLOOP4 :               446 C |  __CMDMAINLOOP5 :               470 C |
 __CMDMAINLOOP6 :               4B8 C |  __CMDMAINLOOP7 :               524 C |
 __CMDPARAMETERFAIL :           3DD C |  __CMDPARAMETERFAIL1 :          448 C |
 __COMMANDERROR :               356 C |  __COMMANDLIST :                747 C |
 __COMMANDLISTEND :             7EC C |  __COMMANDTABLE :               7EE C |
 __DASSFINDOPCODE :             50B C |  __DASSFOUNDOPCODE :            526 C |
 __DASSLOOP :                   4E2 C |  __DASSLOOP2 :                  522 C |
 __DASSNEXT :                   580 C |  __DASSNEXTOPCODE :             51E C |
 __DASSNOOPERAND :              501 C |  __DASSNOTAUTOINDEXED :         59D C |
 __DASSNOTIMMEDIATE :           532 C |  __DASSPRINTMNEMONIC :          547 C |
 __DASSPRINTMODIFIER :          591 C |  __DASSPRINTOPERAND :           572 C |
 __DASSSHIFTENCODE :            557 C |  __DASSSKIPSPACE :              553 C |
 __DCLOOP :                     496 C |
 __DIVIDECOMPLETE [SCMPDIVIDE] : 1D9 C |
 __DIVIDECONTINUE [SCMPDIVIDE] : 1AC C |
 __DIVIDEEXIT [SCMPDIVIDE] :    1C6 C |  __DIVIDELOOP [SCMPDIVIDE] :    17E C |
 __DIVIDENOINCREMAINDER [SCMPDIVIDE] :                                  19B C |
 __DIVIDENOTSIGNED [SCMPDIVIDE] :                                       174 C |
 __DIVIDEREMAINDERGREATER [SCMPDIVIDE] :                                1F1 C |
 __DIVIDEUNSIGNLOOP [SCMPDIVIDE] :                                      15C C |
 __EX5SHIFT :                   2FE C |  __EXTRACTEND :                 314 C |
 __FINDCOMMANDLOOP :            31F C |  __GETTAPEBITS :                460 C |
 __GETTAPEWAIT :                450 C |  __GPAADJUSTMODIFIER :          6F9 C |
 __GPAATMODIFIER :              6F7 C |  __GPAEXIT :                    70B C |
 __GPAEXITFAIL :                70A C |  __GPAFOUNDHEX :                6B2 C |
 __GPANEXTCHARACTER :           69D C |  __GPAPOINTERMODIFIER :         6E9 C |
 __GPASHIFT :                   6BC C |  __GPASKIP :                    68B C |
 __KBDBACKSPACE :               2D8 C |  __KBDEXIT :                    2E6 C |
 __KBDNOTLOWER :                2CC C |  __MATH_EXIT2 [SCMPDIVIDE] :    17C C |
 __MULTIPLYEXIT [SCMPMULTIPLY] : C5 C |  __MULTIPLYLOOP [SCMPMULTIPLY] : 92 C |
 __MULTIPLYNOADD [SCMPMULTIPLY] : AB C |
 __PCBACKSPACE :                631 C |  __PCBLANKNEWLINE :             60D C |
 __PCBLANKNEWLINELOOP :         611 C |  __PCEXIT :                     619 C |
 __PCNEWLINE :                  63D C |  __PHBNOSPACE :                 5BB C |
 __TOASCII_LOOP :                20 C |  __UCAEXIT :                    71B C |

    184 symbols
     31 unused symbols

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 34 - 12/4/2015 10:28:39


  defined macros:
  ---------------

SHIFTLEFT                             | SHIFTRIGHT                           

      2 macros

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 35 - 12/4/2015 10:28:39


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

   1775 lines source file
   1817 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
