 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 1 - 11/30/2015 10:31:02


       1/       0 :                     ; ******************************************************************************************************************
       2/       0 :                     ; ******************************************************************************************************************
       3/       0 :                     ; ******************************************************************************************************************
       4/       0 :                     ;
       5/       0 :                     ;												Machine Language Monitor
       6/       0 :                     ;
       7/       0 :                     ; ******************************************************************************************************************
       8/       0 :                     ; ******************************************************************************************************************
       9/       0 :                     ; ******************************************************************************************************************
      10/       0 :                     
      11/       0 :                     ; TODO: 
      12/       0 :                     ; 		16 bit maths routines.
      13/       0 :                     ; 		Decode addresses on disassembler (?)
      14/       0 :                     ; 		Print message on first clear screen (?)
      15/       0 :                     
      16/       0 :                     		cpu	sc/mp
      17/       0 :                     
      18/       0 : =0xC00              labels 		= 0xC00												; labels, 1 byte each
      19/       0 : =0x20               labelCount 	= 32 												; number of labels (perhaps a bit generous ?)
      20/       0 :                     
      21/       0 : =0xC20              varBase 	= labels+labelCount 								; variables after labels start here.
      22/       0 :                     
      23/       0 : =0xC20              cursor 		= varBase 											; cursor position
      24/       0 : =0xC21              current 	= varBase+1 										; current address (lo,hi)
      25/       0 : =0xC23              parPosn		= varBase+3 										; current param offset in buffer (low addr)
      26/       0 : =0xC24              modifier  	= varBase+4 										; instruction modifier (@,Pn)
      27/       0 : =0xC25              kbdBuffer 	= varBase+5 										; 16 character keyboard buffer
      28/       0 : =0x10               kbdBufferLn = 16 										
      29/       0 :                     
      30/       0 : =0xC35              codeStart 	= kbdBuffer+kbdBufferLn								; code starts here.
      31/       0 :                     
      32/       0 : =0x4                tapeDelay 	= 4 												; DLY parameter for 1 tape bit width.
      33/       0 :                     																; (smaller = faster tape I/O - see file end.)
      34/       0 :                     
      35/       0 :                     		org 	0x0000
      36/       0 : 08                  		nop
      37/       1 :                     
      38/       1 :                     		include maths.asm 										; import the maths routines.
(1)    1/       1 :                     ; ******************************************************************************************************************
(1)    2/       1 :                     ; ******************************************************************************************************************
(1)    3/       1 :                     ;
(1)    4/       1 :                     ;										16 bit Arithmetic routines
(1)    5/       1 :                     ;
(1)    6/       1 :                     ; ******************************************************************************************************************
(1)    7/       1 :                     ; ******************************************************************************************************************
(1)    8/       1 :                     
(1)    9/       1 :                     ;
(1)   10/       1 :                     ;	Priority order : * / + - anything else VTL-2 might use ASCII -> int int -> ASCII
(1)   11/       1 :                     ;
(1)   12/       1 :                     ;	jmp	 	GoBoot 												; this will be at location 1.
(1)   13/       1 : 90 07               	jmp 	Maths 												; maths routine, at location 3.
(1)   14/       3 :                     	; any other routines you care to call.
(1)   15/       3 :                     
(1)   16/       3 :                     GoBoot:
(1)   17/       3 : C4 5D               	ldi 	(BootMonitor-1) & 255 								; jump to Boot Monitor
(1)   18/       5 : 33                  	xpal 	p3
(1)   19/       6 : C4 00               	ldi 	(BootMonitor-1) / 256
(1)   20/       8 : 37                  	xpah 	p3
(1)   21/       9 : 3F                  	xppc 	p3
(1)   22/       A :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 2 - 11/30/2015 10:31:02


(1)   23/       A :                     ; ******************************************************************************************************************
(1)   24/       A :                     ;
(1)   25/       A :                     ;		Maths routines : the (P2) stack functions as a number stack.  So to push $1234 on the stack you do
(1)   26/       A :                     ;
(1)   27/       A :                     ;		ld 	#$12
(1)   28/       A :                     ;		st 	@-1(p2) 					1(p2) is the MSB of TOS
(1)   29/       A :                     ;		ld 	#$34
(1)   30/       A :                     ;		st 	@-1(p2) 					0(p2) is the LSB of TOS
(1)   31/       A :                     ;
(1)   32/       A :                     ;		on entry, A is the function (+,-,*,/ etc.). P2 should be left in the 'correct' state afterwards,
(1)   33/       A :                     ;		so if you add two numbers then p2 will be 2 higher than when the routine was entered.
(1)   34/       A :                     ;
(1)   35/       A :                     ; ******************************************************************************************************************
(1)   36/       A :                     
(1)   37/       A : =0xD                n1 = 13
(1)   38/       A : =0x10               n2 = 16
(1)   39/       A :                     
(1)   40/       A :                     Maths:															; maths support routine.
(1)   41/       A : C4 0C               	ldi 	0xC
(1)   42/       C : 36                  	xpah 	p2
(1)   43/       D : C4 2F               	ldi 	0x2F
(1)   44/       F : 32                  	xpal 	p2
(1)   45/      10 :                     
(1)   46/      10 : C4 00               	ldi 	n2 / 256
(1)   47/      12 : CE FF               	st 		@-1(p2)
(1)   48/      14 : C4 10               	ldi 	n2 & 255
(1)   49/      16 : CE FF               	st 		@-1(p2)
(1)   50/      18 :                     
(1)   51/      18 : C4 00               	ldi 	n1 / 256
(1)   52/      1A : CE FF               	st 		@-1(p2)
(1)   53/      1C : C4 0D               	ldi 	n1 & 255
(1)   54/      1E : CE FF               	st 		@-1(p2)
(1)   55/      20 :                     	
(1)   56/      20 : C4 2A               	ldi 	'*'
(1)   57/      22 :                     
(1)   58/      22 : E4 2B               	xri 	'+'
(1)   59/      24 : 98 0A               	jz 		MATH_Add
(1)   60/      26 : E4 06               	xri 	'+'!'-'
(1)   61/      28 : 98 15               	jz 		MATH_Subtract
(1)   62/      2A : E4 07               	xri 	'-'!'*'
(1)   63/      2C : 98 20               	jz 		MATH_Multiply
(1)   64/      2E :                     
(1)   65/      2E :                     MATH_Exit:
(1)   66/      2E : 90 FE               	jmp  	MATH_Exit
(1)   67/      30 :                     
(1)   68/      30 :                     ; ******************************************************************************************************************
(1)   69/      30 :                     ;														16 Bit Add
(1)   70/      30 :                     ; ******************************************************************************************************************
(1)   71/      30 :                     
(1)   72/      30 :                     MATH_Add:
(1)   73/      30 : 02                  	ccl 										
(1)   74/      31 : C6 01               	ld 		@1(p2) 												; read LSB of TOS and unstack
(1)   75/      33 : F2 01               	add 	1(p2)
(1)   76/      35 : CA 01               	st 		1(p2)
(1)   77/      37 : C6 01               	ld 		@1(p2) 												; read MSB of TOS and unstack
(1)   78/      39 : F2 01               	add 	1(p2)
(1)   79/      3B : CA 01               	st 		1(p2)
(1)   80/      3D : 90 EF               	jmp 	MATH_Exit
(1)   81/      3F :                     
(1)   82/      3F :                     ; ******************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file monitor.asm(maths.asm) - page 3 - 11/30/2015 10:31:02


(1)   83/      3F :                     ;													16 Bit Subtract
(1)   84/      3F :                     ; ******************************************************************************************************************
(1)   85/      3F :                     
(1)   86/      3F :                     MATH_Subtract:
(1)   87/      3F : 03                  	scl 										
(1)   88/      40 : C6 01               	ld 		@1(p2) 												; read LSB of TOS and unstack
(1)   89/      42 : FA 01               	cad 	1(p2)
(1)   90/      44 : CA 01               	st 		1(p2)
(1)   91/      46 : C6 01               	ld 		@1(p2) 												; read MSB of TOS and unstack
(1)   92/      48 : FA 01               	cad 	1(p2)
(1)   93/      4A : CA 01               	st 		1(p2)
(1)   94/      4C : 90 E0               	jmp 	MATH_Exit
(1)   95/      4E :                     
(1)   96/      4E :                     ; ******************************************************************************************************************
(1)   97/      4E :                     ;												16 bit signed multiply
(1)   98/      4E :                     ; ******************************************************************************************************************
(1)   99/      4E :                     
(1)  100/      4E :                     MATH_Multiply:
(1)  101/      4E : C2 02               	ld 		2(p2) 												; copy multiplicand to space below stack
(1)  102/      50 : CA FE               	st 		-2(p2)
(1)  103/      52 : C2 03               	ld 		3(p2)
(1)  104/      54 : CA FF               	st 		-1(p2)
(1)  105/      56 : C4 00               	ldi 	0 													; clear result
(1)  106/      58 : CA 02               	st 		2(p2)
(1)  107/      5A : CA 03               	st 		3(p2)
(1)  108/      5C :                     
(1)  109/      5C : 90 D0               	jmp 	MATH_Exit
      39/      5E :                     
      40/      5E :                     ; ******************************************************************************************************************
      41/      5E :                     ;
      42/      5E :                     ;									Find Top of Memory to initialise the stack.
      43/      5E :                     ;
      44/      5E :                     ; ******************************************************************************************************************
      45/      5E :                     
      46/      5E :                     BootMonitor:
      47/      5E : C4 0F               		ldi 	0x0F 											; point P2 to theoretical top of RAM on basic m/c
      48/      60 : 36                  		xpah 	p2 												; e.g. 0xFFF
      49/      61 : C4 FF               		ldi 	0xFF 											; ideally you'd make this 0x003F and remove the ld
      50/      63 : 32                  		xpal 	p2 												; but the emulators don't do 4+12 math. Only matters here.
      51/      64 : C6 40               		ld 		@64(p2) 										; fix the predecrement (wrap around not emulated)
      52/      66 :                     FindTopMemory:
      53/      66 : C4 A5               		ldi 	0xA5 											; try to write this to memory
      54/      68 : CE C0               		st 		@-64(p2) 										; predecrementing by 64.
      55/      6A : E2 00               		xor 	(p2) 											; did it write correctly.
      56/      6C : 9C F8               		jnz 	FindTopMemory 									; now P2 points to top of memory.
      57/      6E :                     
      58/      6E :                     ; ******************************************************************************************************************
      59/      6E :                     ;
      60/      6E :                     ;									Reset cursor position and current address.
      61/      6E :                     ;
      62/      6E :                     ; ******************************************************************************************************************
      63/      6E :                     
      64/      6E : C4 0C               		ldi 	Current/256 									; set P1 to current address
      65/      70 : 35                  		xpah 	p1
      66/      71 : C4 21               		ldi 	Current&255
      67/      73 : 31                  		xpal 	p1
      68/      74 : C4 35               		ldi 	codeStart & 255 								; reset current address to code start
      69/      76 : CD 01               		st 		@1(p1)
      70/      78 : C4 0C               		ldi 	codeStart / 256
      71/      7A : CD 00               		st 		@(p1)
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 4 - 11/30/2015 10:31:02


      72/      7C :                     
      73/      7C :                     ; ******************************************************************************************************************
      74/      7C :                     ;
      75/      7C :                     ;												Clear the screen
      76/      7C :                     ;
      77/      7C :                     ; ******************************************************************************************************************
      78/      7C :                     
      79/      7C :                     ClearScreen_Command:
      80/      7C : C4 00               		ldi 	0
      81/      7E : 35                  		xpah 	p1
      82/      7F : C4 00               		ldi 	0
      83/      81 :                     ClearScreenLoop:
      84/      81 : 31                  		xpal 	p1												; clear screen
      85/      82 : C4 20               		ldi 	' '
      86/      84 : CD 01               		st 		@1(p1)
      87/      86 : 31                  		xpal 	p1
      88/      87 : 94 F8               		jp 		ClearScreenLoop
      89/      89 : C4 0C               		ldi 	Cursor/256 										; reset the cursor position to TOS
      90/      8B : 35                  		xpah 	p1
      91/      8C : C4 20               		ldi 	Cursor&255
      92/      8E : 31                  		xpal 	p1 
      93/      8F : C4 00               		ldi 	0
      94/      91 : C9 00               		st 		0(p1)											
      95/      93 :                     
      96/      93 :                     ; ****************************************************************************************************************
      97/      93 :                     ;
      98/      93 :                     ;													Main Loop
      99/      93 :                     ;
     100/      93 :                     ; ****************************************************************************************************************
     101/      93 :                     
     102/      93 :                     CommandMainLoop:
     103/      93 : C4 04               		ldi 	(PrintAddressData-1)/256						; print Address only
     104/      95 : 37                  		xpah 	p3
     105/      96 : C4 53               		ldi 	(PrintAddressData-1)&255
     106/      98 : 33                  		xpal 	p3
     107/      99 : C4 00               		ldi 	0
     108/      9B : 3F                  		xppc 	p3
     109/      9C :                     
     110/      9C : C4 03               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     111/      9E : 37                  		xpah 	p3
     112/      9F : C4 E6               		ldi 	(PrintCharacter-1)&255
     113/      A1 : 33                  		xpal 	p3
     114/      A2 : C4 5D               		ldi 	']'												; print the prompt.
     115/      A4 : 3F                  		xppc 	p3
     116/      A5 :                     
     117/      A5 :                     ; ****************************************************************************************************************
     118/      A5 :                     ;
     119/      A5 :                     ;											Keyboard Line Input
     120/      A5 :                     ;
     121/      A5 :                     ; ****************************************************************************************************************
     122/      A5 :                     
     123/      A5 : C4 00               		ldi 	0 												; set E = character position.
     124/      A7 : 01                  		xae 
     125/      A8 :                     KeyboardLoop:
     126/      A8 : C4 08               		ldi 	0x8 											; set P1 to point to keyboard latch
     127/      AA : 35                  		xpah 	p1
     128/      AB :                     _KBDWaitRelease:
     129/      AB : C1 00               		ld 		0(p1) 											; wait for strobe to clear
     130/      AD : 94 02               		jp 		_KBDWaitKey
     131/      AF : 90 FA               		jmp 	_KBDWaitRelease
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 5 - 11/30/2015 10:31:02


     132/      B1 :                     _KBDWaitKey:
     133/      B1 : C1 00               		ld 		0(p1) 											; wait for strobe, i.e. new key
     134/      B3 : 94 FC               		jp 		_KBDWaitKey
     135/      B5 : D4 7F               		ani 	0x7F 											; throw away bit 7
     136/      B7 : CA FF               		st 		-1(p2) 											; save key.
     137/      B9 :                     
     138/      B9 : C4 0C               		ldi 	kbdBuffer/256 									; set P1 = keyboard buffer
     139/      BB : 35                  		xpah 	p1
     140/      BC : C4 25               		ldi 	kbdBuffer&255
     141/      BE : 31                  		xpal 	p1		
     142/      BF :                     
     143/      BF : C2 FF               		ld 		-1(p2) 											; read key
     144/      C1 : E4 08               		xri 	8 												; is it backspace
     145/      C3 : 98 1E               		jz 		__KBDBackSpace
     146/      C5 : E4 05               		xri 	8!13 											; is it CR, then exit
     147/      C7 : 98 28               		jz 		__KBDExit
     148/      C9 :                     
     149/      C9 : 40                  		lde 													; have we a full buffer.
     150/      CA : E4 10               		xri 	kbdBufferLn 									; if so, ignore the key.
     151/      CC : 98 DA               		jz 		KeyboardLoop
     152/      CE :                     
     153/      CE : C2 FF               		ld 		-1(p2) 											; restore the key.
     154/      D0 : 02                  		ccl
     155/      D1 : F4 20               		adi 	0x20											; will make lower case -ve
     156/      D3 : 94 02               		jp 		__KBDNotLower
     157/      D5 : FC 20               		cai 	0x20 											; capitalise
     158/      D7 :                     __KBDNotLower:
     159/      D7 : F4 E0               		adi 	0xE0 											; fix up.
     160/      D9 : C9 80               		st 		-0x80(p1) 										; save in the buffer using E as index.
     161/      DB : 3F                  		xppc 	p3 												; print the character
     162/      DC : 01                  		xae 													; increment E
     163/      DD : 02                  		ccl
     164/      DE : F4 01               		adi 	1
     165/      E0 : 01                  		xae
     166/      E1 : 90 C5               		jmp 	KeyboardLoop 									; and get the next key.
     167/      E3 :                     
     168/      E3 :                     __KBDBackSpace:
     169/      E3 : 40                  		lde 													; get position
     170/      E4 : 98 C2               		jz 		KeyboardLoop 									; can't go back if at beginning
     171/      E6 : 03                  		scl 													; go back 1 from E
     172/      E7 : FC 01               		cai 	1
     173/      E9 : 01                  		xae 
     174/      EA : C4 08               		ldi 	8 												; print a backspace
     175/      EC : 3F                  		xppc 	p3
     176/      ED : 90 B9               		jmp 	KeyboardLoop 									; and go round again.
     177/      EF :                     
     178/      EF :                     __CmdMainLoop1:
     179/      EF : 90 A2               		jmp 	CommandMainLoop
     180/      F1 :                     
     181/      F1 :                     __KBDExit:
     182/      F1 : C9 80               		st 		-0x80(p1) 										; add the ASCIIZ terminator.
     183/      F3 : C4 0D               		ldi 	13												; print a new line.
     184/      F5 : 3F                  		xppc 	p3
     185/      F6 :                     
     186/      F6 :                     ; ****************************************************************************************************************
     187/      F6 :                     ;
     188/      F6 :                     ;						Extract the 5 bit 3 letter (max command value). P1 points to buffer
     189/      F6 :                     ;
     190/      F6 :                     ; ****************************************************************************************************************
     191/      F6 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 6 - 11/30/2015 10:31:02


     192/      F6 : C4 00               		ldi 	0
     193/      F8 : 01                  		xae 													; E contains the LSB of the 5 bit shift
     194/      F9 : 40                  		lde 	
     195/      FA : CA FF               		st 		-1(p2) 											; -1(P2) contains the MSB
     196/      FC : C9 FF               		st 		modifier-kbdBuffer(p1)							; clear the modifier.
     197/      FE :                     Extract5Bit:
     198/      FE : C1 00               		ld 		(p1) 											; look at character
     199/     100 : 02                  		ccl 													; add 128-65, will be +ve if < 64
     200/     101 : F4 3F               		adi 	128-65
     201/     103 : 94 1A               		jp 		__ExtractEnd
     202/     105 : C4 05               		ldi 	5 												; shift current value left 5 times using -2(p2)
     203/     107 : CA FE               		st 		-2(p2)
     204/     109 :                     __Ex5Shift:
     205/     109 : 40                  		lde 													; shift E left into CY/L
     206/     10A : 02                  		ccl
     207/     10B : 70                  		ade 
     208/     10C : 01                  		xae
     209/     10D : C2 FF               		ld 		-1(p2) 											; shift CY/L into -1(p2) and carry/link
     210/     10F : F2 FF               		add 	-1(p2)
     211/     111 : CA FF               		st 		-1(p2)
     212/     113 : BA FE               		dld 	-2(p2) 											; done it 5 times ?
     213/     115 : 9C F2               		jnz 	__Ex5Shift
     214/     117 : C5 01               		ld 		@1(p1) 											; re-read character.
     215/     119 : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     216/     11B : 58                  		ore 													; OR into E
     217/     11C : 01                  		xae
     218/     11D : 90 DF               		jmp 	Extract5Bit 									; go and get the next one.
     219/     11F :                     
     220/     11F :                     __ExtractEnd:
     221/     11F : C4 23               		ldi 	parPosn & 255 									; P1.L = Parameter Position, A = first non cmd char
     222/     121 : 31                  		xpal	p1
     223/     122 : C9 00               		st 		(p1) 											; write to parameter position.
     224/     124 :                     
     225/     124 :                     ; ****************************************************************************************************************
     226/     124 :                     ;
     227/     124 :                     ;						Find command in -1 (P2) (High) E (Low) in Command table
     228/     124 :                     ;	
     229/     124 :                     ; ****************************************************************************************************************
     230/     124 :                     
     231/     124 : C4 47               		ldi 	__commandList & 255 							; point P1 to the command list
     232/     126 : 31                  		xpal 	p1
     233/     127 : C4 07               		ldi 	__commandList / 256 		
     234/     129 : 35                  		xpah 	p1	
     235/     12A :                     __FindCommandLoop:
     236/     12A : C1 00               		ld 		0(p1) 											; reached the end of the table ?
     237/     12C : D9 01               		or 		1(p1)											; which is marked by word 0000
     238/     12E : 98 31               		jz 		__CommandError
     239/     130 : C5 03               		ld 		@3(p1) 											; read low byte, and point to next
     240/     132 : 60                  		xre
     241/     133 : 9C F5               		jnz 	__FindCommandLoop 								; if different to LSB loop back.
     242/     135 : C1 FE               		ld 		-2(p1) 											; read the high byte
     243/     137 : E2 FF               		xor 	-1(p2) 											; if different to the MSB loop back.
     244/     139 : 9C EF               		jnz 	__FindCommandLoop
     245/     13B :                     
     246/     13B :                     ; ****************************************************************************************************************
     247/     13B :                     ;
     248/     13B :                     ;				Found command, figure out if ASM or Command, if Command go to that routine
     249/     13B :                     ;
     250/     13B :                     ; ****************************************************************************************************************
     251/     13B :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 7 - 11/30/2015 10:31:02


     252/     13B : C4 86               		ldi 	(GetParameter-1) & 255 							; point P3 to the get parameter code.
     253/     13D : 33                  		xpal 	p3
     254/     13E : C4 04               		ldi 	(GetParameter-1) / 256
     255/     140 : 37                  		xpah 	p3
     256/     141 :                     
     257/     141 : C1 FF               		ld 		-1(p1) 											; read the operation code.
     258/     143 : D4 F0               		ani 	0xF0 											; look at the m-s-nibble - commands are 0x20.
     259/     145 : E4 20               		xri 	0x20
     260/     147 : 9C 22               		jnz 	__Assembler
     261/     149 :                     
     262/     149 : C1 FF               		ld 		-1(p1) 											; re-read it
     263/     14B : 02                  		ccl
     264/     14C : F1 FF               		add 	-1(p1) 											; double it
     265/     14E : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     266/     150 : F4 EE               		adi 	__CommandTable & 255 							; make P1 point to the command table entry
     267/     152 : 31                  		xpal 	p1
     268/     153 : C4 07               		ldi 	__CommandTable / 256 					
     269/     155 : 35                  		xpah 	p1
     270/     156 : C1 00               		ld 		0(p1) 											; read low address
     271/     158 : 01                  		xae
     272/     159 : C1 01               		ld 		1(p1) 											; read high address
     273/     15B : 35                  		xpah 	p1 												; put in P1.H
     274/     15C : 40                  		lde 													; get low address
     275/     15D : 31                  		xpal 	p1 												; put in P1.L
     276/     15E : C5 FF               		ld 		@-1(p1) 										; fix up for the pre-increment
     277/     160 : 3D                  		xppc 	p1 												; and go there.
     278/     161 :                     
     279/     161 :                     __CommandError: 												; unknown command.
     280/     161 : C4 03               		ldi 	3 												; set the beeper on
     281/     163 : 07                  		cas
     282/     164 : 8F FF               		dly 	0xFF 											; short delay
     283/     166 : C4 00               		ldi 	0 												; set the beeper off
     284/     168 : 07                  		cas
     285/     169 : 90 84               		jmp 	__CmdMainLoop1
     286/     16B :                     
     287/     16B :                     ; ****************************************************************************************************************
     288/     16B :                     ;												In line Assembler
     289/     16B :                     ; ****************************************************************************************************************
     290/     16B :                     
     291/     16B :                     __Assembler:
     292/     16B : C1 FF               		ld 		-1(p1) 											; this is the operation code to use.
     293/     16D : CE FF               		st 		@-1(p2) 										; push on the stack.
     294/     16F :                     
     295/     16F : 3F                  		xppc 	p3 												; evaluate (any) parameter if present
     296/     170 : 06                  		csa 													; check carry flag set
     297/     171 : 94 27               		jp 		__ASMNoParameter  								; if clear, no parameter was provided.
     298/     173 :                     
     299/     173 : C4 23               		ldi 	parPosn & 255
     300/     175 : 31                  		xpal 	p1 												; get the parameter LSB
     301/     176 : CE FF               		st 		@-1(p2) 										; push that on the stack, set P1 to parPosn
     302/     178 : C4 0C               		ldi 	parPosn / 256
     303/     17A : 35                  		xpah 	p1
     304/     17B : C1 00               		ld 		(p1) 											; read current position
     305/     17D : 31                  		xpal 	p1 												; P1 now points to character.
     306/     17E : C1 00               		ld 		(p1) 											; read character
     307/     180 : E4 21               		xri 	'!'												; is it the label pling ?
     308/     182 : 9C 1E               		jnz 	__ASMContinue 									; we don't need to change this pointer , we should technically.
     309/     184 : C2 00               		ld 		(p2) 											; read the value, which is the label number
     310/     186 : 03                  		scl
     311/     187 : FC 20               		cai 	labelCount 										; is it a valid label number
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 8 - 11/30/2015 10:31:02


     312/     189 : 94 D6               		jp 		__CommandError 									; no, beep.
     313/     18B : C2 00               		ld 		(p2) 											; re-read the label number
     314/     18D : 01                  		xae 													; put in E
     315/     18E : C4 0C               		ldi 	Labels/256 										; point p1 to labels
     316/     190 : 35                  		xpah 	p1
     317/     191 : C4 00               		ldi 	Labels&255 
     318/     193 : 31                  		xpal 	p1
     319/     194 : C1 80               		ld 		-0x80(p1) 										; read label indexed using E.
     320/     196 : CA 00               		st 		(p2) 											; save as the operand
     321/     198 : 90 08               		jmp 	__ASMContinue 									; and continue
     322/     19A :                     
     323/     19A :                     __ASMNoParameter:
     324/     19A : C2 00               		ld 		(p2) 											; read the pushed operation code
     325/     19C : D4 80               		ani 	0x80 											; is bit 7 set ?
     326/     19E : 9C C1               		jnz 	__CommandError 									; if it is, we need a parameter
     327/     1A0 : CE FF               		st 		@-1(p2) 										; push zero on the stack as a dummy parameter.
     328/     1A2 :                     
     329/     1A2 :                     __ASMContinue:
     330/     1A2 : C4 0C               		ldi 	Current/256 									; p3 = &Current Address
     331/     1A4 : 37                  		xpah 	p3
     332/     1A5 : C4 21               		ldi 	Current&255
     333/     1A7 : 33                  		xpal 	p3
     334/     1A8 :                     
     335/     1A8 : C3 03               		ld 		modifier-Current(p3) 							; get the modifier (e.g. @,Pn etc.)
     336/     1AA : 02                  		ccl
     337/     1AB : F2 01               		add 	1(p2) 											; add to the opcode and write it back
     338/     1AD : CA 01               		st 		1(p2)
     339/     1AF :                     
     340/     1AF : C3 00               		ld 		(p3) 											; read current address into P1
     341/     1B1 : 31                  		xpal 	p1
     342/     1B2 : C3 01               		ld 		1(p3)
     343/     1B4 : 35                  		xpah 	p1
     344/     1B5 :                     
     345/     1B5 : C2 01               		ld 		1(p2) 											; read opcode.
     346/     1B7 : CD 01               		st 		@1(p1) 											; write out to current address and bump it.
     347/     1B9 : 94 1F               		jp 		__ASMExit 										; if +ve then no operand byte, exit.
     348/     1BB :                     
     349/     1BB : C2 00               		ld 		(p2) 											; read the operand byte
     350/     1BD : CD 01               		st 		@1(p1) 											; write that out as well.
     351/     1BF :                     
     352/     1BF : C3 03               		ld 		modifier-Current(p3) 							; look at the modifier 
     353/     1C1 : 9C 17               		jnz 	__ASMExit 										; if non zero we don't need to do anything P0 = 00
     354/     1C3 : C2 01               		ld 		1(p2) 											; DLY is a special case
     355/     1C5 : E4 8F               		xri 	0x8F 											; where the modifier is zero but not PC relative.
     356/     1C7 : 98 11               		jz 		__ASMExit 												
     357/     1C9 :                     
     358/     1C9 : C1 FF               		ld 		-1(p1) 											; read operand
     359/     1CB : 02                  		ccl 													; one fewer because we want the current addr+1 low
     360/     1CC : FB 00               		cad 	(p3) 											; subtract the current address low.
     361/     1CE : C9 FF               		st 		-1(p1) 											; write it back
     362/     1D0 :                     
     363/     1D0 : C2 01               		ld 		1(p2) 											; read opcode again
     364/     1D2 : D4 F0               		ani 	0xF0 											; is it 9x (a JMP command)
     365/     1D4 : E4 90               		xri 	0x90
     366/     1D6 : 9C 02               		jnz 	__ASMExit 										; if not, we are done
     367/     1D8 : B9 FF               		dld 	-1(p1) 											; one fewer because of the pre-increment
     368/     1DA :                     __ASMExit:
     369/     1DA : 31                  		xpal 	p1 												; write current address back out
     370/     1DB : CB 00               		st 		(p3)
     371/     1DD : 35                  		xpah 	p1
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 9 - 11/30/2015 10:31:02


     372/     1DE : CB 01               		st 		1(p3)
     373/     1E0 : C6 02               		ld 		@2(p2) 											; drop stack values.
     374/     1E2 :                     
     375/     1E2 : 90 0C               		jmp 	__CmdMainLoop2 									; back to command loop
     376/     1E4 :                     
     377/     1E4 :                     ; ****************************************************************************************************************
     378/     1E4 :                     ; ****************************************************************************************************************
     379/     1E4 :                     ;
     380/     1E4 :                     ;												Commands Section
     381/     1E4 :                     ;
     382/     1E4 :                     ; ****************************************************************************************************************
     383/     1E4 :                     ; ****************************************************************************************************************
     384/     1E4 :                     
     385/     1E4 :                     ; ****************************************************************************************************************
     386/     1E4 :                     ;											A : Set Current address
     387/     1E4 :                     ; ****************************************************************************************************************
     388/     1E4 :                     
     389/     1E4 :                     Address_Command:
     390/     1E4 : 3F                  		xppc 	p3 												; get parameter if exists
     391/     1E5 : 3F                  		xppc 	p3 												; update current if exists.
     392/     1E6 : 90 08               		jmp 	__CmdMainLoop2
     393/     1E8 :                     
     394/     1E8 :                     __CmdParameterFail:
     395/     1E8 : C4 02               		ldi 	2 												; set the beeper on
     396/     1EA : 07                  		cas
     397/     1EB : 8F FF               		dly 	0xFF 											; short delay
     398/     1ED : C4 00               		ldi 	0 												; set the beeper off
     399/     1EF : 07                  		cas
     400/     1F0 :                     __CmdMainLoop2:													; and go back to the start.
     401/     1F0 : C4 92               		ldi 	(CommandMainLoop-1) & 255
     402/     1F2 : 33                  		xpal 	p3
     403/     1F3 : C4 00               		ldi 	(CommandMainLoop-1) / 256
     404/     1F5 : 37                  		xpah 	p3
     405/     1F6 : 3F                  		xppc 	p3
     406/     1F7 :                     
     407/     1F7 :                     ; ****************************************************************************************************************
     408/     1F7 :                     ;										G : Go (Address must be specified.)
     409/     1F7 :                     ; ****************************************************************************************************************
     410/     1F7 :                     
     411/     1F7 :                     Go_Command:
     412/     1F7 : 3F                  		xppc 	p3 												; get parameter, which should exist.
     413/     1F8 : 06                  		csa 													; look at CY/L which is set if it was.
     414/     1F9 : 94 ED               		jp 		__CmdParameterFail 								; if it is clear, beep an error.
     415/     1FB : 31                  		xpal 	p1 												; copy P1 to P3
     416/     1FC : 33                  		xpal 	p3
     417/     1FD : 35                  		xpah 	p1
     418/     1FE : 37                  		xpah 	p3
     419/     1FF : C7 FF               		ld 		@-1(p3) 										; fix up for pre increment
     420/     201 : 3F                  		xppc 	p3 												; call the routine.		
     421/     202 :                     __CmdMainLoop3:
     422/     202 : 90 EC               		jmp 	__CmdMainLoop2 									; re-enter monitor.
     423/     204 :                     
     424/     204 :                     ; ****************************************************************************************************************
     425/     204 :                     ;			PUT Write to tape : data mandatory, it is the byte count from the current address.
     426/     204 :                     ; ****************************************************************************************************************
     427/     204 :                     
     428/     204 :                     PutTape_Command:
     429/     204 : 3F                  		xppc 	p3 												; get the bytes to write.
     430/     205 : 06                  		csa 													; if CC, no value was provided
     431/     206 : 94 E0               		jp 		__CmdParameterFail 								; which is an error.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 10 - 11/30/2015 10:31:02


     432/     208 : 31                  		xpal 	p1 												; store low byte count in -1(P2)
     433/     209 : CA FF               		st 		-1(p2)
     434/     20B : 35                  		xpah 	p1 												; store high byte count in -2(P2)
     435/     20C : CA FE               		st 		-2(p2)
     436/     20E : 02                  		ccl 													; skip over the update current address
     437/     20F : 3F                  		xppc 	p3 												; this won't update current address as CY/L = 0
     438/     210 : 3F                  		xppc 	p3 												; and load the current address into P1.
     439/     211 : C4 00               		ldi 	0 												; set the output tape bit low
     440/     213 : 01                  		xae
     441/     214 : 19                  		sio
     442/     215 : C4 20               		ldi 	32 												; tape leader
     443/     217 : CA FD               		st 		-3(p2)
     444/     219 :                     _PutTapeLeader:
     445/     219 : 8F FF               		dly 	0xFF
     446/     21B : BA FD               		dld 	-3(p2)
     447/     21D : 9C FA               		jnz 	_PutTapeLeader
     448/     21F :                     _PutTapeByte:													; output byte at P1
     449/     21F : C4 00               		ldi 	0 												; set output bit to 0
     450/     221 : 01                  		xae 	
     451/     222 : 19                  		sio
     452/     223 : 8F 10               		dly 	tapeDelay * 4 									; 0 continuation bit + gap between tapes with no signal 
     453/     225 : C4 01               		ldi 	0x1 											; set bit high
     454/     227 : 01                  		xae
     455/     228 : 19                  		sio 
     456/     229 : C4 00               		ldi 	0
     457/     22B : 8F 04               		dly 	tapeDelay 										; output the start bit.
     458/     22D : C5 01               		ld 		@1(p1) 											; read the byte and put it in E.
     459/     22F : 01                  		xae
     460/     230 : C4 08               		ldi 	8 												; output 8 bits
     461/     232 : CA FD               		st 		-3(p2)
     462/     234 :                     _PutTapeBit:
     463/     234 : 19                  		sio 													; output MSB and shift
     464/     235 : C4 00               		ldi 	0
     465/     237 : 8F 04               		dly 	tapeDelay 								
     466/     239 : BA FD               		dld 	-3(p2) 											; do all 8 bits.
     467/     23B : 9C F7               		jnz 	_PutTapeBit
     468/     23D : BA FF               		dld 	-1(p2) 											; decrement counter
     469/     23F : 9C DE               		jnz 	_PutTapeByte
     470/     241 : BA FE               		dld 	-2(p2) 											; note MSB goes 0 to -1 when finished.
     471/     243 : 94 DA               		jp 		_PutTapeByte
     472/     245 : C4 01               		ldi 	0x01 											; add the termination bit.
     473/     247 : 01                  		xae
     474/     248 : 19                  		sio
     475/     249 : C4 00               		ldi 	0 												; put that out.
     476/     24B : 8F 04               		dly 	TapeDelay
     477/     24D : C4 00               		ldi 	0 												; and set the leve back to 0
     478/     24F : 01                  		xae 
     479/     250 : 19                  		sio
     480/     251 :                     __CmdMainLoop4:
     481/     251 : 90 AF               		jmp 	__CmdMainLoop3
     482/     253 :                     
     483/     253 :                     __CmdParameterFail1:
     484/     253 : 90 93               		jmp 	__CmdParameterFail
     485/     255 :                     
     486/     255 :                     ; ****************************************************************************************************************
     487/     255 :                     ;						GET [addr] load tape to current position or given address.
     488/     255 :                     ; ****************************************************************************************************************
     489/     255 :                     
     490/     255 :                     LoadTape_Command:
     491/     255 : 3F                  		xppc	p3 												; get parameter
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 11 - 11/30/2015 10:31:02


     492/     256 : 3F                  		xppc 	p3												; update current address
     493/     257 : 3F                  		xppc 	p3 												; current address to P1.
     494/     258 : C4 08               		ldi 	0x8 											; point P3 to the keyboard.
     495/     25A : 37                  		xpah 	p3
     496/     25B :                     __GetTapeWait:
     497/     25B : C3 00               		ld 		0(p3) 											; check keyboard break
     498/     25D : D4 80               		ani 	0x80
     499/     25F : 9C F2               		jnz 	__CmdParameterFail1
     500/     261 : 19                  		sio 													; wait for the start bit, examine tape in.
     501/     262 : 40                  		lde 
     502/     263 : 94 F6               		jp 		__GetTapeWait
     503/     265 : 8F 06               		dly 	tapeDelay * 3 / 2 								; half way into the first bit.
     504/     267 : C4 08               		ldi 	8 												; read in 8 bits.
     505/     269 : CA FF               		st 		-1(p2)
     506/     26B :                     __GetTapeBits:
     507/     26B : 19                  		sio 													; read in one bit
     508/     26C : C4 00               		ldi 	0
     509/     26E : 8F 04               		dly 	tapeDelay 										; delay to next bit
     510/     270 : BA FF               		dld 	-1(p2) 											; read 8 bits.
     511/     272 : 9C F7               		jnz 	__GetTapeBits 
     512/     274 : 40                  		lde 													; store byte at current address
     513/     275 : CD 01               		st 		@1(p1)
     514/     277 : 19                  		sio 													; read in the byte, which is zero if continuing.
     515/     278 : 40                  		lde  													; examine bit 7 shifted in.
     516/     279 : 94 E0               		jp 		__GetTapeWait 									; if zero, wait for the next start bit.
     517/     27B :                     __CmdMainLoop5:
     518/     27B : 90 D4               		jmp 	__CmdMainLoop4
     519/     27D :                     
     520/     27D :                     ; ****************************************************************************************************************
     521/     27D :                     ;										L : nn Set Label to current address
     522/     27D :                     ; ****************************************************************************************************************
     523/     27D :                     
     524/     27D :                     Label_Command:
     525/     27D : 3F                  		xppc 	p3 												; get parameter
     526/     27E : 06                  		csa 													; check it exists, CY/L must be set
     527/     27F : 94 D2               		jp 		__CmdParameterFail1
     528/     281 : 31                  		xpal 	p1 												; get into A
     529/     282 : 01                  		xae 													; put into E
     530/     283 : 40                  		lde 													; get back
     531/     284 : 03                  		scl
     532/     285 : FC 20               		cai 	labelCount 										; check is < number of labels
     533/     287 : 94 CA               		jp 		__CmdParameterFail1
     534/     289 :                     
     535/     289 : C4 0C               		ldi 	Current/256 									; point P1 to current address
     536/     28B : 35                  		xpah 	p1
     537/     28C : C4 21               		ldi 	Current&255
     538/     28E : 31                  		xpal 	p1
     539/     28F : C1 00               		ld 		(p1) 											; read current address
     540/     291 : 31                  		xpal 	p1 												; save in P1.Low
     541/     292 : C4 00               		ldi 	Labels&255 										; get labels low byte in same page as current address
     542/     294 : 02                  		ccl
     543/     295 : 70                  		ade 													; add label # to it
     544/     296 : 31                  		xpal 	p1 												; put in P1.L and restore current address low
     545/     297 : C9 00               		st 		(p1) 											; store current address low in label space.
     546/     299 : 90 E0               		jmp 	__CmdMainLoop5 									; and exit.
     547/     29B :                     
     548/     29B :                     ; ****************************************************************************************************************
     549/     29B :                     ;											M :	Dump Memory
     550/     29B :                     ; ****************************************************************************************************************
     551/     29B :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 12 - 11/30/2015 10:31:02


     552/     29B :                     MemoryDump_Command:
     553/     29B : 3F                  		xppc 	p3 												; get parameter if exists
     554/     29C : 3F                  		xppc 	p3 												; update current if exists.
     555/     29D : C4 07               		ldi 	7 												; print seven rows
     556/     29F : CE FF               		st 		@-1(p2)
     557/     2A1 :                     __DCLoop:
     558/     2A1 : C4 04               		ldi 	(PrintAddressData-1)/256						; print one row of address and data.
     559/     2A3 : 37                  		xpah 	p3
     560/     2A4 : C4 53               		ldi 	(PrintAddressData-1)&255
     561/     2A6 : 33                  		xpal 	p3
     562/     2A7 : C4 04               		ldi 	4
     563/     2A9 : 3F                  		xppc 	p3
     564/     2AA : C4 0C               		ldi 	Current/256 									; point P1 to current
     565/     2AC : 35                  		xpah 	p1
     566/     2AD : C4 21               		ldi 	Current&255 
     567/     2AF : 31                  		xpal 	p1
     568/     2B0 : C1 00               		ld 		0(p1) 											; add 4 to current address
     569/     2B2 : 02                  		ccl
     570/     2B3 : F4 04               		adi 	4
     571/     2B5 : C9 00               		st 		0(p1)
     572/     2B7 : C1 01               		ld 		1(p1)
     573/     2B9 : F4 00               		adi 	0
     574/     2BB : C9 01               		st 		1(p1)
     575/     2BD : BA 00               		dld 	(p2) 											; do it 7 times
     576/     2BF : 9C E0               		jnz 	__DCLoop
     577/     2C1 : C6 01               		ld 		@1(p2) 											; fix up stack.
     578/     2C3 :                     __CmdMainLoop6:
     579/     2C3 : 90 B6               		jmp 	__CmdMainLoop5
     580/     2C5 :                     
     581/     2C5 :                     
     582/     2C5 :                     ; ****************************************************************************************************************
     583/     2C5 :                     ;								B: Enter Bytes (no address, sequence of byte data)
     584/     2C5 :                     ; ****************************************************************************************************************
     585/     2C5 :                     
     586/     2C5 :                     EnterBytes_Command:
     587/     2C5 : C4 86               		ldi 	(GetParameter-1) & 255 							; P3 = Get Parameter routine
     588/     2C7 : 33                  		xpal 	p3
     589/     2C8 : C4 04               		ldi 	(GetParameter-1) / 256 	
     590/     2CA : 37                  		xpah 	p3
     591/     2CB : 3F                  		xppc 	p3 												; get the parameter.
     592/     2CC : 06                  		csa 													; look at carry
     593/     2CD : 94 AC               		jp 		__CmdMainLoop5 									; carry clear, no value.
     594/     2CF : C4 0C               		ldi 	Current/256 									; make P1 point to current
     595/     2D1 : 35                  		xpah 	p1
     596/     2D2 : C4 21               		ldi 	Current&255 										
     597/     2D4 : 31                  		xpal 	p1 												; this pulls the byte value into A
     598/     2D5 : 01                  		xae 													; save it in E
     599/     2D6 : C1 00               		ld 		0(p1) 											; copy address to save to into P3
     600/     2D8 : 33                  		xpal 	p3
     601/     2D9 : C1 01               		ld 		1(p1) 
     602/     2DB : 37                  		xpah 	p3 
     603/     2DC : 40                  		lde 													; get byte back
     604/     2DD : CB 00               		st 		(p3) 											; save it in that location
     605/     2DF : A9 00               		ild 	0(p1) 											; bump current address and go back and try again.
     606/     2E1 : 9C E2               		jnz 	EnterBytes_Command
     607/     2E3 : A9 01               		ild 	1(p1)
     608/     2E5 : 90 DE               		jmp 	EnterBytes_Command
     609/     2E7 :                     
     610/     2E7 :                     ; ****************************************************************************************************************
     611/     2E7 :                     ;											D [aaaa] Disassembler
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 13 - 11/30/2015 10:31:02


     612/     2E7 :                     ; ****************************************************************************************************************
     613/     2E7 :                     
     614/     2E7 :                     Disassemble_Command:	
     615/     2E7 : 3F                  		xppc 	p3 												; evaluate
     616/     2E8 : 3F                  		xppc 	p3 												; update current if new value
     617/     2E9 : C4 07               		ldi 	7												; instructions to disassemble counter
     618/     2EB : CE FC               		st 		@-4(p2)											; p2 + 0 = counter p2 + 1 = opcode p2 + 2 = operand
     619/     2ED :                     __DAssLoop:														; p2 + 3 = opcode - base opcode.
     620/     2ED : C4 04               		ldi 	(PrintAddressData-1)/256						; print Address only
     621/     2EF : 37                  		xpah 	p3
     622/     2F0 : C4 53               		ldi 	(PrintAddressData-1)&255
     623/     2F2 : 33                  		xpal 	p3
     624/     2F3 : C4 00               		ldi 	0
     625/     2F5 : 3F                  		xppc 	p3
     626/     2F6 : C4 0C               		ldi 	Current / 256 									; point P1 to current address
     627/     2F8 : 35                  		xpah 	p1
     628/     2F9 : C4 21               		ldi 	Current & 255
     629/     2FB : 31                  		xpal 	p1
     630/     2FC : C1 00               		ld 		0(p1) 											; load current address into P3
     631/     2FE : 33                  		xpal 	p3
     632/     2FF : C1 01               		ld 		1(p1)
     633/     301 : 37                  		xpah 	p3
     634/     302 : C7 01               		ld 		@1(p3) 											; read opcode
     635/     304 : CA 01               		st 		1(p2) 											; save it
     636/     306 : 94 04               		jp 		__DAssNoOperand 								; if +ve no operand
     637/     308 : C7 01               		ld 		@1(p3) 											; read operand
     638/     30A : CA 02               		st 		2(p2) 											; save it
     639/     30C :                     __DAssNoOperand:
     640/     30C : C4 E9               		ldi 	(__CommandListEnd-3) & 255
     641/     30E : 33                  		xpal 	p3 												; update current position, setting P3 to last entry
     642/     30F : C9 00               		st 		0(p1)											; in command table.
     643/     311 : C4 07               		ldi 	(__CommandListEnd-3) / 256
     644/     313 : 37                  		xpah 	p3
     645/     314 : C9 01               		st 		1(p1)
     646/     316 :                     
     647/     316 :                     __DAssFindOpcode: 												; the table is : text (word) opcode (byte)
     648/     316 : C2 01               		ld 		1(p2) 											; get opcode
     649/     318 : E3 02               		xor 	2(p3) 											; check in the same 8 byte page.
     650/     31A : D4 F0               		ani 	0xF0
     651/     31C : 9C 0B               		jnz 	__DAssNextOpcode
     652/     31E : C2 01               		ld 		1(p2) 											; get opcode
     653/     320 : 03                  		scl
     654/     321 : FB 02               		cad 	2(p3) 											; subtract the base opcode.
     655/     323 : CA 03               		st 		3(p2) 											; save a the offset (possible)
     656/     325 : D4 E0               		ani 	0xE0 											; it needs to be 0x20 or less
     657/     327 : 98 08               		jz 		__DAssFoundOpcode 								; if >= 0 then found the correct opcode.
     658/     329 :                     __DAssNextOpcode:
     659/     329 : C7 FD               		ld 		@-3(p3) 										; go to previous entry in table
     660/     32B : 90 E9               		jmp 	__DAssFindOpcode
     661/     32D :                     
     662/     32D :                     __DAssLoop2:
     663/     32D : 90 BE               		jmp 	__DAssLoop
     664/     32F :                     __CmdMainLoop7:
     665/     32F : 90 92               		jmp 	__CmdMainLoop6
     666/     331 :                     
     667/     331 :                     __DAssFoundOpcode:
     668/     331 : C3 02               		ld 		2(p3) 											; look at opcode that matched.
     669/     333 : D4 87               		ani 	0x87 											; match with 1xxx x100
     670/     335 : E4 84               		xri 	0x84 											; which is all the immediate instructions.		
     671/     337 : 9C 04               		jnz 	__DAssNotImmediate
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 14 - 11/30/2015 10:31:02


     672/     339 : C2 03               		ld 		3(p2) 											; only do immediate if base offset is zero
     673/     33B : 9C EC               		jnz 	__DAssNextOpcode 								; fixes C0-C7 being LD, but C4 being LDI.
     674/     33D :                     __DAssNotImmediate:
     675/     33D : C3 00               		ld 		0(p3) 											; save LSB of text on stack
     676/     33F : CE FF               		st 		@-1(p2)
     677/     341 : C3 01               		ld 		1(p3) 											; and the MSB of text on stack
     678/     343 : CE FF               		st 		@-1(p2)
     679/     345 :                     
     680/     345 : C4 03               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     681/     347 : 37                  		xpah 	p3
     682/     348 : C4 E6               		ldi 	(PrintCharacter-1) & 255 
     683/     34A : 33                  		xpal 	p3
     684/     34B : C4 20               		ldi 	' '												; print a space.
     685/     34D : 3F                  		xppc 	p3
     686/     34E :                     
     687/     34E : C4 03               		ldi 	3 												; print 3 characters
     688/     350 : CE FF               		st 		@-1(p2) 										; so +0 is count, +1 = text MSB, +2 = text LSB
     689/     352 :                     __DAssPrintMnemonic:
     690/     352 : C2 01               		ld 		1(p2) 											; get text MSB which is in bits .xxxxx..
     691/     354 : 1C                  		sr 														; shift right twice.
     692/     355 : 1C                  		sr
     693/     356 : D4 1F               		ani 	0x1F 											; lower 5 bits only
     694/     358 : 98 04               		jz 		__DAssSkipSpace 								; don't print spaces (00000)
     695/     35A : 02                  		ccl 													; make it 7 bit ASCII code.
     696/     35B : F4 40               		adi 	64 							
     697/     35D : 3F                  		xppc 	p3 												; display the character
     698/     35E :                     __DAssSkipSpace:
     699/     35E : C4 05               		ldi 	5 												; now shift the encoded data left 5 times
     700/     360 : CA FF               		st 		-1(p2)
     701/     362 :                     __DAssShiftEncode:
     702/     362 : 02                  		ccl
     703/     363 : C2 02               		ld 		2(p2)
     704/     365 : F2 02               		add 	2(p2)
     705/     367 : CA 02               		st 		2(p2)
     706/     369 : C2 01               		ld 		1(p2)
     707/     36B : F2 01               		add 	1(p2)
     708/     36D : CA 01               		st 		1(p2)
     709/     36F : BA FF               		dld 	-1(p2)
     710/     371 : 9C EF               		jnz 	__DAssShiftEncode
     711/     373 : BA 00               		dld 	0(p2) 											; done all three characters
     712/     375 : 9C DB               		jnz 	__DAssPrintMnemonic 							; if not keep going.
     713/     377 :                     
     714/     377 : C6 03               		ld 		@3(p2) 											; remove mnemonic stuff off the stack.
     715/     379 :                     
     716/     379 : C2 03               		ld 		3(p2) 											; print instruction modifier if required.
     717/     37B : 9C 1F               		jnz 	__DAssPrintModifier
     718/     37D :                     
     719/     37D :                     __DAssPrintOperand:
     720/     37D : C2 01               		ld 		1(p2) 											; get original opcode
     721/     37F : 94 0A               		jp 		__DAssNext 										; if no operand go to next line of disassembly.
     722/     381 : C4 03               		ldi 	(PrintHexByte-1) / 256 							; set P3 to point to the hex printer
     723/     383 : 37                  		xpah 	p3
     724/     384 : C4 B3               		ldi 	(PrintHexByte-1) & 255
     725/     386 : 33                  		xpal 	p3
     726/     387 : C2 02               		ld 		2(p2) 											; get operand
     727/     389 : 03                  		scl 
     728/     38A : 3F                  		xppc 	p3 												; print it out with a leading space.
     729/     38B :                     
     730/     38B :                     __DAssNext:
     731/     38B : C4 03               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 15 - 11/30/2015 10:31:02


     732/     38D : 37                  		xpah 	p3
     733/     38E : C4 E6               		ldi 	(PrintCharacter-1) & 255 
     734/     390 : 33                  		xpal 	p3
     735/     391 : C4 0D               		ldi 	13												; print a newline.
     736/     393 : 3F                  		xppc 	p3
     737/     394 :                     
     738/     394 : BA 00               		dld 	0(p2) 											; done all 6 lines
     739/     396 : 9C 95               		jnz 	__DAssLoop2 									; no, go round again.
     740/     398 : C6 04               		ld 		@4(p2) 											; fix up the stack.
     741/     39A : 90 93               		jmp 	__CmdMainLoop7 									; and time to exit.
     742/     39C :                     
     743/     39C :                     
     744/     39C :                     __DAssPrintModifier:
     745/     39C : C4 20               		ldi 	' '												; print leading space
     746/     39E : 3F                  		xppc 	p3
     747/     39F : C2 03               		ld 		3(p2) 											; read modifier
     748/     3A1 : D4 04               		ani 	0x04 											; is @ bit set
     749/     3A3 : 98 03               		jz 		__DAssNotAutoIndexed
     750/     3A5 : C4 40               		ldi 	'@'												; print '@'
     751/     3A7 : 3F                  		xppc 	p3
     752/     3A8 :                     __DAssNotAutoIndexed:
     753/     3A8 : C4 50               		ldi 	'P'												; print 'P'
     754/     3AA : 3F                  		xppc 	p3
     755/     3AB : C2 03               		ld 		3(p2) 											; print pointer register
     756/     3AD : D4 03               		ani 	3
     757/     3AF : DC 30               		ori 	'0'
     758/     3B1 : 3F                  		xppc 	p3
     759/     3B2 : 90 C9               		jmp 	__DAssPrintOperand 								; and print operand.
     760/     3B4 :                     
     761/     3B4 :                     
     762/     3B4 :                     ; ****************************************************************************************************************
     763/     3B4 :                     ; ****************************************************************************************************************
     764/     3B4 :                     ;
     765/     3B4 :                     ;						Print A as a hexadecimal 2 digit value. If CY/L set precede with space
     766/     3B4 :                     ;
     767/     3B4 :                     ; ****************************************************************************************************************
     768/     3B4 :                     ; ****************************************************************************************************************
     769/     3B4 :                     
     770/     3B4 :                     PrintHexByte:
     771/     3B4 : CE FF               		st 		@-1(p2) 										; push A and P3, set P3 up to print character
     772/     3B6 : C4 03               		ldi 	(PrintCharacter-1)/256
     773/     3B8 : 37                  		xpah 	p3
     774/     3B9 : CE FF               		st 		@-1(p2)
     775/     3BB : C4 E6               		ldi 	(PrintCharacter-1)&255
     776/     3BD : 33                  		xpal 	p3
     777/     3BE : CE FF               		st 		@-1(p2)
     778/     3C0 : 06                  		csa 													; check carry
     779/     3C1 : 94 03               		jp 		__PHBNoSpace									; if clear, no space.
     780/     3C3 : C4 20               		ldi 	' '												; print leading space
     781/     3C5 : 3F                  		xppc 	p3 
     782/     3C6 :                     __PHBNoSpace:
     783/     3C6 : C2 02               		ld 		2(p2) 											; read digit
     784/     3C8 : 1C                  		sr 														; convert MSB
     785/     3C9 : 1C                  		sr
     786/     3CA : 1C                  		sr
     787/     3CB : 1C                  		sr
     788/     3CC : 02                  		ccl
     789/     3CD : EC 90               		dai 	0x90
     790/     3CF : EC 40               		dai 	0x40
     791/     3D1 : 3F                  		xppc 	p3 												; print
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 16 - 11/30/2015 10:31:02


     792/     3D2 : C2 02               		ld 		2(p2) 											; read digit
     793/     3D4 : D4 0F               		ani 	0x0F 											; convert LSB
     794/     3D6 : 02                  		ccl
     795/     3D7 : EC 90               		dai 	0x90
     796/     3D9 : EC 40               		dai 	0x40
     797/     3DB : 3F                  		xppc 	p3 												; print
     798/     3DC :                     
     799/     3DC : C6 01               		ld 		@1(p2) 											; restore P3 & A and Return
     800/     3DE : 33                  		xpal 	p3
     801/     3DF : C6 01               		ld 		@1(p2)
     802/     3E1 : 37                  		xpah 	p3
     803/     3E2 : C6 01               		ld 		@1(p2)
     804/     3E4 : 3F                  		xppc 	p3
     805/     3E5 : 90 CD               		jmp 	PrintHexByte
     806/     3E7 :                     
     807/     3E7 :                     ; ****************************************************************************************************************
     808/     3E7 :                     ; ****************************************************************************************************************
     809/     3E7 :                     ;
     810/     3E7 :                     ;		Print Character in A, preserves all registers, re-entrant. Handles 13 (New Line), 8 (Backspace)
     811/     3E7 :                     ;		Characters 32 - 95 only.
     812/     3E7 :                     ;	
     813/     3E7 :                     ;		Rolls to screen top rather than scrolling.
     814/     3E7 :                     ;
     815/     3E7 :                     ; ****************************************************************************************************************
     816/     3E7 :                     ; ****************************************************************************************************************
     817/     3E7 :                     
     818/     3E7 :                     PrintCharacter:
     819/     3E7 : CE FF               		st 		@-1(p2) 										; save A
     820/     3E9 : C4 0C               		ldi 	Cursor/256 										; save P1, setting up P1 -> Cursor at same time.
     821/     3EB : 35                  		xpah 	p1
     822/     3EC : CE FF               		st 		@-1(p2)
     823/     3EE : C4 20               		ldi 	Cursor&255
     824/     3F0 : 31                  		xpal 	p1
     825/     3F1 : CE FF               		st 		@-1(p2)
     826/     3F3 : C4 00               		ldi 	0 												; save P3, setting up P3 -> Page 0 (Video RAM Write)
     827/     3F5 : 37                  		xpah 	p3
     828/     3F6 : CE FF               		st 		@-1(p2)
     829/     3F8 : 33                  		xpal 	p3
     830/     3F9 : CE FF               		st 		@-1(p2)
     831/     3FB :                     
     832/     3FB : C1 00               		ld 		(p1) 											; read cursor position
     833/     3FD : 33                  		xpal 	p3 												; put in P3.Low
     834/     3FE :                     
     835/     3FE : C4 20               		ldi 	' ' 											; erase the cursor.
     836/     400 : CB 00               		st 		0(p3)
     837/     402 :                     
     838/     402 : C2 04               		ld 		4(p2) 											; read character to print.
     839/     404 : E4 0D               		xri 	13 												; is it CR ?
     840/     406 : 98 40               		jz 		__PCNewLine 									; if so, go to new line.
     841/     408 : E4 05               		xri 	13!8 											; is it Backspace ?
     842/     40A : 98 30               		jz 		__PCBackSpace
     843/     40C :                     
     844/     40C : C2 04               		ld 		4(p2) 											; get character to print
     845/     40E : D4 3F               		ani 	0x3F 											; make 6 bit ASCII
     846/     410 : CF 01               		st 		@1(p3) 											; write into P3, e.g. the screen and bump it.
     847/     412 : A9 00               		ild 	(p1) 											; increment cursor position and load
     848/     414 : D4 0F               		ani 	15 												; are we at line start ?
     849/     416 : 9C 0C               		jnz 	__PCExit 										; if so, erase the current line.
     850/     418 :                     
     851/     418 :                     __PCBlankNewLine:
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 17 - 11/30/2015 10:31:02


     852/     418 : C4 10               		ldi 	16 												; count to 16, the number of spaces to write out.
     853/     41A : CA FF               		st 		-1(p2) 
     854/     41C :                     __PCBlankNewLineLoop:
     855/     41C : C4 20               		ldi 	' '
     856/     41E : CF 01               		st 		@1(p3)
     857/     420 : BA FF               		dld 	-1(p2)
     858/     422 : 9C F8               		jnz 	__PCBlankNewLineLoop
     859/     424 :                     
     860/     424 :                     __PCExit:
     861/     424 : C1 00               		ld 		(p1) 											; read cursor
     862/     426 : 33                  		xpal 	p3 												; put in P3.L
     863/     427 : C4 9B               		ldi 	0x9B 											; shaded block cursor on screen
     864/     429 : CB 00               		st 		(p3)
     865/     42B : C6 01               		ld 		@1(p2)											; restore P3
     866/     42D : 33                  		xpal 	p3
     867/     42E : C6 01               		ld 		@1(p2)
     868/     430 : 37                  		xpah 	p3
     869/     431 : C6 01               		ld 		@1(p2)											; restore P1
     870/     433 : 31                  		xpal 	p1
     871/     434 : C6 01               		ld 		@1(p2)
     872/     436 : 35                  		xpah 	p1
     873/     437 : C6 01               		ld 		@1(p2) 											; restore A and Return.	
     874/     439 : 3F                  		xppc 	p3
     875/     43A : 90 AB               		jmp 	PrintCharacter 									; and it is re-entrant.
     876/     43C :                     
     877/     43C :                     __PCBackSpace:
     878/     43C : 33                  		xpal 	p3 												; get current cursor position
     879/     43D : 98 E5               		jz 		__PCExit 										; if top of screen then exit.
     880/     43F : B9 00               		dld 	(p1) 											; backspace and load cursor
     881/     441 : 33                  		xpal 	p3 												; put in P3
     882/     442 : C4 20               		ldi 	' '												; erase character there
     883/     444 : CB 00               		st 		(p3)
     884/     446 : 90 DC               		jmp 	__PCExit 										; and exit.
     885/     448 :                     
     886/     448 :                     __PCNewLine:
     887/     448 : C1 00               		ld 		(p1) 											; read cursor position
     888/     44A : D4 70               		ani 	0x70 											; line
     889/     44C : 02                  		ccl 													; next line
     890/     44D : F4 10               		adi 	0x10
     891/     44F : C9 00               		st 		(p1) 											; write back
     892/     451 : 33                  		xpal 	p3 												; put in P3.L
     893/     452 : 90 C4               		jmp 	__PCBlankNewLine
     894/     454 :                     
     895/     454 :                     ; ****************************************************************************************************************
     896/     454 :                     ; ****************************************************************************************************************
     897/     454 :                     ;
     898/     454 :                     ;					Print current address followed by A data bytes. Doesn't update current address
     899/     454 :                     ;
     900/     454 :                     ; ****************************************************************************************************************
     901/     454 :                     ; ****************************************************************************************************************
     902/     454 :                     
     903/     454 :                     PrintAddressData:
     904/     454 : CE FF               		st 		@-1(p2) 										; save count, we don't restore this.
     905/     456 : C4 03               		ldi 	(PrintHexByte-1)/256 							; save and set up P3
     906/     458 : 37                  		xpah 	p3
     907/     459 : CE FF               		st 		@-1(p2)
     908/     45B : C4 B3               		ldi 	(PrintHexByte-1)&255
     909/     45D : 33                  		xpal 	p3
     910/     45E : CE FF               		st 		@-1(p2)
     911/     460 : C4 0C               		ldi 	current / 256 									; point P1 to current address
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 18 - 11/30/2015 10:31:02


     912/     462 : 35                  		xpah 	p1
     913/     463 : C4 21               		ldi 	current & 255
     914/     465 : 31                  		xpal 	p1
     915/     466 : C1 01               		ld 		1(p1) 											; read high byte of address
     916/     468 : 02                  		ccl
     917/     469 : 3F                  		xppc 	p3												; print w/o leading space
     918/     46A : C1 00               		ld 		0(p1)											; read low byte of address
     919/     46C : 02                  		ccl 	
     920/     46D : 3F                  		xppc 	p3 												; print w/o leading space.
     921/     46E : 01                  		xae 													; put in E
     922/     46F : C1 01               		ld 		1(p1) 											; high byte to P1.H
     923/     471 : 35                  		xpah 	p1
     924/     472 : 40                  		lde 													; low byte to P1.H
     925/     473 : 31                  		xpal 	p1
     926/     474 :                     _PADLoop:
     927/     474 : BA 02               		dld 	2(p2) 											; decrement counter
     928/     476 : 94 09               		jp 		_PADPrint 										; if +ve print another byte
     929/     478 :                     
     930/     478 : C6 01               		ld 		@1(p2) 											; restore P3, skipping A hence @2
     931/     47A : 33                  		xpal 	p3
     932/     47B : C6 02               		ld 		@2(p2)
     933/     47D : 37                  		xpah 	p3
     934/     47E : 3F                  		xppc 	p3
     935/     47F : 90 D3               		jmp 	PrintAddressData
     936/     481 :                     
     937/     481 :                     _PADPrint:
     938/     481 : C5 01               		ld 		@1(p1) 											; read byte advance pointer
     939/     483 : 03                  		scl
     940/     484 : 3F                  		xppc 	p3 												; print with space.
     941/     485 : 90 ED               		jmp 	_PADLoop
     942/     487 :                     
     943/     487 :                     ; ****************************************************************************************************************
     944/     487 :                     ;
     945/     487 :                     ;		Look at the parameter string for a parameter, processing @ and Pn as you go, CS if parameter found
     946/     487 :                     ; 		CC otherwise. Return parameter value in P1. Falls through
     947/     487 :                     ;
     948/     487 :                     ; ****************************************************************************************************************
     949/     487 :                     
     950/     487 :                     GetParameter:
     951/     487 : C4 0C               		ldi 	parPosn/256 									; current position into P1
     952/     489 : 35                  		xpah 	p1
     953/     48A : C4 23               		ldi 	parPosn&255 					
     954/     48C : 31                  		xpal 	p1
     955/     48D : C4 00               		ldi 	0 												; -1(p2) is the low byte result
     956/     48F : CA FF               		st 		-1(p2) 											; -2(p2) is the high byte result
     957/     491 : CA FE               		st 		-2(p2)
     958/     493 :                     
     959/     493 : C1 00               		ld 		(p1) 											; read the current position,P1 points to character
     960/     495 : 31                  		xpal 	p1 												; when we put it in P1.L
     961/     496 :                     
     962/     496 :                     __GPASkip:														; skip over spaces to first alphanumeric.
     963/     496 : C1 00               		ld 		(p1) 											; read character
     964/     498 : 98 7B               		jz 		__GPAExitFail 									; if zero, then end of the input string.
     965/     49A : C5 01               		ld 		@1(p1) 											; read it, advancing.
     966/     49C : E4 20               		xri 	32 												; is it space ?
     967/     49E : 98 F6               		jz 		__GPASkip 
     968/     4A0 : E4 60               		xri 	32!'@'											; is it @ ?
     969/     4A2 : 98 5E               		jz 		__GPAAtModifier 
     970/     4A4 : E4 10               		xri 	'@'!'P' 										; is it P ?
     971/     4A6 : 98 4C               		jz 		__GPAPointerModifier
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 19 - 11/30/2015 10:31:02


     972/     4A8 :                     
     973/     4A8 :                     __GPANextCharacter:
     974/     4A8 : C1 FF               		ld 		-1(p1) 											; get value back after post increment.
     975/     4AA : 02                  		ccl
     976/     4AB : F4 50               		adi 	128-48 											; this will be +ve if A < '0'
     977/     4AD : 94 66               		jp 		__GPAExitFail
     978/     4AF : FC 09               		cai 	9 												; will be +ve if A < '9', CY/L was clear.	
     979/     4B1 : 94 0A               		jp 		__GPAFoundHex
     980/     4B3 : FC 07               		cai 	7 												; will be +ve if A < 'A', CY/L was set
     981/     4B5 : 94 5E               		jp 		__GPAExitFail
     982/     4B7 : F4 79               		adi 	0xFF-0x85-1 									; will be +ve if A > 'F', CY/L was set.
     983/     4B9 : 94 5A               		jp 		__GPAExitFail 					
     984/     4BB : F4 76               		adi 	(0x70-0xFA) & 0xFF 								; make the range as below, CY/L was clear
     985/     4BD :                     __GPAFoundHex: 													; enter here 0-9 = $76..$7F, A-F = $70..$75
     986/     4BD : 02                  		ccl  													; convert that to a hex nibble.
     987/     4BE : F4 0A               		adi 	10
     988/     4C0 : D4 0F               		ani 	0xF
     989/     4C2 : 01                  		xae 													; save in E, temporarily
     990/     4C3 : C4 04               		ldi 	4 												; now shift the result 4 bits to the left.
     991/     4C5 : CA FD               		st 		-3(p2) 											; -3(p2) is the counter
     992/     4C7 :                     __GPAShift:
     993/     4C7 : 02                  		ccl
     994/     4C8 : C2 FF               		ld 		-1(p2) 											; shift 16 bit result 1 bit to the left.
     995/     4CA : F2 FF               		add 	-1(p2)
     996/     4CC : CA FF               		st 		-1(p2)
     997/     4CE : C2 FE               		ld 		-2(p2)
     998/     4D0 : F2 FE               		add 	-2(p2)
     999/     4D2 : CA FE               		st 		-2(p2)
    1000/     4D4 : BA FD               		dld 	-3(p2) 											; do it four times
    1001/     4D6 : 9C EF               		jnz 	__GPAShift 	
    1002/     4D8 : C2 FF               		ld 		-1(p2) 											; Or E into the LSB
    1003/     4DA : 58                  		ore
    1004/     4DB : CA FF               		st 		-1(p2)
    1005/     4DD :                     
    1006/     4DD : C5 01               		ld 		@1(p1) 											; look at next character, post incrementing.
    1007/     4DF : 03                  		scl
    1008/     4E0 : FC 22               		cai 	34 												; if it is after space and ! (label marker)
    1009/     4E2 : 94 C4               		jp 		__GPANextCharacter 								; go back and put it in place.
    1010/     4E4 :                     
    1011/     4E4 : C5 FF               		ld 		@-1(p1) 										; undo the increment, incase we've just read zero.
    1012/     4E6 :                     
    1013/     4E6 : C4 23               		ldi 	parPosn & 255 									; put the parPosn address in P1.L, new posn into A
    1014/     4E8 : 31                  		xpal 	p1
    1015/     4E9 : C9 00               		st 		(p1) 											; and write it back
    1016/     4EB : C2 FF               		ld 		-1(p2) 											; put the result into P1
    1017/     4ED : 31                  		xpal 	p1
    1018/     4EE : C2 FE               		ld 		-2(p2)
    1019/     4F0 : 35                  		xpah 	p1
    1020/     4F1 : 03                  		scl 													; set CY/L to indicate okay
    1021/     4F2 : 90 22               		jmp 	__GPAExit
    1022/     4F4 :                     
    1023/     4F4 :                     __GPAPointerModifier:
    1024/     4F4 : C1 00               		ld 		(p1) 											; read P<something> ?
    1025/     4F6 : D4 FC               		ani 	0xFC 											; is it '0' .. '3'?
    1026/     4F8 : E4 30               		xri 	'0'
    1027/     4FA : 9C 19               		jnz 	__GPAExitFail 									; it didn't work, not 0..3
    1028/     4FC : C5 01               		ld 		@1(p1) 											; re-read it and advance
    1029/     4FE : D4 03               		ani 	3												; lower 2 bits only
    1030/     500 : 90 02               		jmp 	__GPAAdjustModifier
    1031/     502 :                     __GPAAtModifier:
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 20 - 11/30/2015 10:31:02


    1032/     502 : C4 04               		ldi 	4 												; set modifier adjustment to +4
    1033/     504 :                     __GPAAdjustModifier:
    1034/     504 : CA FD               		st 		-3(p2) 
    1035/     506 : C4 24               		ldi 	modifier & 255 									; point P1 to modifier, save current address in E
    1036/     508 : 31                  		xpal 	p1
    1037/     509 : 01                  		xae 
    1038/     50A : C1 00               		ld 		(p1) 											; read modifier
    1039/     50C : 02                  		ccl
    1040/     50D : F2 FD               		add 	-3(p2) 											; add the modifying value to it.
    1041/     50F : C9 00               		st 		(p1) 											; write modifier.
    1042/     511 : 40                  		lde 													; restore current address to P1.L
    1043/     512 : 31                  		xpal 	p1
    1044/     513 : 90 81               		jmp 	__GPASkip 										; go back to skip over.
    1045/     515 :                     
    1046/     515 :                     __GPAExitFail:
    1047/     515 : 02                  		ccl 													; carry clear, e.g. nothing read in / error.
    1048/     516 :                     __GPAExit:
    1049/     516 : 3F                  		xppc 	p3
    1050/     517 :                     
    1051/     517 :                     ; ****************************************************************************************************************
    1052/     517 :                     ;
    1053/     517 :                     ;		Store parameter value in P1 in the current address, if CS. Falls through.
    1054/     517 :                     ;
    1055/     517 :                     ; ****************************************************************************************************************
    1056/     517 :                     
    1057/     517 :                     UpdateCurrentAddress:
    1058/     517 : 06                  		csa 													; get status reg
    1059/     518 : 94 0C               		jp 		__UCAExit 										; if carry flag clear then exit.
    1060/     51A :                     
    1061/     51A : C4 21               		ldi 	current & 255 									; current address to P1.L, acquired address to E
    1062/     51C : 31                  		xpal 	p1
    1063/     51D : 01                  		xae
    1064/     51E : C4 0C               		ldi 	current / 256 									; current address to P1.H, acquired to A
    1065/     520 : 35                  		xpah 	p1
    1066/     521 : C9 01               		st 		1(p1) 											; store address back
    1067/     523 : 40                  		lde
    1068/     524 : C9 00               		st 		0(p1)
    1069/     526 :                     __UCAExit:
    1070/     526 : 3F                  		xppc 	p3
    1071/     527 :                     
    1072/     527 :                     ; ****************************************************************************************************************
    1073/     527 :                     ;
    1074/     527 :                     ;		Get current address into P1.
    1075/     527 :                     ;
    1076/     527 :                     ; ****************************************************************************************************************
    1077/     527 :                     
    1078/     527 :                     GetCurrentAddress:
    1079/     527 : C4 0C               		ldi 	current/256 									; current address ptr in P1
    1080/     529 : 35                  		xpah 	p1
    1081/     52A : C4 21               		ldi 	current&255
    1082/     52C : 31                  		xpal 	p1
    1083/     52D : C1 00               		ld 		0(p1) 											; low byte to E
    1084/     52F : 01                  		xae
    1085/     530 : C1 01               		ld 		1(p1) 											; high byte to A
    1086/     532 : 35                  		xpah 	p1 												; then to P1.H
    1087/     533 : 40                  		lde 													; low byte to P1.L
    1088/     534 : 31                  		xpal 	p1 
    1089/     535 : 3F                  		xppc 	p3
    1090/     536 :                     
    1091/     536 :                     ; ****************************************************************************************************************
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 21 - 11/30/2015 10:31:02


    1092/     536 :                     ;
    1093/     536 :                     ;											List of commands and Jump Table
    1094/     536 :                     ;
    1095/     536 :                     ; ****************************************************************************************************************
    1096/     536 :                     
    1097/     536 :                     		include commands.inc 									; must be at the end, so the command table is in
(1)    1/     747 :                             org 0x0747
(1)    2/     747 :                     ;
(1)    3/     747 :                     ; 	This file is generated automatically by gencommands.py
(1)    4/     747 :                     ;
(1)    5/     747 :                     __CommandList:
(1)    6/     747 : 94 21                       dw    0x2194 ; HLT
(1)    7/     749 : 00                          db    0x00
(1)    8/     74A : 25 60                       dw    0x6025 ; XAE
(1)    9/     74C : 01                          db    0x01
(1)   10/     74D : 6C 0C                       dw    0x0c6c ; CCL
(1)   11/     74F : 02                          db    0x02
(1)   12/     750 : 6C 4C                       dw    0x4c6c ; SCL
(1)   13/     752 : 03                          db    0x03
(1)   14/     753 : 2E 11                       dw    0x112e ; DIN
(1)   15/     755 : 04                          db    0x04
(1)   16/     756 : AE 24                       dw    0x24ae ; IEN
(1)   17/     758 : 05                          db    0x05
(1)   18/     759 : 61 0E                       dw    0x0e61 ; CSA
(1)   19/     75B : 06                          db    0x06
(1)   20/     75C : 33 0C                       dw    0x0c33 ; CAS
(1)   21/     75E : 07                          db    0x07
(1)   22/     75F : F0 39                       dw    0x39f0 ; NOP
(1)   23/     761 : 08                          db    0x08
(1)   24/     762 : 2F 4D                       dw    0x4d2f ; SIO
(1)   25/     764 : 19                          db    0x19
(1)   26/     765 : 72 02                       dw    0x0272 ; SR
(1)   27/     767 : 1C                          db    0x1c
(1)   28/     768 : 4C 4E                       dw    0x4e4c ; SRL
(1)   29/     76A : 1D                          db    0x1d
(1)   30/     76B : 52 02                       dw    0x0252 ; RR
(1)   31/     76D : 1E                          db    0x1e
(1)   32/     76E : 4C 4A                       dw    0x4a4c ; RRL
(1)   33/     770 : 1F                          db    0x1f
(1)   34/     771 : 0D 00                       dw    0x000d ; M
(1)   35/     773 : 20                          db    0x20
(1)   36/     774 : 01 00                       dw    0x0001 ; A
(1)   37/     776 : 21                          db    0x21
(1)   38/     777 : 07 00                       dw    0x0007 ; G
(1)   39/     779 : 22                          db    0x22
(1)   40/     77A : B4 42                       dw    0x42b4 ; PUT
(1)   41/     77C : 23                          db    0x23
(1)   42/     77D : B4 1C                       dw    0x1cb4 ; GET
(1)   43/     77F : 24                          db    0x24
(1)   44/     780 : 03 00                       dw    0x0003 ; C
(1)   45/     782 : 25                          db    0x25
(1)   46/     783 : 02 00                       dw    0x0002 ; B
(1)   47/     785 : 26                          db    0x26
(1)   48/     786 : 0C 00                       dw    0x000c ; L
(1)   49/     788 : 27                          db    0x27
(1)   50/     789 : 04 00                       dw    0x0004 ; D
(1)   51/     78B : 28                          db    0x28
(1)   52/     78C : 0C 62                       dw    0x620c ; XPL
(1)   53/     78E : 30                          db    0x30
(1)   54/     78F : 08 62                       dw    0x6208 ; XPH
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 22 - 11/30/2015 10:31:02


(1)   55/     791 : 34                          db    0x34
(1)   56/     792 : 03 62                       dw    0x6203 ; XPC
(1)   57/     794 : 3C                          db    0x3c
(1)   58/     795 : 85 30                       dw    0x3085 ; LDE
(1)   59/     797 : 40                          db    0x40
(1)   60/     798 : C5 05                       dw    0x05c5 ; ANE
(1)   61/     79A : 50                          db    0x50
(1)   62/     79B : 45 3E                       dw    0x3e45 ; ORE
(1)   63/     79D : 58                          db    0x58
(1)   64/     79E : 45 62                       dw    0x6245 ; XRE
(1)   65/     7A0 : 60                          db    0x60
(1)   66/     7A1 : 25 10                       dw    0x1025 ; DAE
(1)   67/     7A3 : 68                          db    0x68
(1)   68/     7A4 : 85 04                       dw    0x0485 ; ADE
(1)   69/     7A6 : 70                          db    0x70
(1)   70/     7A7 : 25 0C                       dw    0x0c25 ; CAE
(1)   71/     7A9 : 78                          db    0x78
(1)   72/     7AA : 99 11                       dw    0x1199 ; DLY
(1)   73/     7AC : 8F                          db    0x8f
(1)   74/     7AD : B0 29                       dw    0x29b0 ; JMP
(1)   75/     7AF : 90                          db    0x90
(1)   76/     7B0 : 50 01                       dw    0x0150 ; JP
(1)   77/     7B2 : 94                          db    0x94
(1)   78/     7B3 : 5A 01                       dw    0x015a ; JZ
(1)   79/     7B5 : 98                          db    0x98
(1)   80/     7B6 : DA 29                       dw    0x29da ; JNZ
(1)   81/     7B8 : 9C                          db    0x9c
(1)   82/     7B9 : 84 25                       dw    0x2584 ; ILD
(1)   83/     7BB : A8                          db    0xa8
(1)   84/     7BC : 84 11                       dw    0x1184 ; DLD
(1)   85/     7BE : B8                          db    0xb8
(1)   86/     7BF : 84 01                       dw    0x0184 ; LD
(1)   87/     7C1 : C0                          db    0xc0
(1)   88/     7C2 : 89 30                       dw    0x3089 ; LDI
(1)   89/     7C4 : C4                          db    0xc4
(1)   90/     7C5 : 74 02                       dw    0x0274 ; ST
(1)   91/     7C7 : C8                          db    0xc8
(1)   92/     7C8 : C4 05                       dw    0x05c4 ; AND
(1)   93/     7CA : D0                          db    0xd0
(1)   94/     7CB : C9 05                       dw    0x05c9 ; ANI
(1)   95/     7CD : D4                          db    0xd4
(1)   96/     7CE : F2 01                       dw    0x01f2 ; OR
(1)   97/     7D0 : D8                          db    0xd8
(1)   98/     7D1 : 49 3E                       dw    0x3e49 ; ORI
(1)   99/     7D3 : DC                          db    0xdc
(1)  100/     7D4 : F2 61                       dw    0x61f2 ; XOR
(1)  101/     7D6 : E0                          db    0xe0
(1)  102/     7D7 : 49 62                       dw    0x6249 ; XRI
(1)  103/     7D9 : E4                          db    0xe4
(1)  104/     7DA : 24 10                       dw    0x1024 ; DAD
(1)  105/     7DC : E8                          db    0xe8
(1)  106/     7DD : 29 10                       dw    0x1029 ; DAI
(1)  107/     7DF : EC                          db    0xec
(1)  108/     7E0 : 84 04                       dw    0x0484 ; ADD
(1)  109/     7E2 : F0                          db    0xf0
(1)  110/     7E3 : 89 04                       dw    0x0489 ; ADI
(1)  111/     7E5 : F4                          db    0xf4
(1)  112/     7E6 : 24 0C                       dw    0x0c24 ; CAD
(1)  113/     7E8 : F8                          db    0xf8
(1)  114/     7E9 : 29 0C                       dw    0x0c29 ; CAI
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 23 - 11/30/2015 10:31:02


(1)  115/     7EB : FC                          db    0xfc
(1)  116/     7EC :                     __CommandListEnd:
(1)  117/     7EC : 00 00                       dw    0x0000 ; End Marker	
(1)  118/     7EE :                     
(1)  119/     7EE :                     __CommandTable:
(1)  120/     7EE : 9B 02                       dw    MemoryDump_Command
(1)  121/     7F0 : E4 01                       dw    Address_Command
(1)  122/     7F2 : F7 01                       dw    Go_Command
(1)  123/     7F4 : 04 02                       dw    PutTape_Command
(1)  124/     7F6 : 55 02                       dw    LoadTape_Command
(1)  125/     7F8 : 7C 00                       dw    ClearScreen_Command
(1)  126/     7FA : C5 02                       dw    EnterBytes_Command
(1)  127/     7FC : 7D 02                       dw    Label_Command
(1)  128/     7FE : E7 02                       dw    Disassemble_Command
(1)  129/     800 :                     
    1098/     800 :                     																; the same page.
    1099/     800 :                     
    1100/     800 :                     ; ****************************************************************************************************************
    1101/     800 :                     ;
    1102/     800 :                     ;													Tape Format. 
    1103/     800 :                     ;
    1104/     800 :                     ; ****************************************************************************************************************
    1105/     800 :                     ;
    1106/     800 :                     ;		1 x start bit 		'1' value is held for period of time.
    1107/     800 :                     ;		8 x data bits  		'0 or 1' value is held for a period of time.
    1108/     800 :                     ;		1 x continuation	'0' if another bit follows, '1' if end.
    1109/     800 :                     ;		at least 2 bit times between bytes.
    1110/     800 :                     ;
    1111/     800 :                     ;		Use DLY 4 with A = 0 (DLY 6 to skip half-start)
    1112/     800 :                     ; 		= 13 + 2 * 0 + 514 * 4 microcycles
    1113/     800 :                     ;		= 2,069 microcycles
    1114/     800 :                     ;	
    1115/     800 :                     ;		which is about 240 bits per second.
    1116/     800 :                     ;
    1117/     800 :                     ; ****************************************************************************************************************
    1118/     800 :                     ;
    1119/     800 :                     ;												Monitor Commands
    1120/     800 :                     ;
    1121/     800 :                     ; ****************************************************************************************************************
    1122/     800 :                     ;
    1123/     800 :                     ;		A [aaaa] 			Set current address to aaaa
    1124/     800 :                     ;		B [cc] [dd] [ee]..	Fill memory from current address
    1125/     800 :                     ; 		C 					Clear screen
    1126/     800 :                     ;		D [aaaa] 			Disassemble from aaaa (not complete yet)
    1127/     800 :                     ;		G aaaa 				Run from address - address must be given - return with XPPC P3
    1128/     800 :                     ; 		L n 				Set label n to the current address (up to 32 labels 00-1F)
    1129/     800 :                     ; 		M [aaaa] 			Memory dump from current address/aaaa (6 lines, 4 bytes per line)
    1130/     800 :                     ; 		GET [aaaa] 			Load tape to current address/aaa
    1131/     800 :                     ;		PUT [nnnn]			Write nnnn bytes from current address onwards to tape.
    1132/     800 :                     ;
    1133/     800 :                     ;		Command Line Assembler
    1134/     800 :                     ;
    1135/     800 :                     ;		Standard SC/MP mnemonics, except for XPAH, XPAL, XPPC, HALT and DINT which are XPH XPL XPC HLT DIN
    1136/     800 :                     ;		respectively (4 character mnemonics not supported)
    1137/     800 :                     ;
    1138/     800 :                     ;		Address modes are written as such:
    1139/     800 :                     ;
    1140/     800 :                     ;		Direct:			LD 	address 					(offset auto calculated, also for jump)
    1141/     800 :                     ;		Indexed:		LD  P1 7 						(normally ld 7(p1))
    1142/     800 :                     ;		Immediate:		DLY 42 					
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 24 - 11/30/2015 10:31:02


    1143/     800 :                     ;		AutoIndexed:	LD @P1 4 						(normally ld @4(p1))
    1144/     800 :                     ;
    1145/     800 :                     ;		Labels are accessed via the pling, so to jump to label 4 rather than address 4 you write
    1146/     800 :                     ;
    1147/     800 :                     ;		JMP 4!
    1148/     800 :                     ;
    1149/     800 :                     ; ****************************************************************************************************************
    1150/     800 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 25 - 11/30/2015 10:31:02


  symbol table (* = unused):
  ------------------------

 ADDRESS_COMMAND :              1E4 C | *ARCHITECTURE :  i386-unknown-win32 - |
*BIGENDIAN :                      0 - |  BOOTMONITOR :                   5E C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CLEARSCREENLOOP :               81 C |  CLEARSCREEN_COMMAND :           7C C |
 CODESTART :                    C35 - |  COMMANDMAINLOOP :               93 C |
*CONSTPI :        3.141592653589793 - |  CURRENT :                      C21 - |
 CURSOR :                       C20 - | *DATE :                  11/30/2015 - |
 DISASSEMBLE_COMMAND :          2E7 C |  ENTERBYTES_COMMAND :           2C5 C |
 EXTRACT5BIT :                   FE C | *FALSE :                          0 - |
 FINDTOPMEMORY :                 66 C | *FULLPMMU :                       1 - |
*GETCURRENTADDRESS :            527 C |  GETPARAMETER :                 487 C |
*GOBOOT :                         3 C |  GO_COMMAND :                   1F7 C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - |  KBDBUFFER :                    C25 - |
 KBDBUFFERLN :                   10 - |  KEYBOARDLOOP :                  A8 C |
 LABELCOUNT :                    20 - |  LABELS :                       C00 - |
 LABEL_COMMAND :                27D C | *LISTON :                         1 - |
 LOADTAPE_COMMAND :             255 C | *MACEXP :                         1 - |
 MATHS :                          A C |  MATH_ADD :                      30 C |
 MATH_EXIT :                     2E C |  MATH_MULTIPLY :                 4E C |
 MATH_SUBTRACT :                 3F C |  MEMORYDUMP_COMMAND :           29B C |
 MODIFIER :                     C24 - | *MOMCPU :                         C - |
*MOMCPUNAME :                 SC/MP - |  N1 :                             D - |
 N2 :                            10 - | *NESTMAX :                      100 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PARPOSN :                      C23 - |  PRINTADDRESSDATA :             454 C |
 PRINTCHARACTER :               3E7 C |  PRINTHEXBYTE :                 3B4 C |
 PUTTAPE_COMMAND :              204 C | *RELAXED :                        0 - |
 TAPEDELAY :                      4 - | *TIME :                    10:31:02 - |
*TRUE :                           1 - | *UPDATECURRENTADDRESS :         517 C |
 VARBASE :                      C20 - | *VERSION :                     142F - |
 _KBDWAITKEY :                   B1 C |  _KBDWAITRELEASE :               AB C |
 _PADLOOP :                     474 C |  _PADPRINT :                    481 C |
 _PUTTAPEBIT :                  234 C |  _PUTTAPEBYTE :                 21F C |
 _PUTTAPELEADER :               219 C |  __ASMCONTINUE :                1A2 C |
 __ASMEXIT :                    1DA C |  __ASMNOPARAMETER :             19A C |
 __ASSEMBLER :                  16B C |  __CMDMAINLOOP1 :                EF C |
 __CMDMAINLOOP2 :               1F0 C |  __CMDMAINLOOP3 :               202 C |
 __CMDMAINLOOP4 :               251 C |  __CMDMAINLOOP5 :               27B C |
 __CMDMAINLOOP6 :               2C3 C |  __CMDMAINLOOP7 :               32F C |
 __CMDPARAMETERFAIL :           1E8 C |  __CMDPARAMETERFAIL1 :          253 C |
 __COMMANDERROR :               161 C |  __COMMANDLIST :                747 C |
 __COMMANDLISTEND :             7EC C |  __COMMANDTABLE :               7EE C |
 __DASSFINDOPCODE :             316 C |  __DASSFOUNDOPCODE :            331 C |
 __DASSLOOP :                   2ED C |  __DASSLOOP2 :                  32D C |
 __DASSNEXT :                   38B C |  __DASSNEXTOPCODE :             329 C |
 __DASSNOOPERAND :              30C C |  __DASSNOTAUTOINDEXED :         3A8 C |
 __DASSNOTIMMEDIATE :           33D C |  __DASSPRINTMNEMONIC :          352 C |
 __DASSPRINTMODIFIER :          39C C |  __DASSPRINTOPERAND :           37D C |
 __DASSSHIFTENCODE :            362 C |  __DASSSKIPSPACE :              35E C |
 __DCLOOP :                     2A1 C |  __EX5SHIFT :                   109 C |
 __EXTRACTEND :                 11F C |  __FINDCOMMANDLOOP :            12A C |
 __GETTAPEBITS :                26B C |  __GETTAPEWAIT :                25B C |
 __GPAADJUSTMODIFIER :          504 C |  __GPAATMODIFIER :              502 C |
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 26 - 11/30/2015 10:31:02


 __GPAEXIT :                    516 C |  __GPAEXITFAIL :                515 C |
 __GPAFOUNDHEX :                4BD C |  __GPANEXTCHARACTER :           4A8 C |
 __GPAPOINTERMODIFIER :         4F4 C |  __GPASHIFT :                   4C7 C |
 __GPASKIP :                    496 C |  __KBDBACKSPACE :                E3 C |
 __KBDEXIT :                     F1 C |  __KBDNOTLOWER :                 D7 C |
 __PCBACKSPACE :                43C C |  __PCBLANKNEWLINE :             418 C |
 __PCBLANKNEWLINELOOP :         41C C |  __PCEXIT :                     424 C |
 __PCNEWLINE :                  448 C |  __PHBNOSPACE :                 3C6 C |
 __UCAEXIT :                    526 C |

    131 symbols
     31 unused symbols

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 27 - 11/30/2015 10:31:02


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

   1388 lines source file
      2 passes
      0 errors
      0 warnings
